‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  Byaboneka+ Backend                                        ‚ïë
‚ïë  Project Code Dump ‚Äî AI Review Edition                      ‚ïë
‚ïë  Generated: 2026-02-14T17:57:55.598Z                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  PROJECT SUMMARY
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  Files included:  63
  Total lines:     16,555
  Total size:      549.2 KB
  Languages:       YAML (2), TypeScript (53), Text (4), JSON (3), JavaScript (1)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  DIRECTORY STRUCTURE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  backend/
  ‚îú‚îÄ‚îÄ src/
  ‚îÇ   ‚îú‚îÄ‚îÄ config/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.ts (2.1 KB)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ swagger.ts (51.7 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ adminController.ts (10.1 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ authController.ts (16.6 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ claimsController.ts (19.5 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cooperativesController.ts (10.5 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ foundItemsController.ts (11.9 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lostItemsController.ts (13.1 KB)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ messagesController.ts (8.9 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ middleware/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.ts (6.1 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emailVerification.ts (2.5 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ errorHandler.ts (2.2 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts (85 B)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rateLimiter.ts (4.3 KB)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.ts (8.1 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ migrations/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001_initial.ts (20.5 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 002_patch.ts (0 B)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rollback.ts (398 B)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ run.ts (395 B)
  ‚îÇ   ‚îú‚îÄ‚îÄ routes/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ enhancedRoutes.ts (14.4 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts (9.2 KB)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ novelFeatureRoutes.ts (7.0 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ seeds/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ run.ts (50.0 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ services/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auditService.ts (6.5 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cooperativeAccountabilityService.ts (13.6 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ disputeService.ts (12.6 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ duplicateDetectionService.ts (10.0 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ emailVerificationService.ts (4.6 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ expiryService.ts (5.9 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fraudDetectionService.ts (14.7 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ matchingService.ts (9.8 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ otpService.ts (10.8 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sensitiveRedactionService.ts (8.3 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trustService.ts (6.7 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verificationAttemptsService.ts (2.0 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ verificationCooldownService.ts (7.1 KB)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ verificationStrengthService.ts (13.2 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ types/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts (7.4 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ utils/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts (12.0 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ index.swagger-patch.ts (1016 B)
  ‚îÇ   ‚îî‚îÄ‚îÄ index.ts (6.5 KB)
  ‚îú‚îÄ‚îÄ tests/
  ‚îÇ   ‚îú‚îÄ‚îÄ integration/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.test.ts (12.1 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ unit/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ matching.test.ts (5.2 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware.test.ts (4.0 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ novel-features.test.ts (8.9 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trust.test.ts (3.4 KB)
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils.test.ts (5.8 KB)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.test.ts (6.4 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ integration.test.ts (7.1 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ matching.test.ts (4.3 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ setup.ts (596 B)
  ‚îÇ   ‚îú‚îÄ‚îÄ trust.test.ts (4.8 KB)
  ‚îÇ   ‚îú‚îÄ‚îÄ utils.test.ts (13.0 KB)
  ‚îÇ   ‚îî‚îÄ‚îÄ validation.test.ts (10.3 KB)
  ‚îú‚îÄ‚îÄ .dockerignore (219 B)
  ‚îú‚îÄ‚îÄ .env (804 B)
  ‚îú‚îÄ‚îÄ .env.backup (804 B)
  ‚îú‚îÄ‚îÄ .env.example (792 B)
  ‚îú‚îÄ‚îÄ .env.production (725 B)
  ‚îú‚îÄ‚îÄ Byaboneka_Plus_API.postman_collection.json (27.8 KB)
  ‚îú‚îÄ‚îÄ docker-compose.yml (1.1 KB)
  ‚îú‚îÄ‚îÄ Dockerfile (1.3 KB)
  ‚îú‚îÄ‚îÄ jest.config.js (773 B)
  ‚îú‚îÄ‚îÄ package.json (2.3 KB)
  ‚îî‚îÄ‚îÄ tsconfig.json (521 B)

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
  TABLE OF CONTENTS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

  üìÅ .github/
      1. .github/workflows/ci.yml  [175 lines | YAML]

  üìÅ src/
      1. src/config/database.ts  [86 lines | TypeScript]
      2. src/config/swagger.ts  [1231 lines | TypeScript]
      3. src/controllers/adminController.ts  [308 lines | TypeScript]
      4. src/controllers/authController.ts  [639 lines | TypeScript]
      5. src/controllers/claimsController.ts  [643 lines | TypeScript]
      6. src/controllers/cooperativesController.ts  [336 lines | TypeScript]
      7. src/controllers/foundItemsController.ts  [360 lines | TypeScript]
      8. src/controllers/lostItemsController.ts  [465 lines | TypeScript]
      9. src/controllers/messagesController.ts  [280 lines | TypeScript]
     10. src/middleware/auth.ts  [262 lines | TypeScript]
     11. src/middleware/emailVerification.ts  [101 lines | TypeScript]
     12. src/middleware/errorHandler.ts  [108 lines | TypeScript]
     13. src/middleware/index.ts  [4 lines | TypeScript]
     14. src/middleware/rateLimiter.ts  [151 lines | TypeScript]
     15. src/middleware/validation.ts  [227 lines | TypeScript]
     16. src/migrations/001_initial.ts  [481 lines | TypeScript]
     17. src/migrations/rollback.ts  [20 lines | TypeScript]
     18. src/migrations/run.ts  [20 lines | TypeScript]
     19. src/routes/enhancedRoutes.ts  [547 lines | TypeScript]
     20. src/routes/index.ts  [405 lines | TypeScript]
     21. src/routes/novelFeatureRoutes.ts  [238 lines | TypeScript]
     22. src/seeds/run.ts  [654 lines | TypeScript]
     23. src/services/auditService.ts  [272 lines | TypeScript]
     24. src/services/cooperativeAccountabilityService.ts  [322 lines | TypeScript]
     25. src/services/disputeService.ts  [458 lines | TypeScript]
     26. src/services/duplicateDetectionService.ts  [343 lines | TypeScript]
     27. src/services/emailVerificationService.ts  [188 lines | TypeScript]
     28. src/services/expiryService.ts  [210 lines | TypeScript]
     29. src/services/fraudDetectionService.ts  [413 lines | TypeScript]
     30. src/services/matchingService.ts  [315 lines | TypeScript]
     31. src/services/otpService.ts  [371 lines | TypeScript]
     32. src/services/sensitiveRedactionService.ts  [261 lines | TypeScript]
     33. src/services/trustService.ts  [287 lines | TypeScript]
     34. src/services/verificationAttemptsService.ts  [62 lines | TypeScript]
     35. src/services/verificationCooldownService.ts  [264 lines | TypeScript]
     36. src/services/verificationStrengthService.ts  [311 lines | TypeScript]
     37. src/types/index.ts  [380 lines | TypeScript]
     38. src/utils/index.ts  [374 lines | TypeScript]
     39. src/index.swagger-patch.ts  [32 lines | TypeScript]
     40. src/index.ts  [216 lines | TypeScript]

  üìÅ tests/
      1. tests/integration/api.test.ts  [319 lines | TypeScript]
      2. tests/unit/matching.test.ts  [143 lines | TypeScript]
      3. tests/unit/middleware.test.ts  [132 lines | TypeScript]
      4. tests/unit/novel-features.test.ts  [262 lines | TypeScript]
      5. tests/unit/trust.test.ts  [114 lines | TypeScript]
      6. tests/unit/utils.test.ts  [167 lines | TypeScript]
      7. tests/unit/validation.test.ts  [191 lines | TypeScript]
      8. tests/integration.test.ts  [230 lines | TypeScript]
      9. tests/matching.test.ts  [126 lines | TypeScript]
     10. tests/setup.ts  [25 lines | TypeScript]
     11. tests/trust.test.ts  [143 lines | TypeScript]
     12. tests/utils.test.ts  [395 lines | TypeScript]
     13. tests/validation.test.ts  [383 lines | TypeScript]

  üìÅ (root)/
      1. .dockerignore  [18 lines | Text]
      2. .env.example  [35 lines | Text]
      3. .gitignore  [107 lines | Text]
      4. Byaboneka_Plus_API.postman_collection.json  [711 lines | JSON]
      5. docker-compose.yml  [44 lines | YAML]
      6. Dockerfile  [55 lines | Text]
      7. jest.config.js  [35 lines | JavaScript]
      8. package.json  [73 lines | JSON]
      9. tsconfig.json  [27 lines | JSON]




‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                      SOURCE CODE FILES                      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù


‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  SECTION: .github/
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: .github/workflows/ci.yml
‚îÇ Language: YAML | Lines: 175 | Size: 4.8 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

name: Byaboneka+ CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  NODE_VERSION: '20'

jobs:
  # ============================================
  # JOB 1: Lint & Type Check
  # ============================================
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: TypeScript type check
        run: npx tsc --noEmit

      - name: ESLint
        run: npm run lint
        continue-on-error: true

  # ============================================
  # JOB 2: Unit Tests
  # ============================================
  test-unit:
    name: Unit Tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit
        env:
          NODE_ENV: test

  # ============================================
  # JOB 3: Integration Tests
  # ============================================
  test-integration:
    name: Integration Tests
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: byaboneka_test
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: byaboneka_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run integration tests
        run: npm run test:integration
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://byaboneka_test:test_password@localhost:5432/byaboneka_test
          JWT_SECRET: test_jwt_secret_min_32_characters_long!!
          JWT_REFRESH_SECRET: test_refresh_secret_min_32_chars_long!!
          CORS_ORIGIN: http://localhost:3000

  # ============================================
  # JOB 4: Test Coverage Report
  # ============================================
  coverage:
    name: Coverage Report
    runs-on: ubuntu-latest
    needs: [test-unit]
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage
        env:
          NODE_ENV: test

      - name: Upload coverage artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/

  # ============================================
  # JOB 5: Docker Build
  # ============================================
  docker-build:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: [lint, test-unit]
    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t byaboneka-plus-api:${{ github.sha }} .

      - name: Test Docker health
        run: |
          docker run -d --name test-api \
            -e NODE_ENV=production \
            -e DATABASE_URL=postgresql://x:x@localhost/x \
            -e JWT_SECRET=test_jwt_secret_min_32_characters_long!! \
            -e JWT_REFRESH_SECRET=test_refresh_secret_min_32_chars!! \
            -p 4000:4000 \
            byaboneka-plus-api:${{ github.sha }} || true
          sleep 5
          docker logs test-api
          docker stop test-api || true

  # ============================================
  # JOB 6: Deploy to Render (main branch only)
  # ============================================
  deploy:
    name: Deploy to Render
    runs-on: ubuntu-latest
    needs: [lint, test-unit, test-integration, docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - name: Trigger Render Deploy
        run: |
          curl -X POST "${{ secrets.RENDER_DEPLOY_HOOK }}" \
            -H "Content-Type: application/json" \
            --fail --silent --show-error
        env:
          RENDER_DEPLOY_HOOK: ${{ secrets.RENDER_DEPLOY_HOOK }}



‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  SECTION: src/
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/config/database.ts
‚îÇ Language: TypeScript | Lines: 86 | Size: 2.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Pool, PoolClient, PoolConfig, QueryResult, QueryResultRow } from 'pg';
import dotenv from 'dotenv';

dotenv.config();

const poolConfig: PoolConfig = {
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 30000,
};

// Add SSL for production
if (process.env.NODE_ENV === 'production') {
  poolConfig.ssl = {
    rejectUnauthorized: false // Render managed DB uses self-signed certs
  };
}

const pool = new Pool(poolConfig);

// Connection event handlers
pool.on('connect', () => {
  console.log('üì¶ Database connected');
});

pool.on('error', (err) => {
  // Log but do NOT crash ‚Äî transient errors should not kill the server
  console.error('‚ùå Unexpected database pool error:', err.message);
});

// Query helper with type safety
export async function query<T extends QueryResultRow = any>(
  text: string,
  params?: any[]
): Promise<QueryResult<T>> {
  const start = Date.now();
  try {
    const result = await pool.query<T>(text, params);
    const duration = Date.now() - start;
    if (process.env.NODE_ENV === 'development') {
      console.log('üìù Query executed:', { text: text.substring(0, 100), duration, rows: result.rowCount });
    }
    return result;
  } catch (error) {
    console.error('‚ùå Query error:', { text: text.substring(0, 100), error });
    throw error;
  }
}

// Transaction helper
export async function transaction<T>(
  callback: (client: PoolClient) => Promise<T>
): Promise<T> {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const result = await callback(client);
    await client.query('COMMIT');
    return result;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Connection check
export async function checkConnection(): Promise<boolean> {
  try {
    await pool.query('SELECT 1');
    return true;
  } catch (error) {
    console.error('‚ùå Database connection check failed:', error);
    return false;
  }
}

// Graceful shutdown
export async function closePool(): Promise<void> {
  await pool.end();
  console.log('üì¶ Database pool closed');
}

export default pool;


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/config/swagger.ts
‚îÇ Language: TypeScript | Lines: 1231 | Size: 51.7 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import swaggerJsdoc from 'swagger-jsdoc';

const options: swaggerJsdoc.Options = {
  definition: {
    openapi: '3.0.3',
    info: {
      title: 'Byaboneka+ API',
      version: '1.0.0',
      description: `
## Trust-Aware Lost & Found Infrastructure for Rwanda

Byaboneka+ provides a comprehensive platform for lost and found item management
across Rwanda's transport ecosystem. The API supports citizen reporting, cooperative
integration, intelligent matching, fraud-resistant verification, and secure OTP-based
handover protocols.

### Key Features
- **Private Verification** ‚Äî Owners set secret questions only they can answer
- **OTP Handover** ‚Äî One-time codes ensure items are returned after physical exchange
- **Cooperative Integration** ‚Äî Transport cooperatives serve as trusted intermediaries
- **Trust Scoring** ‚Äî Behavioral tracking discourages abuse and rewards good actors
- **Explainable Matching** ‚Äî Transparent logic builds user confidence in system suggestions

### Authentication
All protected endpoints require a Bearer token in the Authorization header.
Access tokens expire after 15 minutes. Use the refresh token endpoint to obtain new tokens.

### Rate Limits
- Authentication: 10 requests / 15 minutes
- Report creation: 5 / hour
- Claim attempts: 3 / hour
- Verification: 5 / hour
- Messages: 50 / hour
- General API: 100 / minute
      `,
      contact: {
        name: 'MAYALA Plamedi',
        email: 'p.mayala@alustudent.com',
      },
      license: {
        name: 'MIT',
        url: 'https://opensource.org/licenses/MIT',
      },
    },
    servers: [
      {
        url: '/api/v1',
        description: 'API v1',
      },
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: 'http',
          scheme: 'bearer',
          bearerFormat: 'JWT',
          description: 'Enter your JWT access token',
        },
      },
      schemas: {
        // ====== Common ======
        ApiResponse: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            message: { type: 'string' },
          },
        },
        PaginationMeta: {
          type: 'object',
          properties: {
            page: { type: 'integer', example: 1 },
            limit: { type: 'integer', example: 20 },
            total: { type: 'integer', example: 150 },
            totalPages: { type: 'integer', example: 8 },
          },
        },
        ErrorResponse: {
          type: 'object',
          properties: {
            success: { type: 'boolean', example: false },
            message: { type: 'string', example: 'Validation failed' },
            errors: {
              type: 'array',
              items: {
                type: 'object',
                properties: {
                  field: { type: 'string' },
                  message: { type: 'string' },
                },
              },
            },
          },
        },

        // ====== Auth ======
        RegisterRequest: {
          type: 'object',
          required: ['email', 'password', 'name'],
          properties: {
            email: { type: 'string', format: 'email', example: 'jean@example.com' },
            password: { type: 'string', minLength: 8, example: 'MySecure1Pass' },
            name: { type: 'string', example: 'Jean Habimana' },
            phone: { type: 'string', example: '+250788123456' },
          },
        },
        LoginRequest: {
          type: 'object',
          required: ['email', 'password'],
          properties: {
            email: { type: 'string', format: 'email', example: 'jean@example.com' },
            password: { type: 'string', example: 'MySecure1Pass' },
          },
        },
        AuthResponse: {
          type: 'object',
          properties: {
            success: { type: 'boolean', example: true },
            data: {
              type: 'object',
              properties: {
                user: { $ref: '#/components/schemas/UserProfile' },
                tokens: {
                  type: 'object',
                  properties: {
                    accessToken: { type: 'string' },
                    refreshToken: { type: 'string' },
                  },
                },
              },
            },
          },
        },
        RefreshTokenRequest: {
          type: 'object',
          required: ['refreshToken'],
          properties: {
            refreshToken: { type: 'string' },
          },
        },
        ForgotPasswordRequest: {
          type: 'object',
          required: ['email'],
          properties: {
            email: { type: 'string', format: 'email' },
          },
        },
        ResetPasswordRequest: {
          type: 'object',
          required: ['token', 'password'],
          properties: {
            token: { type: 'string' },
            password: { type: 'string', minLength: 8 },
          },
        },
        ChangePasswordRequest: {
          type: 'object',
          required: ['currentPassword', 'newPassword'],
          properties: {
            currentPassword: { type: 'string' },
            newPassword: { type: 'string', minLength: 8 },
          },
        },

        // ====== Users ======
        UserProfile: {
          type: 'object',
          properties: {
            id: { type: 'integer', example: 1 },
            email: { type: 'string', example: 'jean@example.com' },
            name: { type: 'string', example: 'Jean Habimana' },
            phone: { type: 'string', example: '+250788123456', nullable: true },
            role: { type: 'string', enum: ['citizen', 'coop_staff', 'admin'], example: 'citizen' },
            trust_score: { type: 'integer', example: 5 },
            email_verified: { type: 'boolean', example: false },
            cooperative_name: { type: 'string', nullable: true },
            created_at: { type: 'string', format: 'date-time' },
          },
        },

        // ====== Lost Items ======
        CreateLostItemRequest: {
          type: 'object',
          required: ['category', 'title', 'description', 'location_area', 'lost_date', 'verification_questions'],
          properties: {
            category: { type: 'string', enum: ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'], example: 'PHONE' },
            title: { type: 'string', example: 'Samsung Galaxy S23 Ultra' },
            description: { type: 'string', example: 'Black Samsung phone with cracked screen protector, blue case' },
            location_area: { type: 'string', example: 'Nyabugogo' },
            location_hint: { type: 'string', example: 'Near the main bus station' },
            lost_date: { type: 'string', format: 'date-time', example: '2026-02-10T14:00:00Z' },
            photo_url: { type: 'string', format: 'uri', nullable: true },
            verification_questions: {
              type: 'array',
              minItems: 3,
              maxItems: 3,
              items: {
                type: 'object',
                required: ['question', 'answer'],
                properties: {
                  question: { type: 'string', example: 'What is your phone wallpaper?' },
                  answer: { type: 'string', example: 'my dog' },
                },
              },
            },
          },
        },
        LostItem: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            user_id: { type: 'integer' },
            category: { type: 'string', enum: ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'] },
            title: { type: 'string' },
            description: { type: 'string' },
            location_area: { type: 'string' },
            location_hint: { type: 'string', nullable: true },
            lost_date: { type: 'string', format: 'date-time' },
            status: { type: 'string', enum: ['ACTIVE', 'CLAIMED', 'RETURNED', 'EXPIRED'] },
            keywords: { type: 'array', items: { type: 'string' } },
            photo_url: { type: 'string', nullable: true },
            created_at: { type: 'string', format: 'date-time' },
            updated_at: { type: 'string', format: 'date-time' },
          },
        },

        // ====== Found Items ======
        CreateFoundItemRequest: {
          type: 'object',
          required: ['category', 'title', 'description', 'location_area', 'found_date'],
          properties: {
            category: { type: 'string', enum: ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'], example: 'PHONE' },
            title: { type: 'string', example: 'Black Samsung phone found on bus' },
            description: { type: 'string', example: 'Found a black Samsung phone on the seat of bus KBS-205' },
            location_area: { type: 'string', example: 'Nyabugogo' },
            location_hint: { type: 'string', example: 'KBS Bus #205, route Nyabugogo-Kimironko' },
            found_date: { type: 'string', format: 'date-time', example: '2026-02-10T16:30:00Z' },
            cooperative_id: { type: 'integer', nullable: true, description: 'For cooperative staff only' },
          },
        },
        FoundItem: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            finder_id: { type: 'integer' },
            cooperative_id: { type: 'integer', nullable: true },
            category: { type: 'string', enum: ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'] },
            title: { type: 'string' },
            description: { type: 'string' },
            location_area: { type: 'string' },
            found_date: { type: 'string', format: 'date-time' },
            status: { type: 'string', enum: ['UNCLAIMED', 'MATCHED', 'RETURNED', 'EXPIRED'] },
            source: { type: 'string', enum: ['CITIZEN', 'COOPERATIVE'] },
            image_urls: { type: 'array', items: { type: 'string' } },
            keywords: { type: 'array', items: { type: 'string' } },
            created_at: { type: 'string', format: 'date-time' },
          },
        },

        // ====== Claims ======
        CreateClaimRequest: {
          type: 'object',
          required: ['lost_item_id', 'found_item_id'],
          properties: {
            lost_item_id: { type: 'integer', example: 1 },
            found_item_id: { type: 'integer', example: 1 },
          },
        },
        VerifyClaimRequest: {
          type: 'object',
          required: ['answers'],
          properties: {
            answers: {
              type: 'array',
              minItems: 3,
              maxItems: 3,
              items: { type: 'string' },
              example: ['my dog', 'gasabo', '1990'],
            },
          },
        },
        Claim: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            lost_item_id: { type: 'integer' },
            found_item_id: { type: 'integer' },
            claimant_id: { type: 'integer' },
            status: { type: 'string', enum: ['PENDING', 'VERIFIED', 'REJECTED', 'RETURNED', 'DISPUTED', 'CANCELLED', 'EXPIRED'] },
            verification_score: { type: 'number', format: 'float' },
            attempts_made: { type: 'integer' },
            created_at: { type: 'string', format: 'date-time' },
          },
        },
        VerificationQuestionsResponse: {
          type: 'object',
          properties: {
            success: { type: 'boolean', example: true },
            data: {
              type: 'object',
              properties: {
                claim_id: { type: 'integer' },
                questions: { type: 'array', items: { type: 'string' }, example: ['What is your wallpaper?', 'What color is the case?', 'What is the lock screen?'] },
                attempts_remaining: { type: 'integer', example: 3 },
              },
            },
          },
        },
        VerificationResultResponse: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            data: {
              type: 'object',
              properties: {
                passed: { type: 'boolean' },
                score: { type: 'integer', example: 2 },
                attempts_remaining: { type: 'integer' },
                message: { type: 'string' },
              },
            },
          },
        },

        // ====== Handover ======
        OTPGenerateResponse: {
          type: 'object',
          properties: {
            success: { type: 'boolean', example: true },
            data: {
              type: 'object',
              properties: {
                otp: { type: 'string', example: '847291' },
                expires_in: { type: 'string', example: '24 hours' },
                message: { type: 'string' },
              },
            },
          },
        },
        OTPVerifyRequest: {
          type: 'object',
          required: ['otp'],
          properties: {
            otp: { type: 'string', pattern: '^\\d{6}$', example: '847291' },
          },
        },

        // ====== Messages ======
        SendMessageRequest: {
          type: 'object',
          required: ['content'],
          properties: {
            content: { type: 'string', maxLength: 1000, example: 'Hi, I found your phone. When can we meet?' },
          },
        },
        Message: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            sender_id: { type: 'integer' },
            receiver_id: { type: 'integer' },
            claim_id: { type: 'integer' },
            content: { type: 'string' },
            is_read: { type: 'boolean' },
            is_flagged: { type: 'boolean' },
            created_at: { type: 'string', format: 'date-time' },
          },
        },

        // ====== Cooperatives ======
        CreateCooperativeRequest: {
          type: 'object',
          required: ['name', 'registration_number', 'contact_info'],
          properties: {
            name: { type: 'string', example: 'Kigali Bus Services (KBS)' },
            registration_number: { type: 'string', example: 'RW-COOP-2024-001' },
            contact_info: { type: 'string', example: '+250788000111' },
            address: { type: 'string', example: 'Nyabugogo Terminal, Kigali' },
          },
        },
        Cooperative: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            name: { type: 'string' },
            registration_number: { type: 'string' },
            status: { type: 'string', enum: ['PENDING', 'VERIFIED', 'SUSPENDED'] },
            contact_info: { type: 'string' },
            address: { type: 'string', nullable: true },
            staff_count: { type: 'integer' },
            items_count: { type: 'integer' },
            created_at: { type: 'string', format: 'date-time' },
          },
        },

        // ====== Disputes ======
        CreateDisputeRequest: {
          type: 'object',
          required: ['reason'],
          properties: {
            reason: { type: 'string', minLength: 20, example: 'I forgot the exact answer to question 2 but this is definitely my phone. I can show the purchase receipt.' },
            evidence_urls: { type: 'array', items: { type: 'string', format: 'uri' } },
          },
        },
        ResolveDisputeRequest: {
          type: 'object',
          required: ['resolution', 'resolution_notes'],
          properties: {
            resolution: { type: 'string', enum: ['RESOLVED_OWNER', 'RESOLVED_FINDER', 'DISMISSED'] },
            resolution_notes: { type: 'string', example: 'Owner provided purchase receipt as proof.' },
          },
        },

        // ====== Matches ======
        MatchResult: {
          type: 'object',
          properties: {
            found_item: { $ref: '#/components/schemas/FoundItem' },
            score: { type: 'integer', example: 11, description: 'Match confidence score (min 5 to display)' },
            explanation: {
              type: 'array',
              items: { type: 'string' },
              example: ['Category: PHONE (+5)', 'Same location area: Nyabugogo (+3)', 'Within 72 hours (+2)', 'Keyword: samsung (+1)'],
            },
          },
        },

        // ====== Admin ======
        DashboardStats: {
          type: 'object',
          properties: {
            total_users: { type: 'integer' },
            total_lost_items: { type: 'integer' },
            total_found_items: { type: 'integer' },
            total_claims: { type: 'integer' },
            successful_returns: { type: 'integer' },
            pending_scam_reports: { type: 'integer' },
          },
        },
        BanUserRequest: {
          type: 'object',
          required: ['reason'],
          properties: {
            reason: { type: 'string', example: 'Repeated fraudulent claim attempts' },
          },
        },
        AuditLog: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            actor_id: { type: 'integer' },
            action: { type: 'string' },
            resource_type: { type: 'string' },
            resource_id: { type: 'integer' },
            changes: { type: 'object' },
            ip_address: { type: 'string' },
            timestamp: { type: 'string', format: 'date-time' },
          },
        },
        ScamReport: {
          type: 'object',
          properties: {
            id: { type: 'integer' },
            reporter_id: { type: 'integer' },
            reported_user_id: { type: 'integer' },
            reason: { type: 'string' },
            status: { type: 'string', enum: ['OPEN', 'INVESTIGATING', 'RESOLVED'] },
            created_at: { type: 'string', format: 'date-time' },
          },
        },
      },
      parameters: {
        PageParam: {
          name: 'page',
          in: 'query',
          schema: { type: 'integer', minimum: 1, default: 1 },
        },
        LimitParam: {
          name: 'limit',
          in: 'query',
          schema: { type: 'integer', minimum: 1, maximum: 100, default: 20 },
        },
        CategoryFilter: {
          name: 'category',
          in: 'query',
          schema: { type: 'string', enum: ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'] },
        },
        LocationFilter: {
          name: 'location_area',
          in: 'query',
          schema: { type: 'string' },
          description: 'Filter by sector/neighborhood (partial match)',
        },
        KeywordFilter: {
          name: 'keyword',
          in: 'query',
          schema: { type: 'string' },
          description: 'Search in title and description',
        },
      },
      responses: {
        Unauthorized: {
          description: 'Missing or invalid authentication token',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  success: { type: 'boolean', example: false },
                  message: { type: 'string', example: 'Access token required' },
                },
              },
            },
          },
        },
        Forbidden: {
          description: 'Insufficient permissions',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  success: { type: 'boolean', example: false },
                  message: { type: 'string', example: 'Admin access required' },
                },
              },
            },
          },
        },
        NotFound: {
          description: 'Resource not found',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  success: { type: 'boolean', example: false },
                  message: { type: 'string', example: 'Resource not found' },
                },
              },
            },
          },
        },
        RateLimited: {
          description: 'Too many requests',
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  success: { type: 'boolean', example: false },
                  message: { type: 'string', example: 'Too many requests. Please try again later.' },
                },
              },
            },
          },
        },
        ValidationError: {
          description: 'Validation error',
          content: {
            'application/json': {
              schema: { $ref: '#/components/schemas/ErrorResponse' },
            },
          },
        },
      },
    },
    tags: [
      { name: 'Authentication', description: 'User registration, login, token management, password reset' },
      { name: 'Lost Items', description: 'Report, search, and manage lost item reports' },
      { name: 'Found Items', description: 'Report, search, and manage found item reports' },
      { name: 'Matching', description: 'Intelligent matching between lost and found items' },
      { name: 'Claims & Verification', description: 'Claim ownership and verify via secret questions' },
      { name: 'Handover', description: 'OTP-based secure item return protocol' },
      { name: 'Disputes', description: 'Dispute resolution for edge cases' },
      { name: 'Messages', description: 'In-app messaging between claim participants' },
      { name: 'Cooperatives', description: 'Transport cooperative management' },
      { name: 'Admin', description: 'System administration and moderation' },
      { name: 'System', description: 'Health checks and system status' },
    ],
    paths: {
      // ============================
      // AUTHENTICATION
      // ============================
      '/auth/register': {
        post: {
          tags: ['Authentication'],
          summary: 'Register a new user account',
          description: 'Creates a new citizen account with email and password. Returns JWT tokens for immediate use.',
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/RegisterRequest' } } } },
          responses: {
            201: { description: 'Registration successful', content: { 'application/json': { schema: { $ref: '#/components/schemas/AuthResponse' } } } },
            409: { description: 'Email or phone already registered' },
            400: { $ref: '#/components/responses/ValidationError' },
            429: { $ref: '#/components/responses/RateLimited' },
          },
        },
      },
      '/auth/login': {
        post: {
          tags: ['Authentication'],
          summary: 'Login with email and password',
          description: 'Authenticates user and returns JWT access and refresh tokens.',
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/LoginRequest' } } } },
          responses: {
            200: { description: 'Login successful', content: { 'application/json': { schema: { $ref: '#/components/schemas/AuthResponse' } } } },
            401: { description: 'Invalid credentials' },
            403: { description: 'Account suspended' },
            429: { $ref: '#/components/responses/RateLimited' },
          },
        },
      },
      '/auth/refresh': {
        post: {
          tags: ['Authentication'],
          summary: 'Refresh access token',
          description: 'Exchange a valid refresh token for a new access token and refresh token pair.',
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/RefreshTokenRequest' } } } },
          responses: {
            200: { description: 'Tokens refreshed' },
            401: { description: 'Invalid or expired refresh token' },
          },
        },
      },
      '/auth/logout': {
        post: {
          tags: ['Authentication'],
          summary: 'Logout and revoke tokens',
          security: [{ bearerAuth: [] }],
          requestBody: { content: { 'application/json': { schema: { type: 'object', properties: { refreshToken: { type: 'string' } } } } } },
          responses: { 200: { description: 'Logged out' } },
        },
      },
      '/auth/forgot-password': {
        post: {
          tags: ['Authentication'],
          summary: 'Request password reset',
          description: 'Sends a password reset token. Always returns success to prevent email enumeration.',
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/ForgotPasswordRequest' } } } },
          responses: { 200: { description: 'Reset email sent (if account exists)' } },
        },
      },
      '/auth/reset-password': {
        post: {
          tags: ['Authentication'],
          summary: 'Reset password with token',
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/ResetPasswordRequest' } } } },
          responses: {
            200: { description: 'Password reset successful' },
            400: { description: 'Invalid or expired token' },
          },
        },
      },
      '/auth/profile': {
        get: {
          tags: ['Authentication'],
          summary: 'Get current user profile',
          security: [{ bearerAuth: [] }],
          responses: {
            200: { description: 'Profile data', content: { 'application/json': { schema: { type: 'object', properties: { success: { type: 'boolean' }, data: { $ref: '#/components/schemas/UserProfile' } } } } } },
            401: { $ref: '#/components/responses/Unauthorized' },
          },
        },
        put: {
          tags: ['Authentication'],
          summary: 'Update user profile',
          security: [{ bearerAuth: [] }],
          requestBody: { content: { 'application/json': { schema: { type: 'object', properties: { name: { type: 'string' }, phone: { type: 'string' } } } } } },
          responses: { 200: { description: 'Profile updated' } },
        },
      },
      '/auth/change-password': {
        post: {
          tags: ['Authentication'],
          summary: 'Change password (logged-in user)',
          security: [{ bearerAuth: [] }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/ChangePasswordRequest' } } } },
          responses: {
            200: { description: 'Password changed' },
            401: { description: 'Current password incorrect' },
          },
        },
      },

      // ============================
      // LOST ITEMS
      // ============================
      '/lost-items': {
        post: {
          tags: ['Lost Items'],
          summary: 'Report a lost item',
          description: 'Creates a lost item report with 3 private verification questions. Questions are used later to verify ownership claims.',
          security: [{ bearerAuth: [] }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateLostItemRequest' } } } },
          responses: {
            201: { description: 'Report created', content: { 'application/json': { schema: { type: 'object', properties: { success: { type: 'boolean' }, data: { $ref: '#/components/schemas/LostItem' } } } } } },
            400: { $ref: '#/components/responses/ValidationError' },
            401: { $ref: '#/components/responses/Unauthorized' },
          },
        },
        get: {
          tags: ['Lost Items'],
          summary: 'Search and list lost items',
          description: 'Public endpoint. Returns active lost items with optional filters.',
          parameters: [
            { $ref: '#/components/parameters/PageParam' },
            { $ref: '#/components/parameters/LimitParam' },
            { $ref: '#/components/parameters/CategoryFilter' },
            { $ref: '#/components/parameters/LocationFilter' },
            { $ref: '#/components/parameters/KeywordFilter' },
            { name: 'date_from', in: 'query', schema: { type: 'string', format: 'date' } },
            { name: 'date_to', in: 'query', schema: { type: 'string', format: 'date' } },
          ],
          responses: { 200: { description: 'List of lost items with pagination' } },
        },
      },
      '/lost-items/{id}': {
        get: {
          tags: ['Lost Items'],
          summary: 'Get lost item details',
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: {
            200: { description: 'Lost item details' },
            404: { $ref: '#/components/responses/NotFound' },
          },
        },
        put: {
          tags: ['Lost Items'],
          summary: 'Update own lost item',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { content: { 'application/json': { schema: { type: 'object', properties: { title: { type: 'string' }, description: { type: 'string' }, location_area: { type: 'string' } } } } } },
          responses: { 200: { description: 'Updated' }, 404: { $ref: '#/components/responses/NotFound' } },
        },
        delete: {
          tags: ['Lost Items'],
          summary: 'Delete own lost item',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Deleted' }, 400: { description: 'Cannot delete with active claim' } },
        },
      },
      '/lost-items/{id}/matches': {
        get: {
          tags: ['Matching'],
          summary: 'Get matches for a lost item',
          description: 'Returns up to 5 matched found items ranked by score with explanations. Score uses: category (+5), location (+3), time window (+2), keywords (+1 each). Minimum score: 5.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: {
            200: { description: 'Match results', content: { 'application/json': { schema: { type: 'object', properties: { success: { type: 'boolean' }, data: { type: 'array', items: { $ref: '#/components/schemas/MatchResult' } } } } } } },
          },
        },
      },
      '/users/me/lost-items': {
        get: {
          tags: ['Lost Items'],
          summary: "List user's own lost items",
          security: [{ bearerAuth: [] }],
          parameters: [{ $ref: '#/components/parameters/PageParam' }, { $ref: '#/components/parameters/LimitParam' }],
          responses: { 200: { description: "User's lost items" } },
        },
      },

      // ============================
      // FOUND ITEMS
      // ============================
      '/found-items': {
        post: {
          tags: ['Found Items'],
          summary: 'Report a found item',
          description: 'Creates a found item report. Cooperative staff can assign to their cooperative.',
          security: [{ bearerAuth: [] }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateFoundItemRequest' } } } },
          responses: { 201: { description: 'Report created' } },
        },
        get: {
          tags: ['Found Items'],
          summary: 'Search and list found items',
          description: 'Public. Sensitive items (ID/WALLET) show truncated descriptions for privacy.',
          parameters: [
            { $ref: '#/components/parameters/PageParam' },
            { $ref: '#/components/parameters/LimitParam' },
            { $ref: '#/components/parameters/CategoryFilter' },
            { $ref: '#/components/parameters/LocationFilter' },
            { $ref: '#/components/parameters/KeywordFilter' },
          ],
          responses: { 200: { description: 'List of found items' } },
        },
      },
      '/found-items/{id}': {
        get: {
          tags: ['Found Items'],
          summary: 'Get found item details',
          description: 'Sensitive items show limited info unless you are the finder or admin.',
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Found item details' } },
        },
        put: {
          tags: ['Found Items'],
          summary: 'Update own found item',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Updated' } },
        },
        delete: {
          tags: ['Found Items'],
          summary: 'Delete own found item',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Deleted' } },
        },
      },
      '/found-items/{id}/images': {
        post: {
          tags: ['Found Items'],
          summary: 'Upload images for found item',
          description: 'Upload up to 5 images (JPEG, PNG, WebP). Max 5MB each.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { content: { 'multipart/form-data': { schema: { type: 'object', properties: { images: { type: 'array', items: { type: 'string', format: 'binary' } } } } } } },
          responses: { 200: { description: 'Images uploaded' } },
        },
      },
      '/found-items/{id}/matches': {
        get: {
          tags: ['Matching'],
          summary: 'Get matches for a found item',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Match results' } },
        },
      },
      '/users/me/found-items': {
        get: {
          tags: ['Found Items'],
          summary: "List user's own found items",
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: "User's found items" } },
        },
      },

      // ============================
      // CLAIMS & VERIFICATION
      // ============================
      '/claims': {
        post: {
          tags: ['Claims & Verification'],
          summary: 'Initiate a claim',
          description: 'Creates a claim linking a lost item to a found item. Only the lost item owner can create a claim.',
          security: [{ bearerAuth: [] }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateClaimRequest' } } } },
          responses: {
            201: { description: 'Claim created' },
            409: { description: 'Active claim already exists' },
          },
        },
      },
      '/claims/{claimId}': {
        get: {
          tags: ['Claims & Verification'],
          summary: 'Get claim details',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Claim details' } },
        },
      },
      '/claims/{claimId}/questions': {
        get: {
          tags: ['Claims & Verification'],
          summary: 'Get verification questions',
          description: 'Returns the 3 secret questions set by the item owner. Rate limited: max 3 attempts per day.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: {
            200: { description: 'Questions', content: { 'application/json': { schema: { $ref: '#/components/schemas/VerificationQuestionsResponse' } } } },
            429: { $ref: '#/components/responses/RateLimited' },
          },
        },
      },
      '/claims/{claimId}/verify': {
        post: {
          tags: ['Claims & Verification'],
          summary: 'Submit verification answers',
          description: 'Requires 2 of 3 correct answers to verify. Progressive cooldown on failures: 1hr ‚Üí 4hr ‚Üí 24hr. Max 3 attempts/day.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/VerifyClaimRequest' } } } },
          responses: {
            200: { description: 'Verification result', content: { 'application/json': { schema: { $ref: '#/components/schemas/VerificationResultResponse' } } } },
            429: { $ref: '#/components/responses/RateLimited' },
          },
        },
      },
      '/claims/{claimId}/cancel': {
        post: {
          tags: ['Claims & Verification'],
          summary: 'Cancel a claim',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Claim cancelled' } },
        },
      },
      '/users/me/claims': {
        get: {
          tags: ['Claims & Verification'],
          summary: "List user's claims",
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: "User's claims" } },
        },
      },

      // ============================
      // HANDOVER (OTP)
      // ============================
      '/claims/{claimId}/handover/otp': {
        post: {
          tags: ['Handover'],
          summary: 'Generate handover OTP',
          description: 'Generates a 6-digit OTP for the verified claim owner. OTP is valid for 24 hours. Only the item owner can generate.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: {
            200: { description: 'OTP generated', content: { 'application/json': { schema: { $ref: '#/components/schemas/OTPGenerateResponse' } } } },
            400: { description: 'Claim must be verified / OTP already exists' },
          },
        },
      },
      '/claims/{claimId}/handover/verify': {
        post: {
          tags: ['Handover'],
          summary: 'Verify OTP and complete handover',
          description: 'The finder or cooperative staff enters the OTP to confirm the physical item return. Max 3 attempts.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/OTPVerifyRequest' } } } },
          responses: {
            200: { description: 'Handover confirmed ‚Äî items marked as RETURNED' },
            400: { description: 'Invalid or expired OTP' },
            429: { description: 'Too many failed attempts' },
          },
        },
      },
      '/claims/{claimId}/handover': {
        get: {
          tags: ['Handover'],
          summary: 'Get handover status',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Handover status' } },
        },
      },

      // ============================
      // DISPUTES
      // ============================
      '/claims/{claimId}/dispute': {
        post: {
          tags: ['Disputes'],
          summary: 'File a dispute on a claim',
          description: 'For edge cases where verification fails but user believes they are the owner (e.g., forgot answers).',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateDisputeRequest' } } } },
          responses: { 201: { description: 'Dispute filed' } },
        },
      },
      '/admin/disputes': {
        get: {
          tags: ['Disputes'],
          summary: 'List all disputes (admin)',
          security: [{ bearerAuth: [] }],
          parameters: [
            { name: 'status', in: 'query', schema: { type: 'string', enum: ['OPEN', 'UNDER_REVIEW', 'RESOLVED_OWNER', 'RESOLVED_FINDER', 'DISMISSED'] } },
            { $ref: '#/components/parameters/PageParam' },
          ],
          responses: { 200: { description: 'Disputes list' } },
        },
      },
      '/admin/disputes/{disputeId}/resolve': {
        post: {
          tags: ['Disputes'],
          summary: 'Resolve a dispute (admin)',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'disputeId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/ResolveDisputeRequest' } } } },
          responses: { 200: { description: 'Dispute resolved' } },
        },
      },

      // ============================
      // MESSAGES
      // ============================
      '/messages/threads': {
        get: {
          tags: ['Messages'],
          summary: 'List message threads',
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: 'Message threads grouped by claim' } },
        },
      },
      '/messages/threads/{claimId}': {
        get: {
          tags: ['Messages'],
          summary: 'Get messages for a claim',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Messages in thread' } },
        },
        post: {
          tags: ['Messages'],
          summary: 'Send a message',
          description: 'Messages are scanned for extortion keywords and flagged automatically.',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'claimId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/SendMessageRequest' } } } },
          responses: { 201: { description: 'Message sent' } },
        },
      },
      '/messages/{messageId}/report': {
        post: {
          tags: ['Messages'],
          summary: 'Report a message as scam',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'messageId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { content: { 'application/json': { schema: { type: 'object', properties: { reason: { type: 'string' } } } } } },
          responses: { 201: { description: 'Scam report created' } },
        },
      },
      '/messages/unread-count': {
        get: {
          tags: ['Messages'],
          summary: 'Get unread message count',
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: 'Unread count' } },
        },
      },

      // ============================
      // COOPERATIVES
      // ============================
      '/cooperatives': {
        get: {
          tags: ['Cooperatives'],
          summary: 'List cooperatives',
          description: 'Public users see verified cooperatives only. Admins see all.',
          parameters: [
            { name: 'status', in: 'query', schema: { type: 'string', enum: ['PENDING', 'VERIFIED', 'SUSPENDED'] } },
            { name: 'search', in: 'query', schema: { type: 'string' } },
          ],
          responses: { 200: { description: 'Cooperatives list' } },
        },
        post: {
          tags: ['Cooperatives'],
          summary: 'Create cooperative (admin)',
          security: [{ bearerAuth: [] }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/CreateCooperativeRequest' } } } },
          responses: { 201: { description: 'Cooperative created' } },
        },
      },
      '/cooperatives/{id}': {
        get: {
          tags: ['Cooperatives'],
          summary: 'Get cooperative details',
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Cooperative details with stats' } },
        },
      },
      '/cooperatives/{id}/status': {
        patch: {
          tags: ['Cooperatives'],
          summary: 'Update cooperative status (admin)',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { type: 'object', properties: { status: { type: 'string', enum: ['VERIFIED', 'SUSPENDED'] } } } } } },
          responses: { 200: { description: 'Status updated' } },
        },
      },
      '/cooperatives/{id}/staff': {
        post: {
          tags: ['Cooperatives'],
          summary: 'Add staff member (admin)',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { content: { 'application/json': { schema: { type: 'object', required: ['email', 'password', 'name'], properties: { email: { type: 'string' }, password: { type: 'string' }, name: { type: 'string' }, phone: { type: 'string' } } } } } },
          responses: { 201: { description: 'Staff added' } },
        },
        get: {
          tags: ['Cooperatives'],
          summary: 'Get cooperative staff',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Staff list' } },
        },
      },
      '/cooperatives/{id}/items': {
        get: {
          tags: ['Cooperatives'],
          summary: 'Get items managed by cooperative',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'id', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Cooperative items' } },
        },
      },
      '/cooperative/dashboard': {
        get: {
          tags: ['Cooperatives'],
          summary: 'Get cooperative staff dashboard',
          description: 'For logged-in cooperative staff. Shows their cooperative stats and recent items.',
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: 'Dashboard data' } },
        },
      },

      // ============================
      // ADMIN
      // ============================
      '/admin/stats': {
        get: {
          tags: ['Admin'],
          summary: 'Get dashboard statistics',
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: 'Dashboard stats', content: { 'application/json': { schema: { type: 'object', properties: { success: { type: 'boolean' }, data: { $ref: '#/components/schemas/DashboardStats' } } } } } } },
        },
      },
      '/admin/users': {
        get: {
          tags: ['Admin'],
          summary: 'List all users',
          security: [{ bearerAuth: [] }],
          parameters: [
            { name: 'search', in: 'query', schema: { type: 'string' } },
            { name: 'role', in: 'query', schema: { type: 'string', enum: ['citizen', 'coop_staff', 'admin'] } },
            { name: 'status', in: 'query', schema: { type: 'string', enum: ['active', 'banned'] } },
            { $ref: '#/components/parameters/PageParam' },
          ],
          responses: { 200: { description: 'Users list' } },
        },
      },
      '/admin/users/{userId}/ban': {
        post: {
          tags: ['Admin'],
          summary: 'Ban a user',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'userId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { required: true, content: { 'application/json': { schema: { $ref: '#/components/schemas/BanUserRequest' } } } },
          responses: { 200: { description: 'User banned' } },
        },
      },
      '/admin/users/{userId}/unban': {
        post: {
          tags: ['Admin'],
          summary: 'Unban a user',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'userId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'User unbanned' } },
        },
      },
      '/admin/scam-reports': {
        get: {
          tags: ['Admin'],
          summary: 'List scam reports',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'status', in: 'query', schema: { type: 'string', enum: ['OPEN', 'INVESTIGATING', 'RESOLVED'] } }],
          responses: { 200: { description: 'Scam reports' } },
        },
      },
      '/admin/scam-reports/{reportId}/resolve': {
        post: {
          tags: ['Admin'],
          summary: 'Resolve a scam report',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'reportId', in: 'path', required: true, schema: { type: 'integer' } }],
          requestBody: { content: { 'application/json': { schema: { type: 'object', properties: { resolution_notes: { type: 'string' }, action: { type: 'string', enum: ['dismiss', 'warn', 'suspend', 'ban'] } } } } } },
          responses: { 200: { description: 'Report resolved' } },
        },
      },
      '/admin/audit-logs': {
        get: {
          tags: ['Admin'],
          summary: 'View audit logs',
          security: [{ bearerAuth: [] }],
          parameters: [
            { name: 'actorId', in: 'query', schema: { type: 'integer' } },
            { name: 'action', in: 'query', schema: { type: 'string' } },
            { name: 'resourceType', in: 'query', schema: { type: 'string' } },
            { name: 'fromDate', in: 'query', schema: { type: 'string', format: 'date' } },
            { name: 'toDate', in: 'query', schema: { type: 'string', format: 'date' } },
          ],
          responses: { 200: { description: 'Audit logs' } },
        },
      },
      '/admin/users/{userId}/recalculate-trust': {
        post: {
          tags: ['Admin'],
          summary: 'Recalculate user trust score',
          security: [{ bearerAuth: [] }],
          parameters: [{ name: 'userId', in: 'path', required: true, schema: { type: 'integer' } }],
          responses: { 200: { description: 'Trust score recalculated' } },
        },
      },
      '/admin/cleanup': {
        post: {
          tags: ['Admin'],
          summary: 'Trigger manual cleanup',
          description: 'Manually runs the daily expiry and cleanup job.',
          security: [{ bearerAuth: [] }],
          responses: { 200: { description: 'Cleanup completed' } },
        },
      },

      // ============================
      // SYSTEM
      // ============================
      '/health': {
        get: {
          tags: ['System'],
          summary: 'Health check',
          description: 'Returns server and database connectivity status.',
          responses: {
            200: { description: 'Healthy', content: { 'application/json': { schema: { type: 'object', properties: { status: { type: 'string', example: 'ok' }, timestamp: { type: 'string', format: 'date-time' }, database: { type: 'string', example: 'connected' } } } } } },
            503: { description: 'Database unreachable' },
          },
        },
      },
    },
  },
  apis: [], // We define everything inline above
};

export const swaggerSpec = swaggerJsdoc(options);


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/adminController.ts
‚îÇ Language: TypeScript | Lines: 308 | Size: 10.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query, transaction } from '../config/database';
import { parsePaginationParams } from '../utils';
import { logModeration, getAuditLogs } from '../services/auditService';
import { onScamConfirmed, onFalseScamReport, recalculateTrustScore } from '../services/trustService';
import { runDailyCleanup } from '../services/expiryService';

// ============================================
// ADMIN CONTROLLER
// ============================================

// Get dashboard stats
export async function getDashboardStats(req: Request, res: Response): Promise<void> {
  try {
    const [
      usersResult,
      lostResult,
      foundResult,
      claimsResult,
      returnedResult,
      pendingReportsResult
    ] = await Promise.all([
      query('SELECT COUNT(*) FROM users WHERE role = $1', ['citizen']),
      query('SELECT COUNT(*) FROM lost_items'),
      query('SELECT COUNT(*) FROM found_items'),
      query('SELECT COUNT(*) FROM claims'),
      query(`SELECT COUNT(*) FROM claims WHERE status = 'RETURNED'`),
      query(`SELECT COUNT(*) FROM scam_reports WHERE status = 'OPEN'`),
    ]);

    res.json({
      success: true,
      data: {
        total_users: parseInt(usersResult.rows[0].count),
        total_lost_items: parseInt(lostResult.rows[0].count),
        total_found_items: parseInt(foundResult.rows[0].count),
        total_claims: parseInt(claimsResult.rows[0].count),
        successful_returns: parseInt(returnedResult.rows[0].count),
        pending_scam_reports: parseInt(pendingReportsResult.rows[0].count),
      }
    });
  } catch (error) {
    console.error('Dashboard stats error:', error);
    res.status(500).json({ success: false, message: 'Failed to get stats' });
  }
}

// Get all users
export async function getUsers(req: Request, res: Response): Promise<void> {
  try {
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );
    const { search, role, status } = req.query;

    const conditions: string[] = [];
    const params: any[] = [];
    let paramIndex = 1;

    if (search) {
      conditions.push(`(LOWER(u.name) LIKE LOWER($${paramIndex}) OR LOWER(u.email) LIKE LOWER($${paramIndex}))`);
      params.push(`%${search}%`);
      paramIndex++;
    }

    if (role) {
      conditions.push(`u.role = $${paramIndex++}`);
      params.push(role);
    }

    if (status === 'banned') {
      conditions.push('u.is_banned = true');
    } else if (status === 'active') {
      conditions.push('u.is_banned = false');
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    const countResult = await query(`SELECT COUNT(*) FROM users u LEFT JOIN cooperatives c ON u.cooperative_id = c.id ${whereClause}`, params);
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT u.id, u.email, u.name, u.phone, u.role, u.trust_score, u.is_banned, u.ban_reason, u.created_at,
              c.name as cooperative_name
       FROM users u
       LEFT JOIN cooperatives c ON u.cooperative_id = c.id
       ${whereClause}
       ORDER BY u.created_at DESC
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
      [...params, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ success: false, message: 'Failed to get users' });
  }
}

// Ban user
export async function banUser(req: Request, res: Response): Promise<void> {
  try {
    const { userId } = req.params;
    const { reason } = req.body;

    const userResult = await query('SELECT * FROM users WHERE id = $1', [userId]);
    if (userResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'User not found' });
      return;
    }

    if (userResult.rows[0].role === 'admin') {
      res.status(403).json({ success: false, message: 'Cannot ban admin users' });
      return;
    }

    await query(
      `UPDATE users SET is_banned = true, banned_at = NOW(), ban_reason = $1 WHERE id = $2`,
      [reason, userId]
    );

    await logModeration(req, 'USER_BANNED', 'user', parseInt(userId), { reason });

    res.json({ success: true, message: 'User banned successfully' });
  } catch (error) {
    console.error('Ban user error:', error);
    res.status(500).json({ success: false, message: 'Failed to ban user' });
  }
}

// Unban user
export async function unbanUser(req: Request, res: Response): Promise<void> {
  try {
    const { userId } = req.params;

    await query(
      `UPDATE users SET is_banned = false, banned_at = NULL, ban_reason = NULL WHERE id = $1`,
      [userId]
    );

    await logModeration(req, 'USER_UNBANNED', 'user', parseInt(userId), {});

    res.json({ success: true, message: 'User unbanned successfully' });
  } catch (error) {
    console.error('Unban user error:', error);
    res.status(500).json({ success: false, message: 'Failed to unban user' });
  }
}

// Get scam reports
export async function getScamReports(req: Request, res: Response): Promise<void> {
  try {
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );
    const { status } = req.query;

    let whereClause = '';
    const params: any[] = [];

    if (status) {
      whereClause = 'WHERE sr.status = $1';
      params.push(status);
    }

    const countResult = await query(
      `SELECT COUNT(*) FROM scam_reports sr ${whereClause}`,
      params
    );
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT sr.*, 
              reporter.name as reporter_name, reporter.email as reporter_email,
              reported.name as reported_name, reported.email as reported_email,
              m.content as message_content
       FROM scam_reports sr
       JOIN users reporter ON sr.reporter_id = reporter.id
       JOIN users reported ON sr.reported_user_id = reported.id
       LEFT JOIN messages m ON sr.message_id = m.id
       ${whereClause}
       ORDER BY sr.created_at DESC
       LIMIT $${params.length + 1} OFFSET $${params.length + 2}`,
      [...params, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get scam reports error:', error);
    res.status(500).json({ success: false, message: 'Failed to get scam reports' });
  }
}

// Resolve scam report
export async function resolveScamReport(req: Request, res: Response): Promise<void> {
  try {
    const { reportId } = req.params;
    const { resolution_notes, action } = req.body;

    const reportResult = await query('SELECT * FROM scam_reports WHERE id = $1', [reportId]);
    if (reportResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Report not found' });
      return;
    }

    const report = reportResult.rows[0];

    await transaction(async (client) => {
      // Update report
      await client.query(
        `UPDATE scam_reports SET status = 'RESOLVED', resolution_notes = $1, resolved_at = NOW(), resolved_by = $2
         WHERE id = $3`,
        [resolution_notes, req.user!.userId, reportId]
      );

      // Take action based on decision
      if (action === 'ban') {
        await client.query(
          `UPDATE users SET is_banned = true, banned_at = NOW(), ban_reason = $1 WHERE id = $2`,
          [`Scam report #${reportId}: ${resolution_notes}`, report.reported_user_id]
        );
        await onScamConfirmed(req, report.reported_user_id);
      } else if (action === 'warn') {
        await onScamConfirmed(req, report.reported_user_id);
      } else if (action === 'dismiss') {
        // False report - penalize reporter
        await onFalseScamReport(req, report.reporter_id);
      }
    });

    await logModeration(req, 'SCAM_REPORT_RESOLVED', 'scam_report', parseInt(reportId), {
      action, resolution_notes
    });

    res.json({ success: true, message: 'Scam report resolved' });
  } catch (error) {
    console.error('Resolve scam report error:', error);
    res.status(500).json({ success: false, message: 'Failed to resolve report' });
  }
}

// Get audit logs
export async function getAuditLogsHandler(req: Request, res: Response): Promise<void> {
  try {
    const { actorId, action, resourceType, resourceId, fromDate, toDate, page, limit } = req.query;

    const logs = await getAuditLogs({
      actorId: actorId ? parseInt(actorId as string) : undefined,
      action: action as string,
      resourceType: resourceType as string,
      resourceId: resourceId ? parseInt(resourceId as string) : undefined,
      fromDate: fromDate ? new Date(fromDate as string) : undefined,
      toDate: toDate ? new Date(toDate as string) : undefined,
      page: page ? parseInt(page as string) : 1,
      limit: limit ? parseInt(limit as string) : 50,
    });

    res.json({ success: true, ...logs });
  } catch (error) {
    console.error('Get audit logs error:', error);
    res.status(500).json({ success: false, message: 'Failed to get audit logs' });
  }
}

// Recalculate trust score
export async function recalculateUserTrust(req: Request, res: Response): Promise<void> {
  try {
    const { userId } = req.params;

    const newScore = await recalculateTrustScore(parseInt(userId));

    res.json({
      success: true,
      data: { user_id: parseInt(userId), new_trust_score: newScore },
      message: 'Trust score recalculated'
    });
  } catch (error) {
    console.error('Recalculate trust error:', error);
    res.status(500).json({ success: false, message: 'Failed to recalculate trust' });
  }
}

// Run daily cleanup manually
export async function triggerCleanup(req: Request, res: Response): Promise<void> {
  try {
    await runDailyCleanup();
    
    await logModeration(req, 'CLEANUP_TRIGGERED', 'system', 0, {});

    res.json({
      success: true,
      message: 'Cleanup job completed successfully'
    });
  } catch (error) {
    console.error('Cleanup trigger error:', error);
    res.status(500).json({ success: false, message: 'Failed to run cleanup' });
  }
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/authController.ts
‚îÇ Language: TypeScript | Lines: 639 | Size: 16.6 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query, transaction } from '../config/database';
import {
  hashPassword,
  verifyPassword,
  generateAccessToken,
  generateRefreshToken,
  verifyRefreshToken,
  hashToken,
  generateUUID
} from '../utils';
import { UserRole, TokenPayload } from '../types';
import { logLogin, logAudit, extractRequestMeta } from '../services/auditService';

// ============================================
// AUTHENTICATION CONTROLLER
// ============================================

// Register new user
export async function register(req: Request, res: Response): Promise<void> {
  try {
    const { email, password, name, phone } = req.body;

    // Check if email already exists
    const existingUser = await query(
      'SELECT id FROM users WHERE email = $1',
      [email.toLowerCase()]
    );

    if (existingUser.rows.length > 0) {
      res.status(409).json({
        success: false,
        message: 'Email is already registered'
      });
      return;
    }

    // Check if phone already exists (if provided)
    if (phone) {
      const existingPhone = await query(
        'SELECT id FROM users WHERE phone = $1',
        [phone]
      );

      if (existingPhone.rows.length > 0) {
        res.status(409).json({
          success: false,
          message: 'Phone number is already registered'
        });
        return;
      }
    }

    // Hash password
    const passwordHash = await hashPassword(password);

    // Create user
    const result = await query(
      `INSERT INTO users (email, password_hash, name, phone, role, trust_score)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING id, email, name, phone, role, trust_score, email_verified, phone_verified, created_at`,
      [email.toLowerCase(), passwordHash, name, phone || null, UserRole.CITIZEN, 0]
    );

    const user = result.rows[0];

    // Generate tokens
    const tokenPayload: TokenPayload = {
      userId: user.id,
      email: user.email,
      role: user.role
    };

    const accessToken = generateAccessToken(tokenPayload);
    const refreshToken = generateRefreshToken(tokenPayload);

    // Store refresh token
    await query(
      `INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
       VALUES ($1, $2, NOW() + INTERVAL '7 days')`,
      [user.id, hashToken(refreshToken)]
    );

    // Log the registration
    const { ipAddress, userAgent } = extractRequestMeta(req);
    await logAudit({
      actorId: user.id,
      action: 'CREATE',
      resourceType: 'user',
      resourceId: user.id,
      changes: { email: user.email, name: user.name },
      ipAddress,
      userAgent
    });

    // FIX #5: Include email_verified and phone_verified in response
    res.status(201).json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          phone: user.phone,
          role: user.role,
          trust_score: user.trust_score,
          email_verified: user.email_verified || false,
          phone_verified: user.phone_verified || false,
          created_at: user.created_at
        },
        tokens: {
          accessToken,
          refreshToken
        }
      },
      message: 'Registration successful'
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      message: 'Registration failed'
    });
  }
}

// Login
export async function login(req: Request, res: Response): Promise<void> {
  try {
    const { email, password } = req.body;

    // FIX #5 & #17: Include email_verified, phone_verified, cooperative fields in login query
    const result = await query(
      `SELECT u.id, u.email, u.password_hash, u.name, u.phone, u.role, u.trust_score,
              u.is_banned, u.ban_reason, u.email_verified, u.phone_verified,
              u.cooperative_id, c.name as cooperative_name, u.created_at
       FROM users u
       LEFT JOIN cooperatives c ON u.cooperative_id = c.id
       WHERE u.email = $1`,
      [email.toLowerCase()]
    );

    if (result.rows.length === 0) {
      res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
      return;
    }

    const user = result.rows[0];

    // Check if banned
    if (user.is_banned) {
      res.status(403).json({
        success: false,
        message: 'Account has been suspended',
        reason: user.ban_reason
      });
      return;
    }

    // Verify password
    const isValidPassword = await verifyPassword(password, user.password_hash);

    if (!isValidPassword) {
      res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
      return;
    }

    // Generate tokens
    const tokenPayload: TokenPayload = {
      userId: user.id,
      email: user.email,
      role: user.role
    };

    const accessToken = generateAccessToken(tokenPayload);
    const refreshToken = generateRefreshToken(tokenPayload);

    // Store refresh token
    await query(
      `INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
       VALUES ($1, $2, NOW() + INTERVAL '7 days')`,
      [user.id, hashToken(refreshToken)]
    );

    // Log login
    await logLogin(req, user.id);

    // FIX #5 & #17: Include all fields frontend expects
    res.json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          phone: user.phone,
          role: user.role,
          trust_score: user.trust_score,
          email_verified: user.email_verified || false,
          phone_verified: user.phone_verified || false,
          cooperative_id: user.cooperative_id || undefined,
          cooperative_name: user.cooperative_name || undefined,
          created_at: user.created_at
        },
        tokens: {
          accessToken,
          refreshToken
        }
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      success: false,
      message: 'Login failed'
    });
  }
}

// Refresh token
export async function refreshToken(req: Request, res: Response): Promise<void> {
  try {
    const { refreshToken: token } = req.body;

    // Verify token
    let payload: TokenPayload;
    try {
      payload = verifyRefreshToken(token);
    } catch (error) {
      res.status(401).json({
        success: false,
        message: 'Invalid refresh token'
      });
      return;
    }

    // Check if token exists in database and is not revoked
    const tokenHash = hashToken(token);
    const result = await query(
      `SELECT id FROM refresh_tokens
       WHERE user_id = $1 AND token_hash = $2 AND revoked_at IS NULL AND expires_at > NOW()`,
      [payload.userId, tokenHash]
    );

    if (result.rows.length === 0) {
      res.status(401).json({
        success: false,
        message: 'Refresh token has been revoked or expired'
      });
      return;
    }

    // Get current user data
    const userResult = await query(
      'SELECT id, email, role, is_banned FROM users WHERE id = $1',
      [payload.userId]
    );

    if (userResult.rows.length === 0 || userResult.rows[0].is_banned) {
      res.status(401).json({
        success: false,
        message: 'User not found or account suspended'
      });
      return;
    }

    const user = userResult.rows[0];

    // Generate new tokens
    const newPayload: TokenPayload = {
      userId: user.id,
      email: user.email,
      role: user.role
    };

    const newAccessToken = generateAccessToken(newPayload);
    const newRefreshToken = generateRefreshToken(newPayload);

    // Revoke old refresh token and create new one
    await transaction(async (client) => {
      await client.query(
        'UPDATE refresh_tokens SET revoked_at = NOW() WHERE token_hash = $1',
        [tokenHash]
      );
      await client.query(
        `INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
         VALUES ($1, $2, NOW() + INTERVAL '7 days')`,
        [user.id, hashToken(newRefreshToken)]
      );
    });

    res.json({
      success: true,
      data: {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken
      }
    });
  } catch (error) {
    console.error('Token refresh error:', error);
    res.status(500).json({
      success: false,
      message: 'Token refresh failed'
    });
  }
}

// Logout
export async function logout(req: Request, res: Response): Promise<void> {
  try {
    const { refreshToken: token } = req.body;

    if (token) {
      // Revoke refresh token
      await query(
        'UPDATE refresh_tokens SET revoked_at = NOW() WHERE token_hash = $1',
        [hashToken(token)]
      );
    }

    // Log logout
    if (req.user) {
      const { ipAddress, userAgent } = extractRequestMeta(req);
      await logAudit({
        actorId: req.user.userId,
        action: 'LOGOUT',
        resourceType: 'user',
        resourceId: req.user.userId,
        ipAddress,
        userAgent
      });
    }

    res.json({
      success: true,
      message: 'Logged out successfully'
    });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({
      success: false,
      message: 'Logout failed'
    });
  }
}

// Request password reset
export async function forgotPassword(req: Request, res: Response): Promise<void> {
  try {
    const { email } = req.body;

    // Find user
    const result = await query(
      'SELECT id, email, name FROM users WHERE email = $1',
      [email.toLowerCase()]
    );

    // Always return success to prevent email enumeration
    if (result.rows.length === 0) {
      res.json({
        success: true,
        message: 'If the email exists, a password reset link has been sent'
      });
      return;
    }

    const user = result.rows[0];

    // Generate reset token
    const resetToken = generateUUID();
    const tokenHash = hashToken(resetToken);

    // Store token (valid for 1 hour)
    await query(
      `INSERT INTO password_reset_tokens (user_id, token_hash, expires_at)
       VALUES ($1, $2, NOW() + INTERVAL '1 hour')`,
      [user.id, tokenHash]
    );

    // TODO: Send email with reset link
    // For MVP, we'll just log it
    console.log(`Password reset token for ${user.email}: ${resetToken}`);

    res.json({
      success: true,
      message: 'If the email exists, a password reset link has been sent',
      // In development, include token for testing
      ...(process.env.NODE_ENV === 'development' && { resetToken })
    });
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({
      success: false,
      message: 'Password reset request failed'
    });
  }
}

// Reset password with token
export async function resetPassword(req: Request, res: Response): Promise<void> {
  try {
    const { token, password } = req.body;

    // Find valid token
    const tokenHash = hashToken(token);
    const result = await query(
      `SELECT user_id FROM password_reset_tokens
       WHERE token_hash = $1 AND expires_at > NOW() AND used_at IS NULL`,
      [tokenHash]
    );

    if (result.rows.length === 0) {
      res.status(400).json({
        success: false,
        message: 'Invalid or expired reset token'
      });
      return;
    }

    const userId = result.rows[0].user_id;

    // Hash new password
    const passwordHash = await hashPassword(password);

    // Update password and mark token as used
    await transaction(async (client) => {
      await client.query(
        'UPDATE users SET password_hash = $1 WHERE id = $2',
        [passwordHash, userId]
      );
      await client.query(
        'UPDATE password_reset_tokens SET used_at = NOW() WHERE token_hash = $1',
        [tokenHash]
      );
      // Revoke all refresh tokens for this user
      await client.query(
        'UPDATE refresh_tokens SET revoked_at = NOW() WHERE user_id = $1',
        [userId]
      );
    });

    // Log the password reset
    const { ipAddress, userAgent } = extractRequestMeta(req);
    await logAudit({
      actorId: userId,
      action: 'UPDATE',
      resourceType: 'user',
      resourceId: userId,
      changes: { action: 'password_reset' },
      ipAddress,
      userAgent
    });

    res.json({
      success: true,
      message: 'Password has been reset successfully'
    });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({
      success: false,
      message: 'Password reset failed'
    });
  }
}

// Get current user profile
export async function getProfile(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;

    const result = await query(
      `SELECT u.id, u.email, u.name, u.phone, u.role, u.trust_score, 
              u.email_verified, u.phone_verified, u.created_at,
              c.name as cooperative_name, c.id as cooperative_id
       FROM users u
       LEFT JOIN cooperatives c ON u.cooperative_id = c.id
       WHERE u.id = $1`,
      [userId]
    );

    if (result.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: 'User not found'
      });
      return;
    }

    res.json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    console.error('Get profile error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get profile'
    });
  }
}

// Update profile
export async function updateProfile(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { name, phone } = req.body;

    // Check if phone is already used by another user
    if (phone) {
      const existingPhone = await query(
        'SELECT id FROM users WHERE phone = $1 AND id != $2',
        [phone, userId]
      );

      if (existingPhone.rows.length > 0) {
        res.status(409).json({
          success: false,
          message: 'Phone number is already in use'
        });
        return;
      }
    }

    // FIX: Return all fields the frontend needs
    const result = await query(
      `UPDATE users SET name = COALESCE($1, name), phone = COALESCE($2, phone)
       WHERE id = $3
       RETURNING id, email, name, phone, role, trust_score, email_verified, phone_verified, created_at`,
      [name, phone, userId]
    );

    res.json({
      success: true,
      data: result.rows[0],
      message: 'Profile updated successfully'
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update profile'
    });
  }
}

// Change password (for logged-in users)
export async function changePassword(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { currentPassword, newPassword } = req.body;

    // Validate input
    if (!currentPassword || !newPassword) {
      res.status(400).json({
        success: false,
        message: 'Current password and new password are required'
      });
      return;
    }

    if (newPassword.length < 8) {
      res.status(400).json({
        success: false,
        message: 'New password must be at least 8 characters long'
      });
      return;
    }

    // Get current password hash
    const userResult = await query(
      'SELECT password_hash FROM users WHERE id = $1',
      [userId]
    );

    if (userResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: 'User not found'
      });
      return;
    }

    // Verify current password
    const isValidPassword = await verifyPassword(currentPassword, userResult.rows[0].password_hash);

    if (!isValidPassword) {
      res.status(401).json({
        success: false,
        message: 'Current password is incorrect'
      });
      return;
    }

    // Hash new password
    const newPasswordHash = await hashPassword(newPassword);

    // Update password
    await query(
      'UPDATE users SET password_hash = $1 WHERE id = $2',
      [newPasswordHash, userId]
    );

    // Revoke all refresh tokens except current one (optional security measure)
    await query(
      'UPDATE refresh_tokens SET revoked_at = NOW() WHERE user_id = $1 AND revoked_at IS NULL',
      [userId]
    );

    // Log the password change
    const { ipAddress, userAgent } = extractRequestMeta(req);
    await logAudit({
      actorId: userId,
      action: 'UPDATE',
      resourceType: 'user',
      resourceId: userId,
      changes: { action: 'password_change' },
      ipAddress,
      userAgent
    });

    res.json({
      success: true,
      message: 'Password changed successfully. Please log in again.'
    });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to change password'
    });
  }
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/claimsController.ts
‚îÇ Language: TypeScript | Lines: 643 | Size: 19.5 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query, transaction } from '../config/database';
import { verifySecretAnswer, parsePaginationParams, generateOTP, hashOTP, verifyOTP } from '../utils';
import { logClaimAttempt, logOtpAction, logAudit, extractRequestMeta } from '../services/auditService';
import { onFailedVerification, onSuccessfulReturn, onMultipleFailedClaims } from '../services/trustService';
import { ClaimStatus, UserRole } from '../types';

// ============================================
// CLAIMS CONTROLLER
// Verification Challenge & OTP Handover
// ============================================

// Create a new claim
export async function createClaim(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { lost_item_id, found_item_id } = req.body;

    // Verify lost item exists and belongs to claimant
    const lostItem = await query(
      'SELECT id, user_id, status FROM lost_items WHERE id = $1',
      [lost_item_id]
    );

    if (lostItem.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Lost item not found' });
      return;
    }

    if (lostItem.rows[0].user_id !== userId) {
      res.status(403).json({ success: false, message: 'You can only claim items for your own lost reports' });
      return;
    }

    if (lostItem.rows[0].status !== 'ACTIVE') {
      res.status(400).json({ success: false, message: 'This lost item is no longer active' });
      return;
    }

    // Verify found item exists and is unclaimed
    const foundItem = await query(
      'SELECT id, status FROM found_items WHERE id = $1',
      [found_item_id]
    );

    if (foundItem.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Found item not found' });
      return;
    }

    if (foundItem.rows[0].status !== 'UNCLAIMED') {
      res.status(400).json({ success: false, message: 'This found item is no longer available' });
      return;
    }

    // Check for existing active claim
    const existingClaim = await query(
      `SELECT id FROM claims 
       WHERE lost_item_id = $1 AND found_item_id = $2 AND claimant_id = $3
       AND status NOT IN ('CANCELLED', 'REJECTED', 'EXPIRED')`,
      [lost_item_id, found_item_id, userId]
    );

    if (existingClaim.rows.length > 0) {
      res.status(409).json({ 
        success: false, 
        message: 'You already have an active claim for this item',
        claim_id: existingClaim.rows[0].id
      });
      return;
    }

    // Create claim
    const result = await query(
      `INSERT INTO claims (lost_item_id, found_item_id, claimant_id, status)
       VALUES ($1, $2, $3, 'PENDING')
       RETURNING *`,
      [lost_item_id, found_item_id, userId]
    );

    res.status(201).json({
      success: true,
      data: result.rows[0],
      message: 'Claim created. Please complete verification to proceed.'
    });
  } catch (error) {
    console.error('Create claim error:', error);
    res.status(500).json({ success: false, message: 'Failed to create claim' });
  }
}

// Get verification questions for a claim
export async function getVerificationQuestions(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;

    // Get claim and verify ownership
    const claim = await query(
      `SELECT c.*, li.user_id as lost_item_owner
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (claim.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    if (claim.rows[0].claimant_id !== userId) {
      res.status(403).json({ success: false, message: 'Not authorized to view this claim' });
      return;
    }

    if (claim.rows[0].status !== 'PENDING') {
      res.status(400).json({ success: false, message: 'Verification is only available for pending claims' });
      return;
    }

    // Check rate limits
    const attemptsToday = await query(
      `SELECT COUNT(*) FROM verification_attempts
       WHERE claim_id = $1 AND attempt_at > NOW() - INTERVAL '24 hours'`,
      [claimId]
    );

    if (parseInt(attemptsToday.rows[0].count) >= 3) {
      res.status(429).json({
        success: false,
        message: 'Too many verification attempts. Please try again in 24 hours.'
      });
      return;
    }

    // Get questions (not answers)
    const secrets = await query(
      `SELECT question_1_text, question_2_text, question_3_text
       FROM verification_secrets
       WHERE lost_item_id = $1`,
      [claim.rows[0].lost_item_id]
    );

    if (secrets.rows.length === 0) {
      res.status(500).json({ success: false, message: 'Verification questions not found' });
      return;
    }

    res.json({
      success: true,
      data: {
        claim_id: parseInt(claimId),
        questions: [
          secrets.rows[0].question_1_text,
          secrets.rows[0].question_2_text,
          secrets.rows[0].question_3_text
        ],
        attempts_remaining: 3 - parseInt(attemptsToday.rows[0].count)
      }
    });
  } catch (error) {
    console.error('Get verification questions error:', error);
    res.status(500).json({ success: false, message: 'Failed to get verification questions' });
  }
}

// Verify claim with answers
export async function verifyClaim(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;
    const { answers } = req.body;

    // Get claim
    const claimResult = await query(
      `SELECT c.*, li.user_id as lost_item_owner
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (claimResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    const claim = claimResult.rows[0];

    if (claim.claimant_id !== userId) {
      res.status(403).json({ success: false, message: 'Not authorized' });
      return;
    }

    if (claim.status !== 'PENDING') {
      res.status(400).json({ success: false, message: 'Claim is not in pending status' });
      return;
    }

    // Check rate limits
    const attemptsToday = await query(
      `SELECT COUNT(*) FROM verification_attempts
       WHERE claim_id = $1 AND attempt_at > NOW() - INTERVAL '24 hours'`,
      [claimId]
    );

    if (parseInt(attemptsToday.rows[0].count) >= 3) {
      res.status(429).json({
        success: false,
        message: 'Daily verification limit reached. Try again tomorrow.'
      });
      return;
    }

    // Get secrets
    const secrets = await query(
      `SELECT * FROM verification_secrets WHERE lost_item_id = $1`,
      [claim.lost_item_id]
    );

    if (secrets.rows.length === 0) {
      res.status(500).json({ success: false, message: 'Verification data not found' });
      return;
    }

    const secret = secrets.rows[0];

    // Verify each answer
    let correctCount = 0;
    const results: boolean[] = [];

    const answer1Correct = await verifySecretAnswer(
      answers[0],
      secret.answer_1_hash,
      secret.answer_1_salt
    );
    results.push(answer1Correct);
    if (answer1Correct) correctCount++;

    const answer2Correct = await verifySecretAnswer(
      answers[1],
      secret.answer_2_hash,
      secret.answer_2_salt
    );
    results.push(answer2Correct);
    if (answer2Correct) correctCount++;

    const answer3Correct = await verifySecretAnswer(
      answers[2],
      secret.answer_3_hash,
      secret.answer_3_salt
    );
    results.push(answer3Correct);
    if (answer3Correct) correctCount++;

    const passed = correctCount >= 2;
    const verificationScore = correctCount / 3;

    // Record attempt
    const { ipAddress } = extractRequestMeta(req);
    await query(
      `INSERT INTO verification_attempts (claim_id, correct_answers, attempt_status, ip_address)
       VALUES ($1, $2, $3, $4)`,
      [claimId, correctCount, passed ? 'PASSED' : 'FAILED', ipAddress]
    );

    // Update claim
    const newStatus = passed ? ClaimStatus.VERIFIED : ClaimStatus.PENDING;
    const newAttempts = claim.attempts_made + 1;

    await query(
      `UPDATE claims SET 
        status = $1, 
        verification_score = $2, 
        attempts_made = $3,
        last_attempt_at = NOW()
       WHERE id = $4`,
      [newStatus, verificationScore, newAttempts, claimId]
    );

    // Log the attempt
    await logClaimAttempt(req, parseInt(claimId), passed, correctCount);

    // Update trust score
    if (!passed) {
      await onFailedVerification(req, userId);
      
      // Check for multiple failures
      const totalFailed = await query(
        `SELECT COUNT(*) FROM verification_attempts
         WHERE claim_id IN (SELECT id FROM claims WHERE claimant_id = $1)
         AND attempt_status = 'FAILED'
         AND attempt_at > NOW() - INTERVAL '7 days'`,
        [userId]
      );
      await onMultipleFailedClaims(req, userId, parseInt(totalFailed.rows[0].count));
    }

    // If verified, update found item status
    if (passed) {
      await query(
        `UPDATE found_items SET status = 'MATCHED' WHERE id = $1`,
        [claim.found_item_id]
      );
      await query(
        `UPDATE lost_items SET status = 'CLAIMED' WHERE id = $1`,
        [claim.lost_item_id]
      );
    }

    const attemptsRemaining = 3 - parseInt(attemptsToday.rows[0].count) - 1;

    res.json({
      success: true,
      data: {
        passed,
        score: correctCount,
        attempts_remaining: attemptsRemaining,
        message: passed 
          ? 'Verification successful! You can now coordinate the handover.'
          : `Verification failed. ${correctCount}/3 correct. ${attemptsRemaining} attempts remaining.`
      }
    });
  } catch (error) {
    console.error('Verify claim error:', error);
    res.status(500).json({ success: false, message: 'Verification failed' });
  }
}

// Generate OTP for handover
export async function generateHandoverOTP(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;

    // Get claim
    const claimResult = await query(
      `SELECT c.*, li.user_id as lost_item_owner, fi.finder_id
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       JOIN found_items fi ON c.found_item_id = fi.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (claimResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    const claim = claimResult.rows[0];

    // Only the verified owner can generate OTP
    if (claim.claimant_id !== userId) {
      res.status(403).json({ success: false, message: 'Only the item owner can generate the handover code' });
      return;
    }

    if (claim.status !== 'VERIFIED') {
      res.status(400).json({ success: false, message: 'Claim must be verified before generating handover code' });
      return;
    }

    // Check for existing valid OTP
    const existingOTP = await query(
      `SELECT id, otp_expires_at FROM handover_confirmations
       WHERE claim_id = $1 AND otp_expires_at > NOW() AND otp_verified = FALSE`,
      [claimId]
    );

    if (existingOTP.rows.length > 0) {
      res.status(400).json({
        success: false,
        message: 'A valid handover code already exists',
        expires_at: existingOTP.rows[0].otp_expires_at
      });
      return;
    }

    // Generate OTP
    const otp = generateOTP();
    const otpHash = await hashOTP(otp);

    // Store or update handover confirmation
    await query(
      `INSERT INTO handover_confirmations (claim_id, otp_code_hash, otp_expires_at)
       VALUES ($1, $2, NOW() + INTERVAL '24 hours')
       ON CONFLICT (claim_id) 
       DO UPDATE SET otp_code_hash = $2, otp_expires_at = NOW() + INTERVAL '24 hours', 
                     otp_verified = FALSE, verification_attempts = 0`,
      [claimId, otpHash]
    );

    // Log OTP generation
    await logOtpAction(req, parseInt(claimId), 'generated');

    res.json({
      success: true,
      data: {
        otp,
        expires_in: '24 hours',
        message: 'Share this code only when you physically receive your item. The finder will enter this code to confirm the return.'
      }
    });
  } catch (error) {
    console.error('Generate OTP error:', error);
    res.status(500).json({ success: false, message: 'Failed to generate handover code' });
  }
}

// Verify OTP and complete handover
export async function confirmHandover(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;
    const { otp } = req.body;

    // Get claim and handover info
    const claimResult = await query(
      `SELECT c.*, h.id as handover_id, h.otp_code_hash, h.otp_expires_at, 
              h.otp_verified, h.verification_attempts,
              fi.finder_id, li.user_id as owner_id
       FROM claims c
       JOIN handover_confirmations h ON h.claim_id = c.id
       JOIN found_items fi ON c.found_item_id = fi.id
       JOIN lost_items li ON c.lost_item_id = li.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (claimResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim or handover not found' });
      return;
    }

    const data = claimResult.rows[0];

    // Only finder or coop staff can confirm handover
    const isFinderOrCoopStaff = data.finder_id === userId || req.user!.role === UserRole.COOP_STAFF;
    if (!isFinderOrCoopStaff) {
      res.status(403).json({ success: false, message: 'Only the finder or cooperative staff can confirm the handover' });
      return;
    }

    if (data.otp_verified) {
      res.status(400).json({ success: false, message: 'Handover already confirmed' });
      return;
    }

    if (new Date(data.otp_expires_at) < new Date()) {
      res.status(400).json({ success: false, message: 'Handover code has expired. Please request a new one.' });
      return;
    }

    if (data.verification_attempts >= 3) {
      res.status(429).json({ success: false, message: 'Too many failed attempts. Please contact support.' });
      return;
    }

    // Verify OTP
    const isValid = await verifyOTP(otp, data.otp_code_hash);

    if (!isValid) {
      // Increment attempts
      await query(
        `UPDATE handover_confirmations SET verification_attempts = verification_attempts + 1 WHERE id = $1`,
        [data.handover_id]
      );
      
      await logOtpAction(req, parseInt(claimId), 'failed');

      res.status(400).json({
        success: false,
        message: 'Invalid handover code',
        attempts_remaining: 2 - data.verification_attempts
      });
      return;
    }

    // Success - complete handover
    await transaction(async (client) => {
      // Update handover
      await client.query(
        `UPDATE handover_confirmations 
         SET otp_verified = TRUE, returned_at = NOW(), return_confirmed_by = $1
         WHERE id = $2`,
        [userId, data.handover_id]
      );

      // Update claim
      await client.query(
        `UPDATE claims SET status = 'RETURNED' WHERE id = $1`,
        [claimId]
      );

      // Update items
      await client.query(
        `UPDATE lost_items SET status = 'RETURNED' WHERE id = $1`,
        [data.lost_item_id]
      );
      await client.query(
        `UPDATE found_items SET status = 'RETURNED' WHERE id = $1`,
        [data.found_item_id]
      );
    });

    // Log and update trust scores
    await logOtpAction(req, parseInt(claimId), 'verified');
    await onSuccessfulReturn(req, data.finder_id, data.owner_id);

    res.json({
      success: true,
      message: 'Item return confirmed successfully! Thank you for using Byaboneka+.'
    });
  } catch (error) {
    console.error('Confirm handover error:', error);
    res.status(500).json({ success: false, message: 'Failed to confirm handover' });
  }
}

// Get claim details
export async function getClaim(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;

    const result = await query(
      `SELECT c.*, 
              li.title as lost_item_title, li.category,
              fi.title as found_item_title, fi.finder_id,
              h.otp_expires_at, h.otp_verified,
              u.name as claimant_name
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       JOIN found_items fi ON c.found_item_id = fi.id
       LEFT JOIN handover_confirmations h ON h.claim_id = c.id
       JOIN users u ON c.claimant_id = u.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (result.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    const claim = result.rows[0];

    // Only allow access to claim participants or admin
    const isParticipant = claim.claimant_id === userId || claim.finder_id === userId;
    if (!isParticipant && req.user!.role !== UserRole.ADMIN) {
      res.status(403).json({ success: false, message: 'Not authorized to view this claim' });
      return;
    }

    res.json({ success: true, data: claim });
  } catch (error) {
    console.error('Get claim error:', error);
    res.status(500).json({ success: false, message: 'Failed to get claim' });
  }
}

// Get user's claims
export async function getMyClaims(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );

    const countResult = await query(
      'SELECT COUNT(*) FROM claims WHERE claimant_id = $1',
      [userId]
    );
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT c.*, 
              li.title as lost_item_title, li.category,
              fi.title as found_item_title,
              h.otp_expires_at, h.otp_verified
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       JOIN found_items fi ON c.found_item_id = fi.id
       LEFT JOIN handover_confirmations h ON h.claim_id = c.id
       WHERE c.claimant_id = $1
       ORDER BY c.created_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get my claims error:', error);
    res.status(500).json({ success: false, message: 'Failed to get claims' });
  }
}

// Cancel claim
export async function cancelClaim(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;

    const claim = await query(
      'SELECT * FROM claims WHERE id = $1 AND claimant_id = $2',
      [claimId, userId]
    );

    if (claim.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    if (!['PENDING', 'VERIFIED'].includes(claim.rows[0].status)) {
      res.status(400).json({ success: false, message: 'Cannot cancel this claim' });
      return;
    }

    await query(
      `UPDATE claims SET status = 'CANCELLED' WHERE id = $1`,
      [claimId]
    );

    // Revert item statuses if needed
    if (claim.rows[0].status === 'VERIFIED') {
      await query(`UPDATE found_items SET status = 'UNCLAIMED' WHERE id = $1`, [claim.rows[0].found_item_id]);
      await query(`UPDATE lost_items SET status = 'ACTIVE' WHERE id = $1`, [claim.rows[0].lost_item_id]);
    }

    res.json({ success: true, message: 'Claim cancelled' });
  } catch (error) {
    console.error('Cancel claim error:', error);
    res.status(500).json({ success: false, message: 'Failed to cancel claim' });
  }
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/cooperativesController.ts
‚îÇ Language: TypeScript | Lines: 336 | Size: 10.5 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query } from '../config/database';
import { parsePaginationParams, hashPassword } from '../utils';
import { logCreate, logUpdate, logModeration } from '../services/auditService';
import { UserRole, CooperativeStatus } from '../types';

// ============================================
// COOPERATIVES CONTROLLER
// ============================================

// Get all cooperatives (public)
export async function getCooperatives(req: Request, res: Response): Promise<void> {
  try {
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );
    const { status, search } = req.query;

    const conditions: string[] = [];
    const params: any[] = [];
    let paramIndex = 1;

    if (status) {
      conditions.push(`status = $${paramIndex++}`);
      params.push(status);
    } else {
      // By default, only show verified cooperatives to public
      if (req.user?.role !== 'admin') {
        conditions.push(`status = 'VERIFIED'`);
      }
    }

    if (search) {
      conditions.push(`LOWER(name) LIKE LOWER($${paramIndex++})`);
      params.push(`%${search}%`);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    const countResult = await query(`SELECT COUNT(*) FROM cooperatives ${whereClause}`, params);
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT c.*, 
              (SELECT COUNT(*) FROM users WHERE cooperative_id = c.id) as staff_count,
              (SELECT COUNT(*) FROM found_items WHERE cooperative_id = c.id) as items_count
       FROM cooperatives c
       ${whereClause}
       ORDER BY c.name ASC
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
      [...params, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get cooperatives error:', error);
    res.status(500).json({ success: false, message: 'Failed to get cooperatives' });
  }
}

// Get single cooperative
export async function getCooperative(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;

    const result = await query(
      `SELECT c.*, 
              (SELECT COUNT(*) FROM users WHERE cooperative_id = c.id) as staff_count,
              (SELECT COUNT(*) FROM found_items WHERE cooperative_id = c.id) as items_count,
              (SELECT COUNT(*) FROM found_items WHERE cooperative_id = c.id AND status = 'RETURNED') as returned_count
       FROM cooperatives c
       WHERE c.id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Cooperative not found' });
      return;
    }

    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('Get cooperative error:', error);
    res.status(500).json({ success: false, message: 'Failed to get cooperative' });
  }
}

// Create cooperative (admin only)
export async function createCooperative(req: Request, res: Response): Promise<void> {
  try {
    const { name, registration_number, contact_info, address } = req.body;

    // Check for duplicate registration number
    const existing = await query(
      'SELECT id FROM cooperatives WHERE registration_number = $1',
      [registration_number]
    );

    if (existing.rows.length > 0) {
      res.status(409).json({ success: false, message: 'Registration number already exists' });
      return;
    }

    const result = await query(
      `INSERT INTO cooperatives (name, registration_number, contact_info, address, status)
       VALUES ($1, $2, $3, $4, 'PENDING')
       RETURNING *`,
      [name, registration_number, contact_info, address || null]
    );

    await logCreate(req, 'cooperative', result.rows[0].id, { name, registration_number });

    res.status(201).json({
      success: true,
      data: result.rows[0],
      message: 'Cooperative created successfully'
    });
  } catch (error) {
    console.error('Create cooperative error:', error);
    res.status(500).json({ success: false, message: 'Failed to create cooperative' });
  }
}

// Update cooperative status (admin only)
export async function updateCooperativeStatus(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const { status } = req.body;

    const existing = await query('SELECT * FROM cooperatives WHERE id = $1', [id]);
    if (existing.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Cooperative not found' });
      return;
    }

    const result = await query(
      `UPDATE cooperatives SET status = $1, verified_by = $2, verified_at = NOW()
       WHERE id = $3
       RETURNING *`,
      [status, req.user!.userId, id]
    );

    await logModeration(req, 'COOPERATIVE_STATUS_CHANGED', 'cooperative', parseInt(id), {
      old_status: existing.rows[0].status,
      new_status: status
    });

    res.json({
      success: true,
      data: result.rows[0],
      message: `Cooperative ${status.toLowerCase()}`
    });
  } catch (error) {
    console.error('Update cooperative status error:', error);
    res.status(500).json({ success: false, message: 'Failed to update cooperative status' });
  }
}

// Add staff to cooperative (admin only)
export async function addCooperativeStaff(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const { email, password, name, phone } = req.body;

    // Check cooperative exists and is verified
    const coopResult = await query(
      `SELECT id, status FROM cooperatives WHERE id = $1`,
      [id]
    );

    if (coopResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Cooperative not found' });
      return;
    }

    if (coopResult.rows[0].status !== 'VERIFIED') {
      res.status(400).json({ success: false, message: 'Cooperative must be verified first' });
      return;
    }

    // Check email not taken
    const existingUser = await query('SELECT id FROM users WHERE email = $1', [email.toLowerCase()]);
    if (existingUser.rows.length > 0) {
      res.status(409).json({ success: false, message: 'Email already registered' });
      return;
    }

    // Create staff user
    const passwordHash = await hashPassword(password);
    const result = await query(
      `INSERT INTO users (email, password_hash, name, phone, role, cooperative_id, trust_score)
       VALUES ($1, $2, $3, $4, $5, $6, 5)
       RETURNING id, email, name, phone, role`,
      [email.toLowerCase(), passwordHash, name, phone || null, UserRole.COOP_STAFF, id]
    );

    await logCreate(req, 'user', result.rows[0].id, {
      email: result.rows[0].email,
      role: UserRole.COOP_STAFF,
      cooperative_id: id
    });

    res.status(201).json({
      success: true,
      data: result.rows[0],
      message: 'Staff member added successfully'
    });
  } catch (error) {
    console.error('Add cooperative staff error:', error);
    res.status(500).json({ success: false, message: 'Failed to add staff member' });
  }
}

// Get cooperative staff
export async function getCooperativeStaff(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;

    const result = await query(
      `SELECT id, email, name, phone, trust_score, created_at
       FROM users
       WHERE cooperative_id = $1 AND role = 'coop_staff'
       ORDER BY name ASC`,
      [id]
    );

    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('Get cooperative staff error:', error);
    res.status(500).json({ success: false, message: 'Failed to get staff' });
  }
}

// Get cooperative found items
export async function getCooperativeItems(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );
    const { status } = req.query;

    let whereClause = 'WHERE f.cooperative_id = $1';
    const params: any[] = [id];

    if (status) {
      whereClause += ` AND f.status = $2`;
      params.push(status);
    }

    const countResult = await query(
      `SELECT COUNT(*) FROM found_items f ${whereClause}`,
      params
    );
    const total = parseInt(countResult.rows[0].count);

    const paramOffset = params.length + 1;
    const result = await query(
      `SELECT f.*, u.name as finder_name
       FROM found_items f
       JOIN users u ON f.finder_id = u.id
       ${whereClause}
       ORDER BY f.created_at DESC
       LIMIT $${paramOffset} OFFSET $${paramOffset + 1}`,
      [...params, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get cooperative items error:', error);
    res.status(500).json({ success: false, message: 'Failed to get items' });
  }
}

// Get cooperative dashboard (for coop staff)
export async function getCooperativeDashboard(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;

    // Get user's cooperative
    const userResult = await query(
      'SELECT cooperative_id FROM users WHERE id = $1',
      [userId]
    );

    if (!userResult.rows[0]?.cooperative_id) {
      res.status(403).json({ success: false, message: 'You are not assigned to a cooperative' });
      return;
    }

    const cooperativeId = userResult.rows[0].cooperative_id;

    const [coopInfo, itemStats, recentItems] = await Promise.all([
      query('SELECT * FROM cooperatives WHERE id = $1', [cooperativeId]),
      query(`
        SELECT 
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE status = 'UNCLAIMED') as unclaimed,
          COUNT(*) FILTER (WHERE status = 'MATCHED') as matched,
          COUNT(*) FILTER (WHERE status = 'RETURNED') as returned
        FROM found_items WHERE cooperative_id = $1
      `, [cooperativeId]),
      query(`
        SELECT f.*, u.name as finder_name
        FROM found_items f
        JOIN users u ON f.finder_id = u.id
        WHERE f.cooperative_id = $1
        ORDER BY f.created_at DESC
        LIMIT 10
      `, [cooperativeId])
    ]);

    res.json({
      success: true,
      data: {
        cooperative: coopInfo.rows[0],
        stats: itemStats.rows[0],
        recent_items: recentItems.rows
      }
    });
  } catch (error) {
    console.error('Get cooperative dashboard error:', error);
    res.status(500).json({ success: false, message: 'Failed to get dashboard' });
  }
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/foundItemsController.ts
‚îÇ Language: TypeScript | Lines: 360 | Size: 11.9 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query } from '../config/database';
import { extractKeywords, parsePaginationParams } from '../utils';
import { logCreate, logUpdate, logDelete } from '../services/auditService';
import { onItemCreated, findMatchesForFoundItem } from '../services/matchingService';
import { ItemCategory, FoundItemStatus, ItemSource, UserRole } from '../types';

// ============================================
// FOUND ITEMS CONTROLLER
// ============================================

// Create found item report
export async function createFoundItem(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const {
      category,
      title,
      description,
      location_area,
      location_hint,
      found_date,
      cooperative_id
    } = req.body;

    // Determine source
    let source = ItemSource.CITIZEN;
    let coopId = null;

    if (req.user!.role === UserRole.COOP_STAFF && cooperative_id) {
      const userResult = await query(
        'SELECT cooperative_id FROM users WHERE id = $1',
        [userId]
      );
      
      if (userResult.rows[0]?.cooperative_id === cooperative_id) {
        source = ItemSource.COOPERATIVE;
        coopId = cooperative_id;
      }
    }

    const keywords = extractKeywords(`${title} ${description}`);

    const result = await query(
      `INSERT INTO found_items (finder_id, cooperative_id, category, title, description, 
        location_area, location_hint, found_date, source, keywords, image_urls)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
       RETURNING *`,
      [userId, coopId, category, title, description, location_area, 
       location_hint || null, found_date, source, keywords, []]
    );

    const foundItem = result.rows[0];
    await logCreate(req, 'found_item', foundItem.id, { title, category, source });
    setImmediate(() => onItemCreated('found', foundItem.id));

    res.status(201).json({
      success: true,
      data: foundItem,
      message: 'Found item report created successfully'
    });
  } catch (error) {
    console.error('Create found item error:', error);
    res.status(500).json({ success: false, message: 'Failed to create found item report' });
  }
}

// Get all found items (public, with filters)
export async function getFoundItems(req: Request, res: Response): Promise<void> {
  try {
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );

    const { category, location_area, date_from, date_to, keyword, status } = req.query;

    const conditions: string[] = [];
    const params: any[] = [];
    let paramIndex = 1;

    if (status) {
      conditions.push(`f.status = $${paramIndex++}`);
      params.push(status);
    } else {
      conditions.push(`f.status = 'UNCLAIMED'`);
    }

    if (category) {
      conditions.push(`f.category = $${paramIndex++}`);
      params.push(category);
    }

    if (location_area) {
      conditions.push(`LOWER(f.location_area) LIKE LOWER($${paramIndex++})`);
      params.push(`%${location_area}%`);
    }

    if (date_from) {
      conditions.push(`f.found_date >= $${paramIndex++}`);
      params.push(date_from);
    }

    if (date_to) {
      conditions.push(`f.found_date <= $${paramIndex++}`);
      params.push(date_to);
    }

    if (keyword) {
      conditions.push(`(LOWER(f.title) LIKE LOWER($${paramIndex}) OR LOWER(f.description) LIKE LOWER($${paramIndex}))`);
      params.push(`%${keyword}%`);
      paramIndex++;
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    const countResult = await query(`SELECT COUNT(*) FROM found_items f ${whereClause}`, params);
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT f.id, f.category, f.title, 
              CASE WHEN f.category IN ('ID', 'WALLET') THEN LEFT(f.description, 100) || '...' ELSE f.description END as description,
              f.location_area, f.found_date, f.status, f.source,
              CASE WHEN f.category IN ('ID', 'WALLET') THEN ARRAY[]::text[] ELSE f.image_urls END as image_urls,
              f.created_at, u.name as finder_name, c.name as cooperative_name
       FROM found_items f
       JOIN users u ON f.finder_id = u.id
       LEFT JOIN cooperatives c ON f.cooperative_id = c.id
       ${whereClause}
       ORDER BY f.created_at DESC
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
      [...params, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get found items error:', error);
    res.status(500).json({ success: false, message: 'Failed to get found items' });
  }
}

// Get single found item
export async function getFoundItem(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;

    const result = await query(
      `SELECT f.*, u.name as finder_name, c.name as cooperative_name
       FROM found_items f
       JOIN users u ON f.finder_id = u.id
       LEFT JOIN cooperatives c ON f.cooperative_id = c.id
       WHERE f.id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Found item not found' });
      return;
    }

    let item = result.rows[0];
    const isFinder = req.user?.userId === item.finder_id;
    const isAdmin = req.user?.role === UserRole.ADMIN;

    if (!isFinder && !isAdmin && (item.category === 'ID' || item.category === 'WALLET')) {
      item = {
        ...item,
        description: item.description.substring(0, 100) + '...',
        image_urls: []
      };
    }

    res.json({ success: true, data: item });
  } catch (error) {
    console.error('Get found item error:', error);
    res.status(500).json({ success: false, message: 'Failed to get found item' });
  }
}

// Update found item
export async function updateFoundItem(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const userId = req.user!.userId;
    const { title, description, location_area, location_hint } = req.body;

    const existing = await query(
      'SELECT * FROM found_items WHERE id = $1 AND finder_id = $2',
      [id, userId]
    );

    if (existing.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Found item not found or no permission' });
      return;
    }

    const newKeywords = (title || description)
      ? extractKeywords(`${title || existing.rows[0].title} ${description || existing.rows[0].description}`)
      : existing.rows[0].keywords;

    const result = await query(
      `UPDATE found_items SET title = COALESCE($1, title), description = COALESCE($2, description),
        location_area = COALESCE($3, location_area), location_hint = COALESCE($4, location_hint), keywords = $5
       WHERE id = $6 RETURNING *`,
      [title, description, location_area, location_hint, newKeywords, id]
    );

    await logUpdate(req, 'found_item', parseInt(id), existing.rows[0], result.rows[0]);
    res.json({ success: true, data: result.rows[0], message: 'Found item updated' });
  } catch (error) {
    console.error('Update found item error:', error);
    res.status(500).json({ success: false, message: 'Failed to update found item' });
  }
}

// Delete found item
export async function deleteFoundItem(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const userId = req.user!.userId;

    const existing = await query(
      'SELECT * FROM found_items WHERE id = $1 AND finder_id = $2',
      [id, userId]
    );

    if (existing.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Found item not found or no permission' });
      return;
    }

    const activeClaim = await query(
      `SELECT id FROM claims WHERE found_item_id = $1 AND status IN ('PENDING', 'VERIFIED')`,
      [id]
    );

    if (activeClaim.rows.length > 0) {
      res.status(400).json({ success: false, message: 'Cannot delete with active claim' });
      return;
    }

    await query('DELETE FROM found_items WHERE id = $1', [id]);
    await logDelete(req, 'found_item', parseInt(id), existing.rows[0]);
    res.json({ success: true, message: 'Found item deleted' });
  } catch (error) {
    console.error('Delete found item error:', error);
    res.status(500).json({ success: false, message: 'Failed to delete found item' });
  }
}

// Upload images
export async function uploadFoundItemImages(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const userId = req.user!.userId;

    const existing = await query(
      'SELECT * FROM found_items WHERE id = $1 AND finder_id = $2',
      [id, userId]
    );

    if (existing.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Found item not found or no permission' });
      return;
    }

    if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {
      res.status(400).json({ success: false, message: 'No images uploaded' });
      return;
    }

    const newImageUrls = (req.files as Express.Multer.File[]).map(file => `/uploads/${file.filename}`);
    const currentImages = existing.rows[0].image_urls || [];
    const allImages = [...currentImages, ...newImageUrls].slice(0, 5);

    const result = await query(
      'UPDATE found_items SET image_urls = $1 WHERE id = $2 RETURNING *',
      [allImages, id]
    );

    res.json({ success: true, data: result.rows[0], message: 'Images uploaded' });
  } catch (error) {
    console.error('Upload images error:', error);
    res.status(500).json({ success: false, message: 'Failed to upload images' });
  }
}

// Get matches for found item
export async function getFoundItemMatches(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;

    const itemResult = await query('SELECT id, finder_id FROM found_items WHERE id = $1', [id]);

    if (itemResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Found item not found' });
      return;
    }

    const item = itemResult.rows[0];
    if (req.user?.userId !== item.finder_id && req.user?.role !== UserRole.ADMIN) {
      res.status(403).json({ success: false, message: 'Can only view matches for your own items' });
      return;
    }

    const matches = await findMatchesForFoundItem(parseInt(id));
    res.json({
      success: true,
      data: matches.map(m => ({
        lost_item: {
          id: m.lost_item.id,
          category: m.lost_item.category,
          title: m.lost_item.title,
          description: m.lost_item.description,
          location_area: m.lost_item.location_area,
          lost_date: m.lost_item.lost_date
        },
        score: m.score,
        explanation: m.explanation
      }))
    });
  } catch (error) {
    console.error('Get found item matches error:', error);
    res.status(500).json({ success: false, message: 'Failed to get matches' });
  }
}

// Get user's own found items
export async function getMyFoundItems(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );

    const countResult = await query('SELECT COUNT(*) FROM found_items WHERE finder_id = $1', [userId]);
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT f.*, (SELECT COUNT(*) FROM claims c WHERE c.found_item_id = f.id) as claim_count
       FROM found_items f WHERE f.finder_id = $1 ORDER BY f.created_at DESC LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get my found items error:', error);
    res.status(500).json({ success: false, message: 'Failed to get your found items' });
  }
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/lostItemsController.ts
‚îÇ Language: TypeScript | Lines: 465 | Size: 13.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query, transaction } from '../config/database';
import { extractKeywords, hashSecretAnswer, parsePaginationParams } from '../utils';
import { logCreate, logUpdate, logDelete } from '../services/auditService';
import { onItemCreated, findMatchesForLostItem } from '../services/matchingService';
import { ItemCategory, LostItemStatus } from '../types';

// ============================================
// LOST ITEMS CONTROLLER
// ============================================

// Create lost item report with verification secrets
export async function createLostItem(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const {
      category,
      title,
      description,
      location_area,
      location_hint,
      lost_date,
      photo_url,
      verification_questions
    } = req.body;

    // Extract keywords for matching
    const keywords = extractKeywords(`${title} ${description}`);

    // Create lost item and verification secrets in transaction
    const result = await transaction(async (client) => {
      // Create lost item
      const itemResult = await client.query(
        `INSERT INTO lost_items (user_id, category, title, description, location_area, location_hint, lost_date, keywords, photo_url)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
         RETURNING *`,
        [userId, category, title, description, location_area, location_hint || null, lost_date, keywords, photo_url || null]
      );

      const lostItem = itemResult.rows[0];

      // Hash verification answers
      const q1Answer = await hashSecretAnswer(verification_questions[0].answer);
      const q2Answer = await hashSecretAnswer(verification_questions[1].answer);
      const q3Answer = await hashSecretAnswer(verification_questions[2].answer);

      // Create verification secrets
      await client.query(
        `INSERT INTO verification_secrets (lost_item_id, 
          question_1_text, answer_1_hash, answer_1_salt,
          question_2_text, answer_2_hash, answer_2_salt,
          question_3_text, answer_3_hash, answer_3_salt)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`,
        [
          lostItem.id,
          verification_questions[0].question, q1Answer.hash, q1Answer.salt,
          verification_questions[1].question, q2Answer.hash, q2Answer.salt,
          verification_questions[2].question, q3Answer.hash, q3Answer.salt
        ]
      );

      return lostItem;
    });

    // Log creation
    await logCreate(req, 'lost_item', result.id, { title, category });

    // Trigger matching in background
    setImmediate(() => onItemCreated('lost', result.id));

    res.status(201).json({
      success: true,
      data: {
        id: result.id,
        category: result.category,
        title: result.title,
        description: result.description,
        location_area: result.location_area,
        location_hint: result.location_hint,
        lost_date: result.lost_date,
        status: result.status,
        photo_url: result.photo_url,
        created_at: result.created_at
      },
      message: 'Lost item report created successfully'
    });
  } catch (error) {
    console.error('Create lost item error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to create lost item report'
    });
  }
}

// Get all lost items (public, with filters)
export async function getLostItems(req: Request, res: Response): Promise<void> {
  try {
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );

    const {
      category,
      location_area,
      date_from,
      date_to,
      keyword,
      status
    } = req.query;

    // Build query conditions
    const conditions: string[] = [];
    const params: any[] = [];
    let paramIndex = 1;

    // Only show active items by default for public view
    if (status) {
      conditions.push(`l.status = $${paramIndex++}`);
      params.push(status);
    } else {
      conditions.push(`l.status = 'ACTIVE'`);
    }

    if (category) {
      conditions.push(`l.category = $${paramIndex++}`);
      params.push(category);
    }

    if (location_area) {
      conditions.push(`LOWER(l.location_area) LIKE LOWER($${paramIndex++})`);
      params.push(`%${location_area}%`);
    }

    if (date_from) {
      conditions.push(`l.lost_date >= $${paramIndex++}`);
      params.push(date_from);
    }

    if (date_to) {
      conditions.push(`l.lost_date <= $${paramIndex++}`);
      params.push(date_to);
    }

    if (keyword) {
      conditions.push(`(
        LOWER(l.title) LIKE LOWER($${paramIndex}) OR 
        LOWER(l.description) LIKE LOWER($${paramIndex}) OR
        $${paramIndex}::text = ANY(l.keywords)
      )`);
      params.push(`%${keyword}%`);
      paramIndex++;
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    // Get total count
    const countResult = await query(
      `SELECT COUNT(*) FROM lost_items l ${whereClause}`,
      params
    );
    const total = parseInt(countResult.rows[0].count);

    // Get items with user info
    const result = await query(
      `SELECT l.id, l.category, l.title, l.description, l.location_area, 
              l.location_hint, l.lost_date, l.status, l.photo_url, l.created_at,
              u.name as user_name
       FROM lost_items l
       JOIN users u ON l.user_id = u.id
       ${whereClause}
       ORDER BY l.created_at DESC
       LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
      [...params, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get lost items error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get lost items'
    });
  }
}

// Get single lost item
export async function getLostItem(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;

    const result = await query(
      `SELECT l.*, u.name as user_name, u.id as user_id
       FROM lost_items l
       JOIN users u ON l.user_id = u.id
       WHERE l.id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: 'Lost item not found'
      });
      return;
    }

    const item = result.rows[0];

    // If user is the owner, include verification questions (not answers)
    let verificationQuestions = null;
    if (req.user?.userId === item.user_id) {
      const secretsResult = await query(
        `SELECT question_1_text, question_2_text, question_3_text
         FROM verification_secrets WHERE lost_item_id = $1`,
        [id]
      );
      if (secretsResult.rows.length > 0) {
        verificationQuestions = [
          secretsResult.rows[0].question_1_text,
          secretsResult.rows[0].question_2_text,
          secretsResult.rows[0].question_3_text
        ];
      }
    }

    res.json({
      success: true,
      data: {
        ...item,
        verification_questions: verificationQuestions
      }
    });
  } catch (error) {
    console.error('Get lost item error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get lost item'
    });
  }
}

// Update lost item (owner only)
export async function updateLostItem(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const userId = req.user!.userId;
    const { title, description, location_area, location_hint, photo_url } = req.body;

    // Check ownership
    const existing = await query(
      'SELECT * FROM lost_items WHERE id = $1 AND user_id = $2',
      [id, userId]
    );

    if (existing.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: 'Lost item not found or you do not have permission to update it'
      });
      return;
    }

    // Update keywords if title/description changed
    const newKeywords = (title || description)
      ? extractKeywords(`${title || existing.rows[0].title} ${description || existing.rows[0].description}`)
      : existing.rows[0].keywords;

    const result = await query(
      `UPDATE lost_items SET
        title = COALESCE($1, title),
        description = COALESCE($2, description),
        location_area = COALESCE($3, location_area),
        location_hint = COALESCE($4, location_hint),
        photo_url = COALESCE($5, photo_url),
        keywords = $6
       WHERE id = $7
       RETURNING *`,
      [title, description, location_area, location_hint, photo_url, newKeywords, id]
    );

    // Log update
    await logUpdate(req, 'lost_item', parseInt(id), existing.rows[0], result.rows[0]);

    res.json({
      success: true,
      data: result.rows[0],
      message: 'Lost item updated successfully'
    });
  } catch (error) {
    console.error('Update lost item error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update lost item'
    });
  }
}

// Delete lost item (owner only)
export async function deleteLostItem(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;
    const userId = req.user!.userId;

    // Check ownership and status
    const existing = await query(
      'SELECT * FROM lost_items WHERE id = $1 AND user_id = $2',
      [id, userId]
    );

    if (existing.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: 'Lost item not found or you do not have permission to delete it'
      });
      return;
    }

    // Don't allow deletion if there's an active claim
    const activeClaim = await query(
      `SELECT id FROM claims WHERE lost_item_id = $1 AND status IN ('PENDING', 'VERIFIED')`,
      [id]
    );

    if (activeClaim.rows.length > 0) {
      res.status(400).json({
        success: false,
        message: 'Cannot delete lost item with an active claim'
      });
      return;
    }

    // Delete (will cascade to verification_secrets)
    await query('DELETE FROM lost_items WHERE id = $1', [id]);

    // Log deletion
    await logDelete(req, 'lost_item', parseInt(id), existing.rows[0]);

    res.json({
      success: true,
      message: 'Lost item deleted successfully'
    });
  } catch (error) {
    console.error('Delete lost item error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete lost item'
    });
  }
}

// Get matches for a lost item
export async function getLostItemMatches(req: Request, res: Response): Promise<void> {
  try {
    const { id } = req.params;

    // Verify item exists
    const itemResult = await query(
      'SELECT id, user_id, status FROM lost_items WHERE id = $1',
      [id]
    );

    if (itemResult.rows.length === 0) {
      res.status(404).json({
        success: false,
        message: 'Lost item not found'
      });
      return;
    }

    const item = itemResult.rows[0];

    // Only owner can view matches for their item
    if (req.user?.userId !== item.user_id && req.user?.role !== 'admin') {
      res.status(403).json({
        success: false,
        message: 'You can only view matches for your own lost items'
      });
      return;
    }

    // Get matches
    const matches = await findMatchesForLostItem(parseInt(id));

    res.json({
      success: true,
      data: matches.map(m => ({
        found_item: {
          id: m.found_item.id,
          category: m.found_item.category,
          title: m.found_item.title,
          description: m.found_item.description,
          location_area: m.found_item.location_area,
          found_date: m.found_item.found_date,
          image_urls: m.found_item.image_urls,
          source: m.found_item.source
        },
        score: m.score,
        explanation: m.explanation
      }))
    });
  } catch (error) {
    console.error('Get lost item matches error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get matches'
    });
  }
}

// Get user's own lost items
export async function getMyLostItems(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );

    const countResult = await query(
      'SELECT COUNT(*) FROM lost_items WHERE user_id = $1',
      [userId]
    );
    const total = parseInt(countResult.rows[0].count);

    const result = await query(
      `SELECT l.*, 
              (SELECT COUNT(*) FROM matches m WHERE m.lost_item_id = l.id) as match_count,
              (SELECT COUNT(*) FROM claims c WHERE c.lost_item_id = l.id AND c.status = 'VERIFIED') as claim_count
       FROM lost_items l
       WHERE l.user_id = $1
       ORDER BY l.created_at DESC
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    res.json({
      success: true,
      data: result.rows,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });
  } catch (error) {
    console.error('Get my lost items error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to get your lost items'
    });
  }
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/controllers/messagesController.ts
‚îÇ Language: TypeScript | Lines: 280 | Size: 8.9 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response } from 'express';
import { query } from '../config/database';
import { parsePaginationParams, isMessageFlaggable } from '../utils';
import { UserRole } from '../types';

// ============================================
// MESSAGES CONTROLLER
// In-app Messaging for Claims
// ============================================

// Send message in claim thread
export async function sendMessage(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;
    const { content } = req.body;

    // Get claim and verify user is a participant
    const claimResult = await query(
      `SELECT c.*, fi.finder_id, li.user_id as owner_id
       FROM claims c
       JOIN found_items fi ON c.found_item_id = fi.id
       JOIN lost_items li ON c.lost_item_id = li.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (claimResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    const claim = claimResult.rows[0];

    // Only allow messaging between verified claim participants
    const isOwner = claim.owner_id === userId;
    const isFinder = claim.finder_id === userId;

    if (!isOwner && !isFinder) {
      res.status(403).json({ success: false, message: 'Not authorized to message in this claim' });
      return;
    }

    // Only allow messaging for verified claims
    if (!['VERIFIED', 'PENDING'].includes(claim.status)) {
      res.status(400).json({ success: false, message: 'Messaging is not available for this claim status' });
      return;
    }

    // Determine receiver
    const receiverId = isOwner ? claim.finder_id : claim.owner_id;

    // Check for flaggable content
    const flagCheck = isMessageFlaggable(content);

    // Create message
    const result = await query(
      `INSERT INTO messages (sender_id, receiver_id, claim_id, content, is_flagged, flag_reason)
       VALUES ($1, $2, $3, $4, $5, $6)
       RETURNING *`,
      [userId, receiverId, claimId, content, flagCheck.flagged, flagCheck.reason || null]
    );

    const message = result.rows[0];

    // Add warning if flagged
    const responseMessage = flagCheck.flagged
      ? {
          ...message,
          warning: 'Your message contains potentially suspicious content. Remember: Never pay money before verification.'
        }
      : message;

    res.status(201).json({
      success: true,
      data: responseMessage
    });
  } catch (error) {
    console.error('Send message error:', error);
    res.status(500).json({ success: false, message: 'Failed to send message' });
  }
}

// Get messages for a claim
export async function getClaimMessages(req: Request, res: Response): Promise<void> {
  try {
    const { claimId } = req.params;
    const userId = req.user!.userId;

    // Verify user is a participant
    const claimResult = await query(
      `SELECT c.*, fi.finder_id, li.user_id as owner_id
       FROM claims c
       JOIN found_items fi ON c.found_item_id = fi.id
       JOIN lost_items li ON c.lost_item_id = li.id
       WHERE c.id = $1`,
      [claimId]
    );

    if (claimResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Claim not found' });
      return;
    }

    const claim = claimResult.rows[0];
    const isOwner = claim.owner_id === userId;
    const isFinder = claim.finder_id === userId;

    if (!isOwner && !isFinder && req.user!.role !== UserRole.ADMIN) {
      res.status(403).json({ success: false, message: 'Not authorized to view these messages' });
      return;
    }

    // Get messages
    const result = await query(
      `SELECT m.*, 
              u.name as sender_name,
              CASE WHEN m.sender_id = $2 THEN true ELSE false END as is_mine
       FROM messages m
       JOIN users u ON m.sender_id = u.id
       WHERE m.claim_id = $1
       ORDER BY m.created_at ASC`,
      [claimId, userId]
    );

    // Mark messages as read
    await query(
      `UPDATE messages SET is_read = true WHERE claim_id = $1 AND receiver_id = $2`,
      [claimId, userId]
    );

    res.json({
      success: true,
      data: result.rows,
      warning: 'Never pay money before item verification and handover. Report suspicious behavior.'
    });
  } catch (error) {
    console.error('Get messages error:', error);
    res.status(500).json({ success: false, message: 'Failed to get messages' });
  }
}

// Get all message threads for current user
export async function getMessageThreads(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;
    const { page, limit, offset } = parsePaginationParams(
      req.query.page as string,
      req.query.limit as string
    );

    // Get claims where user is participant
    const result = await query(
      `SELECT DISTINCT ON (c.id)
              c.id as claim_id,
              c.status as claim_status,
              li.title as item_title,
              li.category,
              CASE WHEN li.user_id = $1 THEN 'owner' ELSE 'finder' END as my_role,
              CASE WHEN li.user_id = $1 THEN finder.name ELSE owner.name END as other_party_name,
              (SELECT content FROM messages WHERE claim_id = c.id ORDER BY created_at DESC LIMIT 1) as last_message,
              (SELECT created_at FROM messages WHERE claim_id = c.id ORDER BY created_at DESC LIMIT 1) as last_message_at,
              (SELECT COUNT(*) FROM messages WHERE claim_id = c.id AND receiver_id = $1 AND is_read = false) as unread_count
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       JOIN found_items fi ON c.found_item_id = fi.id
       JOIN users owner ON li.user_id = owner.id
       JOIN users finder ON fi.finder_id = finder.id
       WHERE li.user_id = $1 OR fi.finder_id = $1
       ORDER BY c.id, last_message_at DESC NULLS LAST
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    const countResult = await query(
      `SELECT COUNT(DISTINCT c.id)
       FROM claims c
       JOIN lost_items li ON c.lost_item_id = li.id
       JOIN found_items fi ON c.found_item_id = fi.id
       WHERE li.user_id = $1 OR fi.finder_id = $1`,
      [userId]
    );
    const total = parseInt(countResult.rows[0].count);

    res.json({
      success: true,
      data: result.rows,
      pagination: { page, limit, total, totalPages: Math.ceil(total / limit) }
    });
  } catch (error) {
    console.error('Get message threads error:', error);
    res.status(500).json({ success: false, message: 'Failed to get message threads' });
  }
}

// Report scam
export async function reportScam(req: Request, res: Response): Promise<void> {
  try {
    const { messageId } = req.params;
    const userId = req.user!.userId;
    const { reason } = req.body;

    // Get message
    const messageResult = await query(
      `SELECT m.*, c.id as claim_id
       FROM messages m
       JOIN claims c ON m.claim_id = c.id
       WHERE m.id = $1`,
      [messageId]
    );

    if (messageResult.rows.length === 0) {
      res.status(404).json({ success: false, message: 'Message not found' });
      return;
    }

    const message = messageResult.rows[0];

    // Can only report messages received
    if (message.receiver_id !== userId) {
      res.status(403).json({ success: false, message: 'You can only report messages you received' });
      return;
    }

    // Check for existing report
    const existingReport = await query(
      `SELECT id FROM scam_reports WHERE message_id = $1 AND reporter_id = $2`,
      [messageId, userId]
    );

    if (existingReport.rows.length > 0) {
      res.status(409).json({ success: false, message: 'You have already reported this message' });
      return;
    }

    // Create report
    const result = await query(
      `INSERT INTO scam_reports (reporter_id, message_id, reported_user_id, claim_id, reason)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING *`,
      [userId, messageId, message.sender_id, message.claim_id, reason]
    );

    // Flag the message
    await query(
      `UPDATE messages SET is_flagged = true, flag_reason = 'Reported by recipient' WHERE id = $1`,
      [messageId]
    );

    res.status(201).json({
      success: true,
      data: result.rows[0],
      message: 'Scam report submitted. Our team will review it.'
    });
  } catch (error) {
    console.error('Report scam error:', error);
    res.status(500).json({ success: false, message: 'Failed to report scam' });
  }
}

// Get unread message count
export async function getUnreadCount(req: Request, res: Response): Promise<void> {
  try {
    const userId = req.user!.userId;

    const result = await query(
      `SELECT COUNT(*) FROM messages WHERE receiver_id = $1 AND is_read = false`,
      [userId]
    );

    res.json({
      success: true,
      data: { unread_count: parseInt(result.rows[0].count) }
    });
  } catch (error) {
    console.error('Get unread count error:', error);
    res.status(500).json({ success: false, message: 'Failed to get unread count' });
  }
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/middleware/auth.ts
‚îÇ Language: TypeScript | Lines: 262 | Size: 6.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response, NextFunction } from 'express';
import { verifyAccessToken } from '../utils';
import { UserRole, TokenPayload } from '../types';
import { query } from '../config/database';

// Extend Express Request to include user
declare global {
  namespace Express {
    interface Request {
      user?: TokenPayload & { trust_score?: number; is_banned?: boolean };
    }
  }
}

// ============================================
// AUTHENTICATION MIDDLEWARE
// ============================================

export async function authenticate(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      res.status(401).json({
        success: false,
        message: 'Access token required'
      });
      return;
    }

    const token = authHeader.substring(7);
    const payload = verifyAccessToken(token);

    // Check if user is banned
    const userResult = await query(
      'SELECT trust_score, is_banned FROM users WHERE id = $1',
      [payload.userId]
    );

    if (userResult.rows.length === 0) {
      res.status(401).json({
        success: false,
        message: 'User not found'
      });
      return;
    }

    const user = userResult.rows[0];

    if (user.is_banned) {
      res.status(403).json({
        success: false,
        message: 'Account has been suspended'
      });
      return;
    }

    req.user = {
      ...payload,
      trust_score: user.trust_score,
      is_banned: user.is_banned
    };

    next();
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      res.status(401).json({
        success: false,
        message: 'Access token expired'
      });
      return;
    }

    if (error.name === 'JsonWebTokenError') {
      res.status(401).json({
        success: false,
        message: 'Invalid access token'
      });
      return;
    }

    console.error('Authentication error:', error);
    res.status(500).json({
      success: false,
      message: 'Authentication failed'
    });
  }
}

// Optional authentication - doesn't fail if no token
export async function optionalAuth(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const authHeader = req.headers.authorization;

    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      const payload = verifyAccessToken(token);

      const userResult = await query(
        'SELECT trust_score, is_banned FROM users WHERE id = $1',
        [payload.userId]
      );

      if (userResult.rows.length > 0 && !userResult.rows[0].is_banned) {
        req.user = {
          ...payload,
          trust_score: userResult.rows[0].trust_score,
          is_banned: userResult.rows[0].is_banned
        };
      }
    }

    next();
  } catch (error) {
    // Silently continue without auth
    next();
  }
}

// ============================================
// AUTHORIZATION MIDDLEWARE
// ============================================

export function authorize(...allowedRoles: UserRole[]) {
  return (req: Request, res: Response, next: NextFunction): void => {
    if (!req.user) {
      res.status(401).json({
        success: false,
        message: 'Authentication required'
      });
      return;
    }

    if (!allowedRoles.includes(req.user.role)) {
      res.status(403).json({
        success: false,
        message: 'You do not have permission to perform this action'
      });
      return;
    }

    next();
  };
}

// Admin only
export const adminOnly = authorize(UserRole.ADMIN);

// Admin or cooperative staff
export const adminOrCoopStaff = authorize(UserRole.ADMIN, UserRole.COOP_STAFF);

// Cooperative staff only (for their own cooperative)
export async function coopStaffForCooperative(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  if (!req.user) {
    res.status(401).json({
      success: false,
      message: 'Authentication required'
    });
    return;
  }

  if (req.user.role === UserRole.ADMIN) {
    // Admins can access any cooperative
    next();
    return;
  }

  if (req.user.role !== UserRole.COOP_STAFF) {
    res.status(403).json({
      success: false,
      message: 'Only cooperative staff can perform this action'
    });
    return;
  }

  // Get cooperative ID from request (could be param or body)
  const cooperativeId = req.params.cooperativeId || req.body.cooperative_id;

  if (!cooperativeId) {
    res.status(400).json({
      success: false,
      message: 'Cooperative ID required'
    });
    return;
  }

  // Check if user belongs to this cooperative
  const result = await query(
    'SELECT cooperative_id FROM users WHERE id = $1',
    [req.user.userId]
  );

  if (result.rows.length === 0 || result.rows[0].cooperative_id !== parseInt(cooperativeId)) {
    res.status(403).json({
      success: false,
      message: 'You can only manage your own cooperative'
    });
    return;
  }

  next();
}

// Check if user owns the resource
export function ownerOrAdmin(resourceUserIdExtractor: (req: Request) => Promise<number | null>) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    if (!req.user) {
      res.status(401).json({
        success: false,
        message: 'Authentication required'
      });
      return;
    }

    // Admins can access anything
    if (req.user.role === UserRole.ADMIN) {
      next();
      return;
    }

    try {
      const resourceOwnerId = await resourceUserIdExtractor(req);

      if (resourceOwnerId === null) {
        res.status(404).json({
          success: false,
          message: 'Resource not found'
        });
        return;
      }

      if (resourceOwnerId !== req.user.userId) {
        res.status(403).json({
          success: false,
          message: 'You can only access your own resources'
        });
        return;
      }

      next();
    } catch (error) {
      console.error('Owner check error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to verify resource ownership'
      });
    }
  };
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/middleware/emailVerification.ts
‚îÇ Language: TypeScript | Lines: 101 | Size: 2.5 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Email Verification Middleware for Byaboneka+
 * 
 * Requires verified email for sensitive actions.
 * FIX BUG-02: Bypasses in development/test environments since
 * email sending isn't implemented for MVP.
 */

import { Request, Response, NextFunction } from 'express';
import { query } from '../config/database';

/**
 * Middleware to require email verification for sensitive actions
 * Must be used AFTER authenticate middleware
 * 
 * In development/test: bypasses the check to allow full flow testing
 * In production: enforces email verification
 */
export async function requireVerifiedEmail(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  // FIX BUG-02: Skip email verification in non-production environments
  // This allows the full claim ‚Üí OTP ‚Üí handover flow to work during development & testing
  if (process.env.NODE_ENV !== 'production') {
    return next();
  }

  if (!req.user?.userId) {
    res.status(401).json({
      success: false,
      message: 'Authentication required'
    });
    return;
  }
  
  try {
    const result = await query(
      'SELECT email_verified FROM users WHERE id = $1',
      [req.user.userId]
    );
    
    if (result.rows.length === 0) {
      res.status(401).json({
        success: false,
        message: 'User not found'
      });
      return;
    }
    
    if (!result.rows[0].email_verified) {
      res.status(403).json({
        success: false,
        message: 'Email verification required for this action. Please verify your email first.',
        requiresEmailVerification: true
      });
      return;
    }
    
    next();
  } catch (error) {
    console.error('Email verification middleware error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to check email verification status'
    });
  }
}

/**
 * Optional email verification - warns but doesn't block
 */
export async function warnUnverifiedEmail(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  if (!req.user?.userId) {
    next();
    return;
  }
  
  try {
    const result = await query(
      'SELECT email_verified FROM users WHERE id = $1',
      [req.user.userId]
    );
    
    if (result.rows.length > 0 && !result.rows[0].email_verified) {
      // Add warning to response locals
      res.locals.emailWarning = 'Your email is not verified. Some features may be limited.';
    }
    
    next();
  } catch (error) {
    // Don't block the request if check fails
    console.error('Email verification warning check failed:', error);
    next();
  }
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/middleware/errorHandler.ts
‚îÇ Language: TypeScript | Lines: 108 | Size: 2.2 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response, NextFunction } from 'express';

// Custom error class
export class AppError extends Error {
  statusCode: number;
  isOperational: boolean;

  constructor(message: string, statusCode: number = 500) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// Not found handler
export function notFoundHandler(req: Request, res: Response, next: NextFunction): void {
  res.status(404).json({
    success: false,
    message: 'Resource not found',
    path: req.originalUrl
  });
}

// Global error handler
export function errorHandler(
  err: Error | AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void {
  console.error('Error:', {
    message: err.message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined,
    path: req.path,
    method: req.method
  });

  // Multer errors
  if (err.message === 'File too large') {
    res.status(400).json({
      success: false,
      message: 'File too large. Maximum size is 5MB.'
    });
    return;
  }

  if (err.message.includes('Invalid file type')) {
    res.status(400).json({
      success: false,
      message: err.message
    });
    return;
  }

  // JWT errors
  if (err.name === 'JsonWebTokenError') {
    res.status(401).json({
      success: false,
      message: 'Invalid token'
    });
    return;
  }

  if (err.name === 'TokenExpiredError') {
    res.status(401).json({
      success: false,
      message: 'Token expired'
    });
    return;
  }

  // Postgres errors
  if ((err as any).code === '23505') {
    res.status(409).json({
      success: false,
      message: 'A record with this value already exists'
    });
    return;
  }

  if ((err as any).code === '23503') {
    res.status(400).json({
      success: false,
      message: 'Referenced record does not exist'
    });
    return;
  }

  // App errors
  if (err instanceof AppError) {
    res.status(err.statusCode).json({
      success: false,
      message: err.message
    });
    return;
  }

  // Default error
  res.status(500).json({
    success: false,
    message: process.env.NODE_ENV === 'production'
      ? 'An unexpected error occurred'
      : err.message
  });
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/middleware/index.ts
‚îÇ Language: TypeScript | Lines: 4 | Size: 85 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

export * from './auth';
export * from './rateLimiter';
export * from './validation';



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/middleware/rateLimiter.ts
‚îÇ Language: TypeScript | Lines: 151 | Size: 4.3 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import rateLimit from 'express-rate-limit';
import { Request, Response } from 'express';
import { getTrustLevel, getClaimAttemptLimit, getReportDailyLimit } from '../utils';
import { TrustLevel } from '../types';

// ============================================
// RATE LIMITING MIDDLEWARE
// ============================================

// Standard API rate limiter
export const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 100, // 100 requests per minute
  message: {
    success: false,
    message: 'Too many requests, please try again later'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Strict rate limiter for auth endpoints
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per 15 minutes
  message: {
    success: false,
    message: 'Too many login attempts, please try again later'
  },
  standardHeaders: true,
  legacyHeaders: false,
  skipSuccessfulRequests: true, // Don't count successful logins
});

// Report creation limiter (trust-based)
export const reportLimiter = rateLimit({
  windowMs: 24 * 60 * 60 * 1000, // 24 hours
  max: (req: Request): number => {
    if (req.user) {
      const trustLevel = getTrustLevel(req.user.trust_score || 0);
      return getReportDailyLimit(trustLevel);
    }
    return 3; // Default for unauthenticated
  },
  message: {
    success: false,
    message: 'Daily report limit reached. Try again tomorrow.'
  },
  keyGenerator: (req: Request): string => {
    return req.user?.userId?.toString() || req.ip || 'anonymous';
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Claim attempt limiter
export const claimLimiter = rateLimit({
  windowMs: 24 * 60 * 60 * 1000, // 24 hours
  max: (req: Request): number => {
    if (req.user) {
      const trustLevel = getTrustLevel(req.user.trust_score || 0);
      return getClaimAttemptLimit(trustLevel);
    }
    return 0; // Must be authenticated
  },
  message: {
    success: false,
    message: 'Daily claim limit reached. Try again tomorrow.'
  },
  keyGenerator: (req: Request): string => {
    return req.user?.userId?.toString() || req.ip || 'anonymous';
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Verification attempt limiter (per item)
export const verificationLimiter = rateLimit({
  windowMs: 24 * 60 * 60 * 1000, // 24 hours
  max: 3, // 3 attempts per item per day
  message: {
    success: false,
    message: 'Too many verification attempts for this item. Try again in 24 hours.'
  },
  keyGenerator: (req: Request): string => {
    const userId = req.user?.userId || 'anonymous';
    const claimId = req.params.claimId || 'unknown';
    return `verify:${userId}:${claimId}`;
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// OTP verification limiter
export const otpLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // 3 OTP attempts per hour
  message: {
    success: false,
    message: 'Too many OTP attempts. Please wait before trying again.'
  },
  keyGenerator: (req: Request): string => {
    const claimId = req.params.claimId || 'unknown';
    return `otp:${claimId}`;
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Message sending limiter
export const messageLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 50, // 50 messages per hour
  message: {
    success: false,
    message: 'Message rate limit reached. Please wait before sending more messages.'
  },
  keyGenerator: (req: Request): string => {
    return req.user?.userId?.toString() || req.ip || 'anonymous';
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Search limiter (to prevent scraping)
export const searchLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 30, // 30 searches per minute
  message: {
    success: false,
    message: 'Search rate limit reached. Please slow down.'
  },
  standardHeaders: true,
  legacyHeaders: false,
});

// Password reset limiter
export const passwordResetLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 3, // 3 reset requests per hour
  message: {
    success: false,
    message: 'Too many password reset requests. Please try again later.'
  },
  keyGenerator: (req: Request): string => {
    return req.body.email || req.ip || 'anonymous';
  },
  standardHeaders: true,
  legacyHeaders: false,
});



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/middleware/validation.ts
‚îÇ Language: TypeScript | Lines: 227 | Size: 8.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request, Response, NextFunction } from 'express';
import { z, ZodSchema, ZodError } from 'zod';
import { ItemCategory, UserRole } from '../types';

// ============================================
// VALIDATION MIDDLEWARE
// ============================================

// Generic validation middleware factory
export function validate(schema: ZodSchema, source: 'body' | 'query' | 'params' = 'body') {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      const data = req[source];
      schema.parse(data);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message
        }));

        res.status(400).json({
          success: false,
          message: 'Validation failed',
          errors
        });
        return;
      }

      res.status(400).json({
        success: false,
        message: 'Invalid request data'
      });
    }
  };
}

// ============================================
// AUTH SCHEMAS
// ============================================

export const registerSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number'),
  name: z.string().min(2, 'Name must be at least 2 characters').max(100),
  phone: z.string().regex(/^\+?250\d{9}$/, 'Invalid Rwandan phone number').optional(),
});

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(1, 'Password is required'),
});

export const refreshTokenSchema = z.object({
  refreshToken: z.string().min(1, 'Refresh token is required'),
});

export const forgotPasswordSchema = z.object({
  email: z.string().email('Invalid email address'),
});

export const resetPasswordSchema = z.object({
  token: z.string().min(1, 'Reset token is required'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number'),
});

// ============================================
// LOST ITEM SCHEMAS
// ============================================

const verificationQuestionSchema = z.object({
  question: z.string().min(5, 'Question must be at least 5 characters').max(255),
  answer: z.string().min(1, 'Answer is required').max(100),
});

export const createLostItemSchema = z.object({
  category: z.nativeEnum(ItemCategory),
  title: z.string().min(3, 'Title must be at least 3 characters').max(100),
  description: z.string().min(10, 'Description must be at least 10 characters').max(2000),
  location_area: z.string().min(2, 'Location area is required').max(100),
  location_hint: z.string().max(500).optional(),
  lost_date: z.string().datetime({ offset: true }).or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/)),
  photo_url: z.string().url().optional(),
  verification_questions: z.array(verificationQuestionSchema).length(3, 'Exactly 3 verification questions required'),
});

export const updateLostItemSchema = z.object({
  title: z.string().min(3).max(100).optional(),
  description: z.string().min(10).max(2000).optional(),
  location_area: z.string().min(2).max(100).optional(),
  location_hint: z.string().max(500).optional().nullable(),
  photo_url: z.string().url().optional().nullable(),
});

// ============================================
// FOUND ITEM SCHEMAS
// ============================================

export const createFoundItemSchema = z.object({
  category: z.nativeEnum(ItemCategory),
  title: z.string().min(3, 'Title must be at least 3 characters').max(100),
  description: z.string().min(10, 'Description must be at least 10 characters').max(2000),
  location_area: z.string().min(2, 'Location area is required').max(100),
  location_hint: z.string().max(500).optional(),
  found_date: z.string().datetime({ offset: true }).or(z.string().regex(/^\d{4}-\d{2}-\d{2}$/)),
  cooperative_id: z.number().int().positive().optional(),
});

export const updateFoundItemSchema = z.object({
  title: z.string().min(3).max(100).optional(),
  description: z.string().min(10).max(2000).optional(),
  location_area: z.string().min(2).max(100).optional(),
  location_hint: z.string().max(500).optional().nullable(),
});

// ============================================
// CLAIM SCHEMAS
// ============================================

export const createClaimSchema = z.object({
  lost_item_id: z.number().int().positive('Lost item ID is required'),
  found_item_id: z.number().int().positive('Found item ID is required'),
});

export const verifyClaimSchema = z.object({
  answers: z.array(z.string().min(1, 'Answer is required')).length(3, 'All 3 answers are required'),
});

export const disputeClaimSchema = z.object({
  reason: z.string().min(10, 'Dispute reason must be at least 10 characters').max(1000),
});

// ============================================
// HANDOVER SCHEMAS
// ============================================

export const verifyOtpSchema = z.object({
  otp: z.string().length(6, 'OTP must be 6 digits').regex(/^\d{6}$/, 'OTP must be 6 digits'),
});

// ============================================
// MESSAGE SCHEMAS
// ============================================

export const sendMessageSchema = z.object({
  content: z.string().min(1, 'Message cannot be empty').max(1000, 'Message too long'),
});

// ============================================
// SCAM REPORT SCHEMAS
// ============================================

export const scamReportSchema = z.object({
  reported_user_id: z.number().int().positive('Reported user ID is required'),
  message_id: z.number().int().positive().optional(),
  claim_id: z.number().int().positive().optional(),
  reason: z.string().min(10, 'Please provide a detailed reason').max(1000),
});

export const resolveScamReportSchema = z.object({
  resolution_notes: z.string().min(5, 'Resolution notes are required').max(1000),
  action: z.enum(['dismiss', 'warn', 'suspend', 'ban']),
});

// ============================================
// COOPERATIVE SCHEMAS
// ============================================

export const createCooperativeSchema = z.object({
  name: z.string().min(3, 'Name must be at least 3 characters').max(255),
  registration_number: z.string().min(5, 'Registration number is required').max(100),
  contact_info: z.string().min(5, 'Contact information is required'),
  address: z.string().max(500).optional(),
});

export const approveCooperativeSchema = z.object({
  status: z.enum(['VERIFIED', 'SUSPENDED']),
});

// ============================================
// ADMIN SCHEMAS
// ============================================

export const banUserSchema = z.object({
  reason: z.string().min(5, 'Ban reason is required').max(500),
});

export const createCoopStaffSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
  name: z.string().min(2, 'Name must be at least 2 characters').max(100),
  phone: z.string().regex(/^\+?250\d{9}$/, 'Invalid Rwandan phone number').optional(),
  cooperative_id: z.number().int().positive('Cooperative ID is required'),
});

// ============================================
// SEARCH/FILTER SCHEMAS
// ============================================

export const searchParamsSchema = z.object({
  category: z.nativeEnum(ItemCategory).optional(),
  location_area: z.string().optional(),
  date_from: z.string().optional(),
  date_to: z.string().optional(),
  keyword: z.string().optional(),
  status: z.string().optional(),
  page: z.string().regex(/^\d+$/).transform(Number).optional(),
  limit: z.string().regex(/^\d+$/).transform(Number).optional(),
});

// ============================================
// ID PARAM SCHEMA
// ============================================

export const idParamSchema = z.object({
  id: z.string().regex(/^\d+$/, 'Invalid ID').transform(Number),
});



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/migrations/001_initial.ts
‚îÇ Language: TypeScript | Lines: 481 | Size: 20.5 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query } from '../config/database';

// ============================================
// BYABONEKA+ DATABASE MIGRATIONS
// Trust-Aware Lost & Found Infrastructure
// ============================================

export async function runMigrations(): Promise<void> {
  console.log('üöÄ Running database migrations...');

  // ==========================================
  // EXTENSIONS
  // ==========================================
  await query(`CREATE EXTENSION IF NOT EXISTS "uuid-ossp";`);
  await query(`CREATE EXTENSION IF NOT EXISTS "pg_trgm";`);

  // ==========================================
  // ENUM TYPES (safe to re-run)
  // ==========================================
  await query(`DO $$ BEGIN CREATE TYPE user_role AS ENUM ('citizen', 'coop_staff', 'admin'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE item_category AS ENUM ('PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE lost_item_status AS ENUM ('ACTIVE', 'CLAIMED', 'RETURNED', 'EXPIRED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE found_item_status AS ENUM ('UNCLAIMED', 'MATCHED', 'RETURNED', 'EXPIRED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE item_source AS ENUM ('CITIZEN', 'COOPERATIVE'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE claim_status AS ENUM ('PENDING', 'VERIFIED', 'REJECTED', 'RETURNED', 'DISPUTED', 'CANCELLED', 'EXPIRED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE verification_attempt_status AS ENUM ('PASSED', 'FAILED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE cooperative_status AS ENUM ('PENDING', 'VERIFIED', 'SUSPENDED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE scam_report_status AS ENUM ('OPEN', 'INVESTIGATING', 'RESOLVED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);
  await query(`DO $$ BEGIN CREATE TYPE dispute_status AS ENUM ('OPEN', 'UNDER_REVIEW', 'RESOLVED_OWNER', 'RESOLVED_FINDER', 'DISMISSED'); EXCEPTION WHEN duplicate_object THEN null; END $$;`);

  // ==========================================
  // COOPERATIVES TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS cooperatives (
      id SERIAL PRIMARY KEY,
      name VARCHAR(255) NOT NULL UNIQUE,
      registration_number VARCHAR(100) NOT NULL UNIQUE,
      status cooperative_status NOT NULL DEFAULT 'PENDING',
      contact_info TEXT NOT NULL,
      address TEXT,
      verified_at TIMESTAMP,
      verified_by INTEGER,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);

  // ==========================================
  // USERS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      email VARCHAR(255) NOT NULL UNIQUE,
      phone VARCHAR(20) UNIQUE,
      password_hash VARCHAR(255) NOT NULL,
      name VARCHAR(100) NOT NULL,
      role user_role NOT NULL DEFAULT 'citizen',
      trust_score INTEGER NOT NULL DEFAULT 0,
      cooperative_id INTEGER REFERENCES cooperatives(id),
      email_verified BOOLEAN NOT NULL DEFAULT FALSE,
      phone_verified BOOLEAN NOT NULL DEFAULT FALSE,
      is_banned BOOLEAN NOT NULL DEFAULT FALSE,
      banned_at TIMESTAMP,
      ban_reason TEXT,
      failed_login_attempts INTEGER NOT NULL DEFAULT 0,
      locked_until TIMESTAMP,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_users_role ON users(role)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_users_cooperative ON users(cooperative_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_users_trust_score ON users(trust_score)`);

  // Cooperatives FK to users
  await query(`
    DO $$ BEGIN
      ALTER TABLE cooperatives ADD CONSTRAINT fk_cooperatives_verified_by
        FOREIGN KEY (verified_by) REFERENCES users(id);
    EXCEPTION
      WHEN duplicate_object THEN null;
    END $$
  `);

  // ==========================================
  // LOST ITEMS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS lost_items (
      id SERIAL PRIMARY KEY,
      user_id INTEGER NOT NULL REFERENCES users(id),
      category item_category NOT NULL,
      title VARCHAR(100) NOT NULL,
      description TEXT NOT NULL,
      location_area VARCHAR(100) NOT NULL,
      location_hint TEXT,
      lost_date TIMESTAMP NOT NULL,
      status lost_item_status NOT NULL DEFAULT 'ACTIVE',
      keywords TEXT[] DEFAULT '{}',
      photo_url TEXT,
      expiry_warning_sent BOOLEAN NOT NULL DEFAULT FALSE,
      expired_at TIMESTAMP,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_lost_items_user ON lost_items(user_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_lost_items_category_status ON lost_items(category, status)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_lost_items_location ON lost_items(location_area)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_lost_items_lost_date ON lost_items(lost_date)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_lost_items_created ON lost_items(created_at)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_lost_items_keywords ON lost_items USING GIN(keywords)`);

  // ==========================================
  // FOUND ITEMS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS found_items (
      id SERIAL PRIMARY KEY,
      finder_id INTEGER NOT NULL REFERENCES users(id),
      cooperative_id INTEGER REFERENCES cooperatives(id),
      category item_category NOT NULL,
      title VARCHAR(100) NOT NULL,
      description TEXT NOT NULL,
      location_area VARCHAR(100) NOT NULL,
      location_hint TEXT,
      found_date TIMESTAMP NOT NULL,
      status found_item_status NOT NULL DEFAULT 'UNCLAIMED',
      source item_source NOT NULL DEFAULT 'CITIZEN',
      image_urls TEXT[] NOT NULL DEFAULT '{}',
      keywords TEXT[] DEFAULT '{}',
      expiry_warning_sent BOOLEAN NOT NULL DEFAULT FALSE,
      expired_at TIMESTAMP,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_finder ON found_items(finder_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_cooperative ON found_items(cooperative_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_category_status ON found_items(category, status)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_location ON found_items(location_area)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_found_date ON found_items(found_date)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_created ON found_items(created_at)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_found_items_keywords ON found_items USING GIN(keywords)`);

  // ==========================================
  // VERIFICATION SECRETS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS verification_secrets (
      id SERIAL PRIMARY KEY,
      lost_item_id INTEGER NOT NULL REFERENCES lost_items(id) ON DELETE CASCADE,
      question_1_text VARCHAR(255) NOT NULL,
      answer_1_hash VARCHAR(255) NOT NULL,
      answer_1_salt VARCHAR(64) NOT NULL,
      question_2_text VARCHAR(255) NOT NULL,
      answer_2_hash VARCHAR(255) NOT NULL,
      answer_2_salt VARCHAR(64) NOT NULL,
      question_3_text VARCHAR(255) NOT NULL,
      answer_3_hash VARCHAR(255) NOT NULL,
      answer_3_salt VARCHAR(64) NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
      UNIQUE(lost_item_id)
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_verification_secrets_lost_item ON verification_secrets(lost_item_id)`);

  // ==========================================
  // CLAIMS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS claims (
      id SERIAL PRIMARY KEY,
      lost_item_id INTEGER NOT NULL REFERENCES lost_items(id),
      found_item_id INTEGER NOT NULL REFERENCES found_items(id),
      claimant_id INTEGER NOT NULL REFERENCES users(id),
      status claim_status NOT NULL DEFAULT 'PENDING',
      verification_score DECIMAL(3,2) NOT NULL DEFAULT 0,
      attempts_made INTEGER NOT NULL DEFAULT 0,
      consecutive_failures INTEGER NOT NULL DEFAULT 0,
      next_attempt_at TIMESTAMP,
      last_attempt_at TIMESTAMP,
      dispute_reason TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_claims_claimant ON claims(claimant_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_claims_status ON claims(status)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_claims_lost_item ON claims(lost_item_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_claims_found_item ON claims(found_item_id)`);
  await query(`CREATE UNIQUE INDEX IF NOT EXISTS idx_claims_unique_active ON claims(lost_item_id, found_item_id, claimant_id) WHERE status NOT IN ('CANCELLED', 'REJECTED', 'EXPIRED')`);

  // ==========================================
  // VERIFICATION ATTEMPTS TABLE
  // Drop and recreate to guarantee correct schema
  // ==========================================
  await query(`DROP TABLE IF EXISTS verification_attempts CASCADE`);
  await query(`
    CREATE TABLE verification_attempts (
      id SERIAL PRIMARY KEY,
      claim_id INTEGER NOT NULL REFERENCES claims(id) ON DELETE CASCADE,
      user_id INTEGER REFERENCES users(id),
      correct_answers INTEGER NOT NULL DEFAULT 0,
      attempt_status verification_attempt_status NOT NULL,
      attempt_at TIMESTAMP NOT NULL DEFAULT NOW(),
      ip_address INET
    )
  `);

  // Debug: verify the table was created correctly
  const colCheck = await query(`
    SELECT column_name FROM information_schema.columns 
    WHERE table_name = 'verification_attempts' 
    ORDER BY ordinal_position
  `);
  console.log('  verification_attempts columns:', colCheck.rows.map((r: any) => r.column_name).join(', '));

  await query(`CREATE INDEX IF NOT EXISTS idx_verification_attempts_claim ON verification_attempts(claim_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_verification_attempts_date ON verification_attempts(attempt_at)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_verification_attempts_user ON verification_attempts(user_id)`);

  // ==========================================
  // HANDOVER CONFIRMATIONS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS handover_confirmations (
      id SERIAL PRIMARY KEY,
      claim_id INTEGER NOT NULL REFERENCES claims(id) ON DELETE CASCADE,
      otp_code_hash VARCHAR(255) NOT NULL,
      otp_expires_at TIMESTAMP NOT NULL,
      otp_verified BOOLEAN NOT NULL DEFAULT FALSE,
      verification_attempts INTEGER NOT NULL DEFAULT 0,
      max_attempts INTEGER NOT NULL DEFAULT 3,
      generated_by INTEGER REFERENCES users(id),
      returned_at TIMESTAMP,
      return_confirmed_by INTEGER REFERENCES users(id),
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
      UNIQUE(claim_id)
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_handover_claim ON handover_confirmations(claim_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_handover_expires ON handover_confirmations(otp_expires_at)`);

  // ==========================================
  // MESSAGES TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS messages (
      id SERIAL PRIMARY KEY,
      sender_id INTEGER NOT NULL REFERENCES users(id),
      receiver_id INTEGER NOT NULL REFERENCES users(id),
      claim_id INTEGER NOT NULL REFERENCES claims(id) ON DELETE CASCADE,
      content TEXT NOT NULL,
      is_read BOOLEAN NOT NULL DEFAULT FALSE,
      is_flagged BOOLEAN NOT NULL DEFAULT FALSE,
      flag_reason TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_messages_claim ON messages(claim_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_messages_sender ON messages(sender_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_messages_receiver ON messages(receiver_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_messages_created ON messages(created_at)`);

  // ==========================================
  // SCAM REPORTS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS scam_reports (
      id SERIAL PRIMARY KEY,
      reporter_id INTEGER NOT NULL REFERENCES users(id),
      message_id INTEGER REFERENCES messages(id),
      reported_user_id INTEGER NOT NULL REFERENCES users(id),
      claim_id INTEGER REFERENCES claims(id),
      reason TEXT NOT NULL,
      status scam_report_status NOT NULL DEFAULT 'OPEN',
      resolved_at TIMESTAMP,
      resolved_by INTEGER REFERENCES users(id),
      resolution_notes TEXT,
      created_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_scam_reports_reporter ON scam_reports(reporter_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_scam_reports_reported ON scam_reports(reported_user_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_scam_reports_status ON scam_reports(status)`);

  // ==========================================
  // CLAIM DISPUTES TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS claim_disputes (
      id SERIAL PRIMARY KEY,
      claim_id INTEGER NOT NULL REFERENCES claims(id) ON DELETE CASCADE,
      initiated_by INTEGER NOT NULL REFERENCES users(id),
      reason TEXT NOT NULL,
      evidence_urls TEXT[] DEFAULT '{}',
      status dispute_status NOT NULL DEFAULT 'OPEN',
      admin_notes TEXT,
      resolved_by INTEGER REFERENCES users(id),
      resolved_at TIMESTAMP,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      updated_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_claim_disputes_claim ON claim_disputes(claim_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_claim_disputes_status ON claim_disputes(status)`);

  // ==========================================
  // EMAIL VERIFICATION TOKENS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS email_verification_tokens (
      id SERIAL PRIMARY KEY,
      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      token_hash VARCHAR(255) NOT NULL,
      expires_at TIMESTAMP NOT NULL,
      used_at TIMESTAMP,
      created_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_email_verification_user ON email_verification_tokens(user_id)`);

  // ==========================================
  // AUDIT LOGS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS audit_logs (
      id BIGSERIAL PRIMARY KEY,
      actor_id INTEGER REFERENCES users(id),
      action VARCHAR(50) NOT NULL,
      resource_type VARCHAR(50) NOT NULL,
      resource_id INTEGER,
      changes JSONB,
      ip_address INET,
      user_agent TEXT,
      timestamp TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_audit_logs_actor ON audit_logs(actor_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_audit_logs_resource ON audit_logs(resource_type, resource_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp DESC)`);

  // ==========================================
  // MATCHES TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS matches (
      id SERIAL PRIMARY KEY,
      lost_item_id INTEGER NOT NULL REFERENCES lost_items(id) ON DELETE CASCADE,
      found_item_id INTEGER NOT NULL REFERENCES found_items(id) ON DELETE CASCADE,
      score INTEGER NOT NULL,
      explanation TEXT[] NOT NULL,
      computed_at TIMESTAMP NOT NULL DEFAULT NOW(),
      UNIQUE(lost_item_id, found_item_id)
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_matches_lost ON matches(lost_item_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_matches_found ON matches(found_item_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_matches_score ON matches(score DESC)`);

  // ==========================================
  // REFRESH TOKENS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS refresh_tokens (
      id SERIAL PRIMARY KEY,
      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      token_hash VARCHAR(255) NOT NULL,
      expires_at TIMESTAMP NOT NULL,
      created_at TIMESTAMP NOT NULL DEFAULT NOW(),
      revoked_at TIMESTAMP
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user ON refresh_tokens(user_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_refresh_tokens_hash ON refresh_tokens(token_hash)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON refresh_tokens(expires_at)`);

  // ==========================================
  // PASSWORD RESET TOKENS TABLE
  // ==========================================
  await query(`
    CREATE TABLE IF NOT EXISTS password_reset_tokens (
      id SERIAL PRIMARY KEY,
      user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
      token_hash VARCHAR(255) NOT NULL,
      expires_at TIMESTAMP NOT NULL,
      used_at TIMESTAMP,
      created_at TIMESTAMP NOT NULL DEFAULT NOW()
    )
  `);
  await query(`CREATE INDEX IF NOT EXISTS idx_password_reset_user ON password_reset_tokens(user_id)`);
  await query(`CREATE INDEX IF NOT EXISTS idx_password_reset_hash ON password_reset_tokens(token_hash)`);

  // ==========================================
  // UPDATED_AT TRIGGER FUNCTION
  // ==========================================
  await query(`
    CREATE OR REPLACE FUNCTION update_updated_at_column()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ language 'plpgsql'
  `);

  // Apply updated_at triggers
  const tablesWithUpdatedAt = [
    'users', 'cooperatives', 'lost_items', 'found_items',
    'verification_secrets', 'claims', 'handover_confirmations', 'claim_disputes'
  ];

  for (const table of tablesWithUpdatedAt) {
    await query(`DROP TRIGGER IF EXISTS update_${table}_updated_at ON ${table}`);
    await query(`
      CREATE TRIGGER update_${table}_updated_at
        BEFORE UPDATE ON ${table}
        FOR EACH ROW
        EXECUTE FUNCTION update_updated_at_column()
    `);
  }

  console.log('‚úÖ Database migrations completed successfully');
}

export async function rollbackMigrations(): Promise<void> {
  console.log('üîÑ Rolling back migrations...');
  
  const tables = [
    'password_reset_tokens',
    'refresh_tokens',
    'matches',
    'audit_logs',
    'email_verification_tokens',
    'claim_disputes',
    'scam_reports',
    'messages',
    'handover_confirmations',
    'verification_attempts',
    'claims',
    'verification_secrets',
    'found_items',
    'lost_items',
    'users',
    'cooperatives'
  ];

  for (const table of tables) {
    await query(`DROP TABLE IF EXISTS ${table} CASCADE`);
  }

  await query(`DROP TYPE IF EXISTS user_role CASCADE`);
  await query(`DROP TYPE IF EXISTS item_category CASCADE`);
  await query(`DROP TYPE IF EXISTS lost_item_status CASCADE`);
  await query(`DROP TYPE IF EXISTS found_item_status CASCADE`);
  await query(`DROP TYPE IF EXISTS item_source CASCADE`);
  await query(`DROP TYPE IF EXISTS claim_status CASCADE`);
  await query(`DROP TYPE IF EXISTS verification_attempt_status CASCADE`);
  await query(`DROP TYPE IF EXISTS cooperative_status CASCADE`);
  await query(`DROP TYPE IF EXISTS scam_report_status CASCADE`);
  await query(`DROP TYPE IF EXISTS dispute_status CASCADE`);

  console.log('‚úÖ Migrations rolled back successfully');
}

// Run migrations if executed directly
if (require.main === module) {
  runMigrations()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error('Migration failed:', error);
      process.exit(1);
    });
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/migrations/rollback.ts
‚îÇ Language: TypeScript | Lines: 20 | Size: 398 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import dotenv from 'dotenv';
dotenv.config();

import { rollbackMigrations } from './001_initial';
import { closePool } from '../config/database';

async function main() {
  try {
    await rollbackMigrations();
    console.log('‚úÖ Rollback completed');
  } catch (error) {
    console.error('‚ùå Rollback failed:', error);
    process.exit(1);
  } finally {
    await closePool();
  }
}

main();



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/migrations/run.ts
‚îÇ Language: TypeScript | Lines: 20 | Size: 395 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import dotenv from 'dotenv';
dotenv.config();

import { runMigrations } from './001_initial';
import { closePool } from '../config/database';

async function main() {
  try {
    await runMigrations();
    console.log('‚úÖ All migrations completed');
  } catch (error) {
    console.error('‚ùå Migration failed:', error);
    process.exit(1);
  } finally {
    await closePool();
  }
}

main();



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/routes/enhancedRoutes.ts
‚îÇ Language: TypeScript | Lines: 547 | Size: 14.4 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Enhanced Routes for Byaboneka+
 * 
 * Adds new endpoints for:
 * - Dispute workflow (CLAIM-07)
 * - Enhanced OTP verification (HAND-01 to HAND-07)
 * - Email verification (AUTH-01)
 * - CAPTCHA integration (SYS-04)
 * - Duplicate detection responses (SYS-05)
 */

import { Router } from 'express';
import { authenticate, adminOnly } from '../middleware/auth';
import { validate } from '../middleware/validation';
import { verificationLimiter, otpLimiter } from '../middleware/rateLimiter';
import { requireVerifiedEmail } from '../middleware/emailVerification';
import { z } from 'zod';

// Import new services
import * as otpService from '../services/otpService';
import * as disputeService from '../services/disputeService';
import * as emailVerificationService from '../services/emailVerificationService';
import * as verificationCooldownService from '../services/verificationCooldownService';
import { checkDuplicateLostItems, checkDuplicateFoundItems } from '../services/duplicateDetectionService';

const enhancedRouter = Router();

// ============================================
// VALIDATION SCHEMAS
// ============================================

const disputeSchema = z.object({
  reason: z.string().min(20, 'Please provide a detailed reason (at least 20 characters)').max(2000),
  evidence_urls: z.array(z.string().url()).max(5).optional()
});

const resolveDisputeSchema = z.object({
  resolution: z.enum(['RESOLVED_OWNER', 'RESOLVED_FINDER', 'DISMISSED']),
  resolution_notes: z.string().min(10).max(2000)
});

const verifyEmailSchema = z.object({
  token: z.string().min(64).max(64)
});

// ============================================
// OTP / HANDOVER ENDPOINTS (Enhanced)
// ============================================

/**
 * Generate handover OTP (owner only)
 * POST /claims/:claimId/handover/otp
 */
enhancedRouter.post('/claims/:claimId/handover/otp',
  authenticate,
  requireVerifiedEmail, // Require verified email for OTP generation
  async (req, res) => {
    try {
      const { claimId } = req.params;
      const userId = req.user!.userId;
      
      const result = await otpService.generateHandoverOTP(
        parseInt(claimId),
        userId,
        req
      );
      
      if (!result.success) {
        res.status(400).json({ success: false, message: result.message });
        return;
      }
      
      res.json({
        success: true,
        data: {
          otp: result.otp, // Only shown to owner
          expires_at: result.expiresAt,
          validity_hours: 24
        },
        message: result.message
      });
    } catch (error) {
      console.error('Generate OTP error:', error);
      res.status(500).json({ success: false, message: 'Failed to generate handover code' });
    }
  }
);

/**
 * Verify handover OTP (finder or coop staff only)
 * POST /claims/:claimId/handover/verify
 */
enhancedRouter.post('/claims/:claimId/handover/verify',
  authenticate,
  otpLimiter,
  validate(z.object({ otp: z.string().length(6).regex(/^\d{6}$/) })),
  async (req, res) => {
    try {
      const { claimId } = req.params;
      const { otp } = req.body;
      const userId = req.user!.userId;
      
      const result = await otpService.verifyHandoverOTP(
        parseInt(claimId),
        otp,
        userId,
        req
      );
      
      if (!result.success) {
        res.status(400).json({
          success: false,
          message: result.message,
          attempts_remaining: result.attemptsRemaining
        });
        return;
      }
      
      res.json({
        success: true,
        message: result.message,
        handover_completed: result.handoverCompleted
      });
    } catch (error) {
      console.error('Verify OTP error:', error);
      res.status(500).json({ success: false, message: 'Failed to verify handover code' });
    }
  }
);

/**
 * Get handover status
 * GET /claims/:claimId/handover
 */
enhancedRouter.get('/claims/:claimId/handover',
  authenticate,
  async (req, res) => {
    try {
      const { claimId } = req.params;
      const status = await otpService.getHandoverStatus(parseInt(claimId));
      
      if (!status) {
        res.json({
          success: true,
          data: {
            has_otp: false,
            message: 'No handover code generated yet'
          }
        });
        return;
      }
      
      res.json({
        success: true,
        data: {
          has_otp: true,
          otp_verified: status.otpVerified,
          expires_at: status.otpExpiresAt,
          attempts_used: status.verificationAttempts,
          is_expired: new Date(status.otpExpiresAt) < new Date()
        }
      });
    } catch (error) {
      console.error('Get handover status error:', error);
      res.status(500).json({ success: false, message: 'Failed to get handover status' });
    }
  }
);

// ============================================
// DISPUTE ENDPOINTS
// ============================================

/**
 * Open a dispute for a claim
 * POST /claims/:claimId/dispute
 */
enhancedRouter.post('/claims/:claimId/dispute',
  authenticate,
  validate(disputeSchema),
  async (req, res) => {
    try {
      const { claimId } = req.params;
      const { reason, evidence_urls } = req.body;
      const userId = req.user!.userId;
      
      const result = await disputeService.openDispute(
        parseInt(claimId),
        userId,
        reason,
        evidence_urls || [],
        req
      );
      
      if (!result.success) {
        res.status(400).json({ success: false, message: result.message });
        return;
      }
      
      res.status(201).json({
        success: true,
        data: result.dispute,
        message: result.message
      });
    } catch (error) {
      console.error('Open dispute error:', error);
      res.status(500).json({ success: false, message: 'Failed to open dispute' });
    }
  }
);

/**
 * Get dispute for a claim
 * GET /claims/:claimId/dispute
 */
enhancedRouter.get('/claims/:claimId/dispute',
  authenticate,
  async (req, res) => {
    try {
      const { claimId } = req.params;
      const dispute = await disputeService.getDisputeByClaimId(parseInt(claimId));
      
      if (!dispute) {
        res.status(404).json({ success: false, message: 'No dispute found for this claim' });
        return;
      }
      
      res.json({ success: true, data: dispute });
    } catch (error) {
      console.error('Get dispute error:', error);
      res.status(500).json({ success: false, message: 'Failed to get dispute' });
    }
  }
);

/**
 * Add evidence to a dispute
 * POST /disputes/:disputeId/evidence
 */
enhancedRouter.post('/disputes/:disputeId/evidence',
  authenticate,
  validate(z.object({ evidence_urls: z.array(z.string().url()).min(1).max(5) })),
  async (req, res) => {
    try {
      const { disputeId } = req.params;
      const { evidence_urls } = req.body;
      const userId = req.user!.userId;
      
      const result = await disputeService.addDisputeEvidence(
        parseInt(disputeId),
        userId,
        evidence_urls
      );
      
      if (!result.success) {
        res.status(400).json({ success: false, message: result.message });
        return;
      }
      
      res.json({ success: true, message: result.message });
    } catch (error) {
      console.error('Add evidence error:', error);
      res.status(500).json({ success: false, message: 'Failed to add evidence' });
    }
  }
);

/**
 * Admin: Get all disputes
 * GET /admin/disputes
 */
enhancedRouter.get('/admin/disputes',
  authenticate,
  adminOnly,
  async (req, res) => {
    try {
      const { status, page, limit } = req.query;
      
      const result = await disputeService.getDisputesForReview(
        status as any,
        parseInt(page as string) || 1,
        parseInt(limit as string) || 20
      );
      
      res.json({
        success: true,
        data: result.disputes,
        pagination: {
          total: result.total,
          page: parseInt(page as string) || 1,
          limit: parseInt(limit as string) || 20
        }
      });
    } catch (error) {
      console.error('Get disputes error:', error);
      res.status(500).json({ success: false, message: 'Failed to get disputes' });
    }
  }
);

/**
 * Admin: Resolve a dispute
 * POST /admin/disputes/:disputeId/resolve
 */
enhancedRouter.post('/admin/disputes/:disputeId/resolve',
  authenticate,
  adminOnly,
  validate(resolveDisputeSchema),
  async (req, res) => {
    try {
      const { disputeId } = req.params;
      const { resolution, resolution_notes } = req.body;
      const adminId = req.user!.userId;
      
      const result = await disputeService.resolveDispute(
        parseInt(disputeId),
        adminId,
        resolution,
        resolution_notes,
        req
      );
      
      if (!result.success) {
        res.status(400).json({ success: false, message: result.message });
        return;
      }
      
      res.json({
        success: true,
        message: result.message,
        trust_adjustments: result.trustAdjustments
      });
    } catch (error) {
      console.error('Resolve dispute error:', error);
      res.status(500).json({ success: false, message: 'Failed to resolve dispute' });
    }
  }
);

// ============================================
// VERIFICATION COOLDOWN ENDPOINTS
// ============================================

/**
 * Check verification cooldown status
 * GET /claims/:claimId/verification/status
 */
enhancedRouter.get('/claims/:claimId/verification/status',
  authenticate,
  async (req, res) => {
    try {
      const { claimId } = req.params;
      const userId = req.user!.userId;
      
      const status = await verificationCooldownService.checkCooldownStatus(
        parseInt(claimId),
        userId
      );
      
      res.json({
        success: true,
        data: status
      });
    } catch (error) {
      console.error('Check cooldown error:', error);
      res.status(500).json({ success: false, message: 'Failed to check verification status' });
    }
  }
);

// ============================================
// EMAIL VERIFICATION ENDPOINTS
// ============================================

/**
 * Request email verification
 * POST /auth/email/verify/request
 */
enhancedRouter.post('/auth/email/verify/request',
  authenticate,
  async (req, res) => {
    try {
      const userId = req.user!.userId;
      
      const result = await emailVerificationService.generateEmailVerificationToken(userId, req);
      
      if (!result.success) {
        res.status(400).json({ success: false, message: result.message });
        return;
      }
      
      res.json({
        success: true,
        message: result.message,
        // In development, return token for testing
        ...(process.env.NODE_ENV === 'development' && { token: result.token })
      });
    } catch (error) {
      console.error('Request email verification error:', error);
      res.status(500).json({ success: false, message: 'Failed to send verification email' });
    }
  }
);

/**
 * Verify email with token
 * POST /auth/email/verify
 */
enhancedRouter.post('/auth/email/verify',
  authenticate,
  validate(verifyEmailSchema),
  async (req, res) => {
    try {
      const userId = req.user!.userId;
      const { token } = req.body;
      
      const result = await emailVerificationService.verifyEmail(userId, token, req);
      
      if (!result.success) {
        res.status(400).json({ success: false, message: result.message });
        return;
      }
      
      res.json({
        success: true,
        message: result.message,
        verified: result.verified
      });
    } catch (error) {
      console.error('Verify email error:', error);
      res.status(500).json({ success: false, message: 'Failed to verify email' });
    }
  }
);

/**
 * Check email verification status
 * GET /auth/email/status
 */
enhancedRouter.get('/auth/email/status',
  authenticate,
  async (req, res) => {
    try {
      const userId = req.user!.userId;
      const isVerified = await emailVerificationService.isEmailVerified(userId);
      
      res.json({
        success: true,
        data: { email_verified: isVerified }
      });
    } catch (error) {
      console.error('Check email status error:', error);
      res.status(500).json({ success: false, message: 'Failed to check email status' });
    }
  }
);

// ============================================
// DUPLICATE DETECTION ENDPOINTS
// ============================================

/**
 * Check for duplicate lost item before creation
 * POST /lost-items/check-duplicate
 */
enhancedRouter.post('/lost-items/check-duplicate',
  authenticate,
  validate(z.object({
    category: z.string(),
    title: z.string(),
    description: z.string(),
    location_area: z.string(),
    lost_date: z.string()
  })),
  async (req, res) => {
    try {
      const userId = req.user!.userId;
      const { category, title, description, location_area, lost_date } = req.body;
      
      const result = await checkDuplicateLostItems(
        userId,
        category as any,
        title,
        description,
        location_area,
        new Date(lost_date)
      );
      
      res.json({
        success: true,
        data: {
          has_potential_duplicates: result.hasPotentialDuplicates,
          candidates: result.candidates,
          highest_score: result.highestScore
        }
      });
    } catch (error) {
      console.error('Check duplicate error:', error);
      res.status(500).json({ success: false, message: 'Failed to check for duplicates' });
    }
  }
);

/**
 * Check for duplicate found item before creation
 * POST /found-items/check-duplicate
 */
enhancedRouter.post('/found-items/check-duplicate',
  authenticate,
  validate(z.object({
    category: z.string(),
    title: z.string(),
    description: z.string(),
    location_area: z.string(),
    found_date: z.string()
  })),
  async (req, res) => {
    try {
      const userId = req.user!.userId;
      const { category, title, description, location_area, found_date } = req.body;
      
      const result = await checkDuplicateFoundItems(
        userId,
        category as any,
        title,
        description,
        location_area,
        new Date(found_date)
      );
      
      res.json({
        success: true,
        data: {
          has_potential_duplicates: result.hasPotentialDuplicates,
          candidates: result.candidates,
          highest_score: result.highestScore
        }
      });
    } catch (error) {
      console.error('Check duplicate error:', error);
      res.status(500).json({ success: false, message: 'Failed to check for duplicates' });
    }
  }
);

export default enhancedRouter;



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/routes/index.ts
‚îÇ Language: TypeScript | Lines: 405 | Size: 9.2 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Router } from 'express';
import multer from 'multer';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';

// Controllers
import * as authController from '../controllers/authController';
import * as lostItemsController from '../controllers/lostItemsController';
import * as foundItemsController from '../controllers/foundItemsController';
import * as claimsController from '../controllers/claimsController';
import * as messagesController from '../controllers/messagesController';
import * as adminController from '../controllers/adminController';
import * as cooperativesController from '../controllers/cooperativesController';

// Middleware
import { authenticate, optionalAuth, adminOnly, authorize, adminOrCoopStaff } from '../middleware/auth';
import { validate, registerSchema, loginSchema, refreshTokenSchema, forgotPasswordSchema, resetPasswordSchema,
         createLostItemSchema, updateLostItemSchema, createFoundItemSchema, updateFoundItemSchema,
         createClaimSchema, verifyClaimSchema, verifyOtpSchema, sendMessageSchema } from '../middleware/validation';
import { authLimiter, reportLimiter, claimLimiter, verificationLimiter, otpLimiter, messageLimiter, 
         passwordResetLimiter, searchLimiter } from '../middleware/rateLimiter';
import { UserRole } from '../types';
import { checkConnection } from '../config/database';
import { fraudCheck } from '../services/fraudDetectionService';

const router = Router();

// ============================================
// FILE UPLOAD CONFIGURATION
// ============================================

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, process.env.UPLOAD_PATH || './uploads');
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    cb(null, `${uuidv4()}${ext}`);
  }
});

const fileFilter = (req: any, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, and WebP are allowed.'));
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB
});

// ============================================
// AUTH ROUTES
// ============================================

router.post('/auth/register',
  authLimiter,
  validate(registerSchema),
  authController.register
);

router.post('/auth/login',
  authLimiter,
  validate(loginSchema),
  authController.login
);

router.post('/auth/refresh',
  validate(refreshTokenSchema),
  authController.refreshToken
);

router.post('/auth/logout',
  authenticate,
  authController.logout
);

router.post('/auth/forgot-password',
  passwordResetLimiter,
  validate(forgotPasswordSchema),
  authController.forgotPassword
);

router.post('/auth/reset-password',
  validate(resetPasswordSchema),
  authController.resetPassword
);

router.get('/auth/profile',
  authenticate,
  authController.getProfile
);

router.put('/auth/profile',
  authenticate,
  authController.updateProfile
);

router.post('/auth/change-password',
  authenticate,
  authController.changePassword
);

// ============================================
// LOST ITEMS ROUTES
// ============================================

router.post('/lost-items',
  authenticate,
  reportLimiter,
  fraudCheck('REPORT_CREATE'),
  validate(createLostItemSchema),
  lostItemsController.createLostItem
);

router.get('/lost-items',
  optionalAuth,
  searchLimiter,
  lostItemsController.getLostItems
);

router.get('/lost-items/:id',
  optionalAuth,
  lostItemsController.getLostItem
);

router.put('/lost-items/:id',
  authenticate,
  validate(updateLostItemSchema),
  lostItemsController.updateLostItem
);

router.delete('/lost-items/:id',
  authenticate,
  lostItemsController.deleteLostItem
);

router.get('/lost-items/:id/matches',
  authenticate,
  lostItemsController.getLostItemMatches
);

router.get('/users/me/lost-items',
  authenticate,
  lostItemsController.getMyLostItems
);

// ============================================
// FOUND ITEMS ROUTES
// ============================================

router.post('/found-items',
  authenticate,
  reportLimiter,
  fraudCheck('REPORT_CREATE'),
  validate(createFoundItemSchema),
  foundItemsController.createFoundItem
);

router.get('/found-items',
  optionalAuth,
  searchLimiter,
  foundItemsController.getFoundItems
);

router.get('/found-items/:id',
  optionalAuth,
  foundItemsController.getFoundItem
);

router.put('/found-items/:id',
  authenticate,
  validate(updateFoundItemSchema),
  foundItemsController.updateFoundItem
);

router.delete('/found-items/:id',
  authenticate,
  foundItemsController.deleteFoundItem
);

router.post('/found-items/:id/images',
  authenticate,
  upload.array('images', 5),
  foundItemsController.uploadFoundItemImages
);

router.get('/found-items/:id/matches',
  authenticate,
  foundItemsController.getFoundItemMatches
);

router.get('/users/me/found-items',
  authenticate,
  foundItemsController.getMyFoundItems
);

// ============================================
// CLAIMS ROUTES
// ============================================

router.post('/claims',
  authenticate,
  claimLimiter,
  fraudCheck('CLAIM_CREATE'),
  validate(createClaimSchema),
  claimsController.createClaim
);

router.get('/claims/:claimId',
  authenticate,
  claimsController.getClaim
);

router.get('/claims/:claimId/questions',
  authenticate,
  verificationLimiter,
  claimsController.getVerificationQuestions
);

router.post('/claims/:claimId/verify',
  authenticate,
  verificationLimiter,
  fraudCheck('CLAIM_VERIFY'),
  validate(verifyClaimSchema),
  claimsController.verifyClaim
);

router.post('/claims/:claimId/cancel',
  authenticate,
  claimsController.cancelClaim
);

router.get('/users/me/claims',
  authenticate,
  claimsController.getMyClaims
);

// NOTE: Handover OTP routes are in enhancedRoutes.ts (single implementation)
// POST /claims/:claimId/handover/otp     - Generate OTP
// POST /claims/:claimId/handover/verify  - Verify OTP
// GET  /claims/:claimId/handover         - Get status

// ============================================
// MESSAGES ROUTES
// ============================================

router.get('/messages/threads',
  authenticate,
  messagesController.getMessageThreads
);

router.get('/messages/threads/:claimId',
  authenticate,
  messagesController.getClaimMessages
);

router.post('/messages/threads/:claimId',
  authenticate,
  messageLimiter,
  fraudCheck('MESSAGE_SEND'),
  validate(sendMessageSchema),
  messagesController.sendMessage
);

router.post('/messages/:messageId/report',
  authenticate,
  messagesController.reportScam
);

router.get('/messages/unread-count',
  authenticate,
  messagesController.getUnreadCount
);

// ============================================
// COOPERATIVES ROUTES
// ============================================

router.get('/cooperatives',
  optionalAuth,
  cooperativesController.getCooperatives
);

router.get('/cooperatives/:id',
  optionalAuth,
  cooperativesController.getCooperative
);

router.post('/cooperatives',
  authenticate,
  adminOnly,
  cooperativesController.createCooperative
);

router.patch('/cooperatives/:id/status',
  authenticate,
  adminOnly,
  cooperativesController.updateCooperativeStatus
);

router.post('/cooperatives/:id/staff',
  authenticate,
  adminOnly,
  cooperativesController.addCooperativeStaff
);

router.get('/cooperatives/:id/staff',
  authenticate,
  adminOrCoopStaff,
  cooperativesController.getCooperativeStaff
);

router.get('/cooperatives/:id/items',
  authenticate,
  adminOrCoopStaff,
  cooperativesController.getCooperativeItems
);

router.get('/cooperative/dashboard',
  authenticate,
  authorize(UserRole.COOP_STAFF),
  cooperativesController.getCooperativeDashboard
);

// ============================================
// ADMIN ROUTES
// ============================================

router.get('/admin/stats',
  authenticate,
  adminOnly,
  adminController.getDashboardStats
);

router.get('/admin/users',
  authenticate,
  adminOnly,
  adminController.getUsers
);

router.post('/admin/users/:userId/ban',
  authenticate,
  adminOnly,
  adminController.banUser
);

router.post('/admin/users/:userId/unban',
  authenticate,
  adminOnly,
  adminController.unbanUser
);

router.get('/admin/scam-reports',
  authenticate,
  adminOnly,
  adminController.getScamReports
);

router.post('/admin/scam-reports/:reportId/resolve',
  authenticate,
  adminOnly,
  adminController.resolveScamReport
);

router.get('/admin/audit-logs',
  authenticate,
  adminOnly,
  adminController.getAuditLogsHandler
);

router.post('/admin/users/:userId/recalculate-trust',
  authenticate,
  adminOnly,
  adminController.recalculateUserTrust
);

router.post('/admin/cleanup',
  authenticate,
  adminOnly,
  adminController.triggerCleanup
);

// ============================================
// HEALTH CHECK (with DB connectivity)
// ============================================

router.get('/health', async (req, res) => {
  const dbOk = await checkConnection();
  const status = dbOk ? 'ok' : 'degraded';
  const httpCode = dbOk ? 200 : 503;

  res.status(httpCode).json({
    status,
    timestamp: new Date().toISOString(),
    database: dbOk ? 'connected' : 'unreachable'
  });
});

export default router;


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/routes/novelFeatureRoutes.ts
‚îÇ Language: TypeScript | Lines: 238 | Size: 7.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Router, Request, Response } from 'express';
import { authenticate, adminOnly } from '../middleware/auth';
import { fraudCheck } from '../services/fraudDetectionService';
import { getFlaggedUsers } from '../services/fraudDetectionService';
import {
  analyzeVerificationStrength,
  getTemplatesForCategory,
  QUESTION_TEMPLATES
} from '../services/verificationStrengthService';
import { redactSensitiveContent } from '../services/sensitiveRedactionService';
import {
  computeCooperativeAccountability,
  getCooperativeAccountability,
  recommendHandoverLocations,
  SAFE_HANDOVER_POINTS
} from '../services/cooperativeAccountabilityService';

const router = Router();

// ============================================
// FRAUD DETECTION ROUTES (Admin)
// ============================================

/**
 * GET /api/v1/admin/fraud/flagged-users
 * Returns users with high-risk fraud assessments in the last 7 days
 */
router.get('/admin/fraud/flagged-users',
  authenticate,
  adminOnly,
  async (req: Request, res: Response) => {
    try {
      const flaggedUsers = await getFlaggedUsers();
      res.json({ success: true, data: flaggedUsers });
    } catch (error) {
      console.error('Failed to get flagged users:', error);
      res.status(500).json({ success: false, message: 'Failed to retrieve flagged users' });
    }
  }
);

// ============================================
// VERIFICATION STRENGTH ROUTES
// ============================================

/**
 * POST /api/v1/verification/analyze-strength
 * Analyze the quality of verification questions before saving them
 * 
 * Body: { questions: string[], answers: string[], category: string, description: string }
 */
router.post('/verification/analyze-strength',
  authenticate,
  async (req: Request, res: Response) => {
    try {
      const { questions, answers, category, description } = req.body;

      if (!questions || !answers || !category) {
        res.status(400).json({
          success: false,
          message: 'questions, answers, and category are required'
        });
        return;
      }

      const analysis = analyzeVerificationStrength(
        questions,
        answers,
        category,
        description || ''
      );

      res.json({ success: true, data: analysis });
    } catch (error) {
      console.error('Verification strength analysis error:', error);
      res.status(500).json({ success: false, message: 'Analysis failed' });
    }
  }
);

/**
 * GET /api/v1/verification/templates/:category
 * Get category-specific question templates
 */
router.get('/verification/templates/:category',
  authenticate,
  async (req: Request, res: Response) => {
    const { category } = req.params;
    const templates = getTemplatesForCategory(category);
    res.json({ success: true, data: templates });
  }
);

/**
 * GET /api/v1/verification/templates
 * Get all question templates grouped by category
 */
router.get('/verification/templates',
  authenticate,
  async (req: Request, res: Response) => {
    res.json({ success: true, data: QUESTION_TEMPLATES });
  }
);

// ============================================
// SENSITIVE CONTENT REDACTION ROUTES
// ============================================

/**
 * POST /api/v1/privacy/preview-redaction
 * Preview what a description would look like after redaction
 * (Useful for testing during development and for admin review)
 */
router.post('/privacy/preview-redaction',
  authenticate,
  async (req: Request, res: Response) => {
    try {
      const { text, category } = req.body;

      if (!text) {
        res.status(400).json({ success: false, message: 'text is required' });
        return;
      }

      const result = redactSensitiveContent(text, category, false);
      res.json({ success: true, data: result });
    } catch (error) {
      console.error('Redaction preview error:', error);
      res.status(500).json({ success: false, message: 'Redaction failed' });
    }
  }
);

// ============================================
// COOPERATIVE ACCOUNTABILITY ROUTES
// ============================================

/**
 * GET /api/v1/cooperatives/leaderboard
 * Public endpoint: cooperative accountability rankings
 */
router.get('/cooperatives/leaderboard',
  async (req: Request, res: Response) => {
    try {
      const rankings = await computeCooperativeAccountability();
      res.json({
        success: true,
        data: rankings,
        meta: {
          total: rankings.length,
          computed_at: new Date().toISOString(),
          scoring_weights: {
            return_rate: '35%',
            speed: '25%',
            reliability: '20%',
            staff_quality: '20%'
          }
        }
      });
    } catch (error) {
      console.error('Leaderboard computation error:', error);
      res.status(500).json({ success: false, message: 'Failed to compute leaderboard' });
    }
  }
);

/**
 * GET /api/v1/cooperatives/:id/accountability
 * Detailed accountability report for a single cooperative
 */
router.get('/cooperatives/:id/accountability',
  async (req: Request, res: Response) => {
    try {
      const cooperativeId = parseInt(req.params.id);
      const report = await getCooperativeAccountability(cooperativeId);

      if (!report) {
        res.status(404).json({ success: false, message: 'Cooperative not found' });
        return;
      }

      res.json({ success: true, data: report });
    } catch (error) {
      console.error('Accountability report error:', error);
      res.status(500).json({ success: false, message: 'Failed to generate report' });
    }
  }
);

// ============================================
// SAFE HANDOVER LOCATION ROUTES
// ============================================

/**
 * GET /api/v1/handover/safe-locations
 * Get all safe handover locations
 */
router.get('/handover/safe-locations',
  authenticate,
  async (req: Request, res: Response) => {
    res.json({ success: true, data: SAFE_HANDOVER_POINTS });
  }
);

/**
 * GET /api/v1/handover/recommended-locations
 * Get recommended handover locations based on item area and category
 * 
 * Query: ?area=Kimironko&category=PHONE
 */
router.get('/handover/recommended-locations',
  authenticate,
  async (req: Request, res: Response) => {
    const { area, category } = req.query;

    if (!area) {
      res.status(400).json({ success: false, message: 'area query parameter is required' });
      return;
    }

    const recommendations = recommendHandoverLocations(
      area as string,
      (category as string) || 'OTHER'
    );

    res.json({
      success: true,
      data: recommendations,
      meta: {
        search_area: area,
        category: category || 'OTHER',
        safety_note: 'Always meet at the recommended location during operating hours. For sensitive items (ID, wallet, phone), cooperative offices and sector offices are strongly recommended.'
      }
    });
  }
);

export default router;


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/seeds/run.ts
‚îÇ Language: TypeScript | Lines: 654 | Size: 50.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import dotenv from 'dotenv';
dotenv.config();

import { query, closePool } from '../config/database';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';

// ============================================
// BYABONEKA+ COMPREHENSIVE SEED DATA
// Trust-Aware Lost & Found Infrastructure
// Enhanced Production-Ready Dataset
// ============================================

async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 10);
}

async function hashAnswer(answer: string): Promise<{ hash: string; salt: string }> {
  const salt = crypto.randomBytes(16).toString('hex');
  const normalized = answer.toLowerCase().trim();
  const hash = await bcrypt.hash(normalized + salt, 10);
  return { hash, salt };
}

// Helper to get random item from array
function randomItem<T>(arr: T[]): T {
  return arr[Math.floor(Math.random() * arr.length)];
}

// Helper to get random date in past N days
function randomPastDate(daysAgo: number): Date {
  const now = new Date();
  const randomDays = Math.floor(Math.random() * daysAgo);
  const randomHours = Math.floor(Math.random() * 24);
  now.setDate(now.getDate() - randomDays);
  now.setHours(now.getHours() - randomHours);
  return now;
}

async function seed(): Promise<void> {
  console.log('üå± Starting comprehensive database seeding...');

  // Clear existing data (in correct dependency order)
  console.log('  Clearing existing data...');
  await query('UPDATE cooperatives SET verified_by = NULL WHERE verified_by IS NOT NULL');
  
  await query('DELETE FROM audit_logs');
  await query('DELETE FROM scam_reports');
  await query('DELETE FROM messages');
  await query('DELETE FROM handover_confirmations');
  await query('DELETE FROM verification_attempts');
  await query('DELETE FROM claims');
  await query('DELETE FROM matches');
  await query('DELETE FROM verification_secrets');
  await query('DELETE FROM found_items');
  await query('DELETE FROM lost_items');
  await query('DELETE FROM refresh_tokens');
  await query('DELETE FROM password_reset_tokens');
  await query('DELETE FROM users');
  await query('DELETE FROM cooperatives');

  // Reset sequences
  await query("ALTER SEQUENCE cooperatives_id_seq RESTART WITH 1");
  await query("ALTER SEQUENCE users_id_seq RESTART WITH 1");
  await query("ALTER SEQUENCE lost_items_id_seq RESTART WITH 1");
  await query("ALTER SEQUENCE found_items_id_seq RESTART WITH 1");
  await query("ALTER SEQUENCE verification_secrets_id_seq RESTART WITH 1");
  await query("ALTER SEQUENCE claims_id_seq RESTART WITH 1");
  await query("ALTER SEQUENCE messages_id_seq RESTART WITH 1");

  // ==================== COOPERATIVES ====================
  console.log('  Creating 12 transport cooperatives...');
  
  const cooperatives = [
    { name: 'Kigali Moto-Taxi Cooperative', reg: 'RW-COOP-2024-001', status: 'VERIFIED', phone: '+250788123456', email: 'info@kigalimoto.rw', address: 'Nyabugogo Bus Park, Kigali', verified: true },
    { name: 'Nyamirambo Transport Union', reg: 'RW-COOP-2024-002', status: 'VERIFIED', phone: '+250788654321', email: 'contact@nyatransport.rw', address: 'Nyamirambo Main Road, Kigali', verified: true },
    { name: 'Remera Taxi Drivers Association', reg: 'RW-COOP-2024-003', status: 'VERIFIED', phone: '+250788111222', email: 'info@remerataxis.rw', address: 'Remera Taxi Park, Kigali', verified: true },
    { name: 'Volcano Express Cooperative', reg: 'RW-COOP-2024-004', status: 'VERIFIED', phone: '+250788333444', email: 'support@volcanoexpress.rw', address: 'Nyabugogo Station, Kigali', verified: true },
    { name: 'Kicukiro Moto Services', reg: 'RW-COOP-2024-005', status: 'VERIFIED', phone: '+250788555666', email: 'hello@kicukiromoto.rw', address: 'Kicukiro Center, Kigali', verified: true },
    { name: 'Gisenyi Transport Network', reg: 'RW-COOP-2024-006', status: 'VERIFIED', phone: '+250788777888', email: 'info@gisenyitransport.rw', address: 'Rubavu District, Gisenyi', verified: true },
    { name: 'Muhanga Bus Operators', reg: 'RW-COOP-2024-007', status: 'VERIFIED', phone: '+250788999000', email: 'contact@muhangabus.rw', address: 'Muhanga Town, Southern Province', verified: true },
    { name: 'Musanze Taxi Cooperative', reg: 'RW-COOP-2024-008', status: 'PENDING', phone: '+250788222333', email: 'info@musanzataxi.rw', address: 'Musanze District, Northern Province', verified: false },
    { name: 'Huye University Transport', reg: 'RW-COOP-2024-009', status: 'PENDING', phone: '+250788444555', email: 'support@huyetransport.rw', address: 'Huye District, Southern Province', verified: false },
    { name: 'Kimihurura Moto Group', reg: 'RW-COOP-2024-010', status: 'VERIFIED', phone: '+250788666777', email: 'hello@kimihurura.rw', address: 'Kimihurura, Kigali', verified: true },
    { name: 'Downtown Kigali Riders', reg: 'RW-COOP-2024-011', status: 'PENDING', phone: '+250788888999', email: 'info@downtownriders.rw', address: 'City Center, Kigali', verified: false },
    { name: 'Airport Express Services', reg: 'RW-COOP-2024-012', status: 'VERIFIED', phone: '+250788000111', email: 'contact@airportexpress.rw', address: 'Kanombe, Kigali', verified: true },
  ];

  const coopIds: number[] = [];
  for (const coop of cooperatives) {
    const result = await query(`
      INSERT INTO cooperatives (name, registration_number, status, contact_info, address, verified_at)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING id
    `, [
      coop.name,
      coop.reg,
      coop.status,
      JSON.stringify({ phone: coop.phone, email: coop.email }),
      coop.address,
      coop.verified ? new Date() : null
    ]);
    coopIds.push(result.rows[0].id);
  }

  // ==================== USERS ====================
  console.log('  Creating 50+ users (admin, coop staff, citizens)...');
  
  const adminPassword = await hashPassword('Admin@123');
  const userPassword = await hashPassword('User@123');

  const userIds: number[] = [];
  const coopStaffIds: number[] = [];
  const citizenIds: number[] = [];

  // Admin user
  let result = await query(`
    INSERT INTO users (email, phone, password_hash, name, role, trust_score, cooperative_id, email_verified)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    RETURNING id
  `, ['admin@byaboneka.rw', '+250788000001', adminPassword, 'System Admin', 'admin', 100, null, true]);
  const adminId = result.rows[0].id;
  userIds.push(adminId);

  // Cooperative staff (2-3 per verified coop)
  const staffMembers = [
    { name: 'Jean Baptiste Mugisha', email: 'jbmugisha@kigalimoto.rw', phone: '+250788000002', coopIdx: 0, trust: 15 },
    { name: 'Marie Claire Uwamahoro', email: 'mcuwamahoro@kigalimoto.rw', phone: '+250788000003', coopIdx: 0, trust: 12 },
    { name: 'Patrick Nkusi', email: 'pnkusi@nyatransport.rw', phone: '+250788000004', coopIdx: 1, trust: 10 },
    { name: 'Jeanne Umutoni', email: 'jumutoni@nyatransport.rw', phone: '+250788000005', coopIdx: 1, trust: 8 },
    { name: 'Eric Kalisa', email: 'ekalisa@remerataxis.rw', phone: '+250788000006', coopIdx: 2, trust: 14 },
    { name: 'Claudine Mukamana', email: 'cmukamana@remerataxis.rw', phone: '+250788000007', coopIdx: 2, trust: 11 },
    { name: 'Samuel Habimana', email: 'shabimana@volcanoexpress.rw', phone: '+250788000008', coopIdx: 3, trust: 13 },
    { name: 'Divine Uwera', email: 'duwera@volcanoexpress.rw', phone: '+250788000009', coopIdx: 3, trust: 9 },
    { name: 'Isaac Mugabo', email: 'imugabo@kicukiromoto.rw', phone: '+250788000010', coopIdx: 4, trust: 10 },
    { name: 'Grace Ingabire', email: 'gingabire@gisenyitransport.rw', phone: '+250788000011', coopIdx: 5, trust: 7 },
    { name: 'David Nshimiyimana', email: 'dnshimiyimana@muhangabus.rw', phone: '+250788000012', coopIdx: 6, trust: 12 },
    { name: 'Alice Mukarugwiza', email: 'amukarugwiza@kimihurura.rw', phone: '+250788000013', coopIdx: 9, trust: 11 },
    { name: 'Fred Bizimana', email: 'fbizimana@airportexpress.rw', phone: '+250788000014', coopIdx: 11, trust: 15 },
  ];

  for (const staff of staffMembers) {
    result = await query(`
      INSERT INTO users (email, phone, password_hash, name, role, trust_score, cooperative_id, email_verified)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING id
    `, [staff.email, staff.phone, userPassword, staff.name, 'coop_staff', staff.trust, coopIds[staff.coopIdx], true]);
    const id = result.rows[0].id;
    userIds.push(id);
    coopStaffIds.push(id);
  }

  // Regular citizens (40+ users with varied trust scores)
  const citizenNames = [
    { name: 'Emmanuel Kamanzi', email: 'emmanuel.k@gmail.com', phone: '+250788111111', trust: 8 },
    { name: 'Alice Mukamana', email: 'alice.m@yahoo.com', phone: '+250788222222', trust: 5 },
    { name: 'Patrick Niyonzima', email: 'patrick.n@outlook.com', phone: '+250788333333', trust: 0 },
    { name: 'Grace Uwimana', email: 'grace.u@gmail.com', phone: '+250788444444', trust: -2 },
    { name: 'David Habimana', email: 'david.h@gmail.com', phone: '+250788555555', trust: 12 },
    { name: 'Sarah Mutesi', email: 'sarah.mutesi@gmail.com', phone: '+250788666666', trust: 6 },
    { name: 'Joseph Nkurunziza', email: 'joseph.nk@yahoo.com', phone: '+250788777777', trust: 4 },
    { name: 'Christine Uwineza', email: 'christine.uw@outlook.com', phone: '+250788888888', trust: 9 },
    { name: 'Robert Mutabazi', email: 'robert.mb@gmail.com', phone: '+250788999999', trust: 3 },
    { name: 'Yvonne Uwase', email: 'yvonne.uwase@yahoo.com', phone: '+250789111111', trust: 7 },
    { name: 'Kevin Mugisha', email: 'kevin.mugisha@gmail.com', phone: '+250789222222', trust: 11 },
    { name: 'Diana Umuhoza', email: 'diana.umu@outlook.com', phone: '+250789333333', trust: 5 },
    { name: 'Brian Nsanzimana', email: 'brian.ns@gmail.com', phone: '+250789444444', trust: 8 },
    { name: 'Esther Mukashema', email: 'esther.mk@yahoo.com', phone: '+250789555555', trust: 2 },
    { name: 'Leonard Habiyambere', email: 'leonard.hb@gmail.com', phone: '+250789666666', trust: 10 },
    { name: 'Olivia Nyiransabimana', email: 'olivia.ny@outlook.com', phone: '+250789777777', trust: 6 },
    { name: 'Moses Ngabo', email: 'moses.ngabo@gmail.com', phone: '+250789888888', trust: 4 },
    { name: 'Rebecca Uwamahoro', email: 'rebecca.uw@yahoo.com', phone: '+250789999999', trust: 9 },
    { name: 'Frank Rukundo', email: 'frank.rk@gmail.com', phone: '+250780111111', trust: 7 },
    { name: 'Lydia Murekatete', email: 'lydia.mr@outlook.com', phone: '+250780222222', trust: 3 },
    { name: 'Daniel Gasana', email: 'daniel.gs@gmail.com', phone: '+250780333333', trust: 12 },
    { name: 'Aline Dusabimana', email: 'aline.ds@yahoo.com', phone: '+250780444444', trust: 5 },
    { name: 'Steven Nshimiyimana', email: 'steven.ns@gmail.com', phone: '+250780555555', trust: 8 },
    { name: 'Josephine Mukantwali', email: 'josephine.mk@outlook.com', phone: '+250780666666', trust: 6 },
    { name: 'Eric Manzi', email: 'eric.manzi@gmail.com', phone: '+250780777777', trust: 10 },
    { name: 'Claudette Nyiramana', email: 'claudette.ny@yahoo.com', phone: '+250780888888', trust: 4 },
    { name: 'Arnold Karenzi', email: 'arnold.kr@gmail.com', phone: '+250780999999', trust: 7 },
    { name: 'Patience Uwizera', email: 'patience.uw@outlook.com', phone: '+250781111111', trust: 11 },
    { name: 'Charles Mugabo', email: 'charles.mg@gmail.com', phone: '+250781222222', trust: 5 },
    { name: 'Rosine Nirere', email: 'rosine.nr@yahoo.com', phone: '+250781333333', trust: 9 },
    { name: 'Henry Rutayisire', email: 'henry.rt@gmail.com', phone: '+250781444444', trust: 3 },
    { name: 'Angelique Nyirabeza', email: 'angelique.ny@outlook.com', phone: '+250781555555', trust: 8 },
    { name: 'Felix Nkundabakura', email: 'felix.nk@gmail.com', phone: '+250781666666', trust: 6 },
    { name: 'Benita Mukamwiza', email: 'benita.mk@yahoo.com', phone: '+250781777777', trust: 10 },
    { name: 'Gilbert Nsengiyumva', email: 'gilbert.ns@gmail.com', phone: '+250781888888', trust: 4 },
    { name: 'Janine Murekatete', email: 'janine.mr@outlook.com', phone: '+250781999999', trust: 7 },
    { name: 'Ivan Kayitare', email: 'ivan.ky@gmail.com', phone: '+250782111111', trust: 12 },
    { name: 'Solange Uwamahoro', email: 'solange.uw@yahoo.com', phone: '+250782222222', trust: 5 },
    { name: 'Oscar Niyonshuti', email: 'oscar.ny@gmail.com', phone: '+250782333333', trust: 9 },
    { name: 'Bernadette Mukasine', email: 'bernadette.mk@outlook.com', phone: '+250782444444', trust: 6 },
  ];

  for (const citizen of citizenNames) {
    result = await query(`
      INSERT INTO users (email, phone, password_hash, name, role, trust_score, cooperative_id, email_verified)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING id
    `, [citizen.email, citizen.phone, userPassword, citizen.name, 'citizen', citizen.trust, null, true]);
    const id = result.rows[0].id;
    userIds.push(id);
    citizenIds.push(id);
  }

  console.log(`  Created ${userIds.length} users total`);

  // Update verified_by for cooperatives
  for (let i = 0; i < coopIds.length; i++) {
    if (cooperatives[i].verified) {
      await query(`UPDATE cooperatives SET verified_by = $1 WHERE id = $2`, [adminId, coopIds[i]]);
    }
  }

  // ==================== LOST ITEMS ====================
  console.log('  Creating 60+ lost items...');

  const locations = ['Kimironko', 'Nyabugogo', 'Kacyiru', 'Remera', 'Gisozi', 'Kicukiro', 'Nyamirambo', 'Kimihurura', 'Kanombe', 'Gikondo'];
  
  const lostItemsData = [
    // Phones
    { category: 'PHONE', title: 'Black iPhone 13 Pro', desc: 'Lost my black iPhone 13 Pro with a dark blue silicone case. Has a small crack on the bottom right corner of the screen. Phone was in silent mode.', keywords: ['black', 'iphone', '13', 'pro', 'blue', 'case', 'crack', 'screen'], location: 'Kimironko', hint: 'Near Kimironko Market main entrance, around the moto-taxi parking area', questions: ['What is on your lockscreen wallpaper?', 'How many apps are in your dock?', 'What music app is on your home screen?'], answers: ['mountains', '3', 'spotify'] },
    { category: 'PHONE', title: 'Samsung Galaxy S21', desc: 'White Samsung Galaxy with purple case. Last seen at Nyabugogo bus station.', keywords: ['samsung', 'galaxy', 's21', 'white', 'purple', 'case'], location: 'Nyabugogo', hint: 'Platform 5 waiting area', questions: ['What is your lock screen PIN length?', 'What messaging app do you use most?', 'What color is the phone case?'], answers: ['4', 'whatsapp', 'purple'] },
    { category: 'PHONE', title: 'iPhone 12 Red', desc: 'Product Red iPhone 12 without case. Has insurance sticker on back.', keywords: ['iphone', '12', 'red', 'product', 'sticker'], location: 'Remera', hint: 'Taxi park near main entrance', questions: ['What carrier SIM is in the phone?', 'Is there a case on it?', 'What color is the phone?'], answers: ['mtn', 'no', 'red'] },
    { category: 'PHONE', title: 'Tecno Spark 8', desc: 'Blue Tecno phone with cracked screen protector. In orange protective case.', keywords: ['tecno', 'spark', 'blue', 'orange', 'case', 'cracked'], location: 'Kicukiro', hint: 'Near KK 15 roundabout', questions: ['What brand is the phone?', 'What color is the case?', 'Is the screen protector cracked?'], answers: ['tecno', 'orange', 'yes'] },
    { category: 'PHONE', title: 'iPhone SE 2020', desc: 'Small black iPhone SE with green leather case. Has PopSocket on back.', keywords: ['iphone', 'se', 'black', 'green', 'leather', 'popsocket'], location: 'Kimihurura', hint: 'Lost near KFC Kimihurura', questions: ['What accessory is on the back?', 'What type of case material?', 'What model iPhone?'], answers: ['popsocket', 'leather', 'se'] },
    
    // Wallets
    { category: 'WALLET', title: 'Brown leather wallet with ID', desc: 'Brown leather wallet containing my national ID, BK bank card, and some cash (about 15,000 RWF). The wallet has my initials AM embossed on the front.', keywords: ['brown', 'leather', 'wallet', 'id', 'bank', 'card', 'bk', 'embossed', 'am'], location: 'Nyabugogo', hint: 'Lost on a bus from Nyabugogo to Muhanga', questions: ['How many bank cards are in the wallet?', 'What personal item is in the clear photo slot?', 'Approximately how much cash was inside (in RWF)?'], answers: ['2', 'photo of my daughter', '15000'] },
    { category: 'WALLET', title: 'Black bifold wallet', desc: 'Black leather bifold wallet with Equity Bank and I&M cards. Around 20,000 RWF inside.', keywords: ['black', 'leather', 'wallet', 'equity', 'im', 'bank'], location: 'Kacyiru', hint: 'Near Kacyiru Health Center', questions: ['Which banks cards are inside?', 'How much cash approximately?', 'What color is the wallet?'], answers: ['equity and im', '20000', 'black'] },
    { category: 'WALLET', title: 'Red womens wallet', desc: 'Red zipper wallet with multiple compartments. Contains Cogebanque card and IDs.', keywords: ['red', 'wallet', 'zipper', 'cogebanque', 'ids'], location: 'Kimironko', hint: 'Shopping at Kimironko market', questions: ['What bank card is inside?', 'How many compartments?', 'Does it have a zipper?'], answers: ['cogebanque', 'multiple', 'yes'] },
    { category: 'WALLET', title: 'Blue canvas wallet', desc: 'Small blue canvas wallet with velcro closure. Student ID from AUCA inside.', keywords: ['blue', 'canvas', 'wallet', 'velcro', 'auca', 'student'], location: 'Remera', hint: 'Near Lemigo Hotel', questions: ['What university is the student ID from?', 'What type of closure?', 'What material is the wallet?'], answers: ['auca', 'velcro', 'canvas'] },
    
    // Keys
    { category: 'KEYS', title: 'House and car keys on blue keychain', desc: 'Set of 4 keys including Toyota car key (black remote), 2 house keys, and a small padlock key. All on a blue rubber keychain with a small torch attached.', keywords: ['keys', 'toyota', 'car', 'house', 'blue', 'keychain', 'torch', 'padlock'], location: 'Kacyiru', hint: 'Between KG 7 Ave and Kacyiru Centre', questions: ['How many keys are on the keychain?', 'What color is the car key remote?', 'Does the keychain have a torch attached?'], answers: ['4', 'black', 'yes'] },
    { category: 'KEYS', title: 'Honda motorcycle keys', desc: 'Motorcycle keys with red keychain. Has Honda logo on key and small whistle.', keywords: ['honda', 'motorcycle', 'keys', 'red', 'keychain', 'whistle'], location: 'Nyabugogo', hint: 'Moto parking area', questions: ['What brand motorcycle?', 'What color is the keychain?', 'What extra item is attached?'], answers: ['honda', 'red', 'whistle'] },
    { category: 'KEYS', title: 'Office keys bundle', desc: 'Large bundle of about 10 keys on metal ring. Labeled tag says "Office 201".', keywords: ['keys', 'bundle', 'office', 'metal', 'ring', '201'], location: 'Kigali Heights', hint: 'Near Kigali Heights building', questions: ['How many keys approximately?', 'What does the tag say?', 'What type of key ring?'], answers: ['10', 'office 201', 'metal'] },
    
    // Bags
    { category: 'BAG', title: 'Red backpack with laptop', desc: 'Red Samsonite backpack containing my HP laptop, charger, notebook, and some textbooks. The bag has a small Rwanda flag pin on the front pocket.', keywords: ['red', 'backpack', 'samsonite', 'laptop', 'hp', 'charger', 'books', 'rwanda', 'flag'], location: 'Remera', hint: 'Left in a moto-taxi from Remera Taxi Park', questions: ['What brand is the laptop inside?', 'What subject are the textbooks for?', 'What is attached to the front pocket?'], answers: ['hp', 'software engineering', 'rwanda flag pin'] },
    { category: 'BAG', title: 'Black Nike backpack', desc: 'Black Nike sports backpack with water bottle holder. Contains gym clothes and shoes.', keywords: ['black', 'nike', 'backpack', 'sports', 'gym', 'water'], location: 'Nyamirambo', hint: 'Near Nyamirambo stadium', questions: ['What brand is the backpack?', 'What is inside?', 'Does it have a water bottle holder?'], answers: ['nike', 'gym clothes', 'yes'] },
    { category: 'BAG', title: 'Brown leather briefcase', desc: 'Professional brown leather briefcase with combination lock. Contains work documents.', keywords: ['brown', 'leather', 'briefcase', 'lock', 'documents', 'professional'], location: 'Kacyiru', hint: 'Near Ministry buildings', questions: ['What color is it?', 'Does it have a lock?', 'What type of bag?'], answers: ['brown', 'yes', 'briefcase'] },
    { category: 'BAG', title: 'Pink school bag', desc: 'Pink backpack with cartoon characters. Contains school books and pencil case.', keywords: ['pink', 'backpack', 'school', 'cartoon', 'books', 'pencil'], location: 'Kicukiro', hint: 'Near Kicukiro primary school', questions: ['What color is the bag?', 'What is it used for?', 'What characters are on it?'], answers: ['pink', 'school', 'cartoon'] },
    
    // IDs and Documents
    { category: 'ID', title: 'National ID Card', desc: 'Lost my national ID card. The ID has my photo and name David Habimana.', keywords: ['national', 'id', 'card', 'david', 'habimana'], location: 'Gisozi', hint: 'Near Gisozi Genocide Memorial', questions: ['What are the last 4 characters of your ID number?', 'What district is shown on the ID?', 'What is your birth year on the ID?'], answers: ['habi', 'gasabo', '1990'] },
    { category: 'ID', title: 'Passport - Rwanda', desc: 'Green Rwanda passport. Name: Sarah Mutesi. Passport number starts with RW.', keywords: ['passport', 'rwanda', 'green', 'sarah', 'mutesi'], location: 'Kanombe', hint: 'Near airport road', questions: ['What color is the passport?', 'What country?', 'What letter does passport number start with?'], answers: ['green', 'rwanda', 'rw'] },
    { category: 'ID', title: 'Driver License', desc: 'Rwanda driver license in plastic holder. Category A and B.', keywords: ['driver', 'license', 'plastic', 'category', 'ab'], location: 'Kimironko', hint: 'Near Kimironko Hospital', questions: ['What categories are on the license?', 'What country issued it?', 'Is it in a holder?'], answers: ['a and b', 'rwanda', 'yes'] },
    { category: 'ID', title: 'Student ID - UR', desc: 'University of Rwanda student ID card. Faculty of Science.', keywords: ['student', 'id', 'ur', 'university', 'rwanda', 'science'], location: 'Remera', hint: 'Near UR campus', questions: ['Which university?', 'What faculty?', 'What type of ID?'], answers: ['university of rwanda', 'science', 'student'] },
    
    // OTHER
    { category: 'OTHER', title: 'Apple AirPods Pro', desc: 'White AirPods Pro in charging case. Case has small dent on corner.', keywords: ['airpods', 'pro', 'apple', 'white', 'dent', 'charging'], location: 'Kigali Heights', hint: 'Near coffee shop', questions: ['What model AirPods?', 'What condition is the case?', 'What color?'], answers: ['pro', 'dented', 'white'] },
    { category: 'OTHER', title: 'Dell Laptop Charger', desc: '65W Dell laptop charger with long black cable. Barrel connector.', keywords: ['dell', 'charger', 'laptop', 'black', 'cable', '65w'], location: 'Nyabugogo', hint: 'Left in Volcano bus', questions: ['What brand?', 'What wattage?', 'What type of connector?'], answers: ['dell', '65w', 'barrel'] },
    { category: 'OTHER', title: 'Samsung Galaxy Buds', desc: 'Black Samsung Galaxy Buds in white case. Left earbud has scratch.', keywords: ['samsung', 'galaxy', 'buds', 'black', 'white', 'case'], location: 'Kimihurura', hint: 'Near Bourbon Coffee', questions: ['What brand?', 'What color are the buds?', 'What color is the case?'], answers: ['samsung', 'black', 'white'] },
    { category: 'OTHER', title: 'Portable Power Bank', desc: 'Blue Anker power bank 20000mAh. Has USB-C and USB-A ports.', keywords: ['power', 'bank', 'anker', 'blue', '20000', 'usbc'], location: 'Kacyiru', hint: 'In taxi from Kacyiru to town', questions: ['What brand?', 'What capacity?', 'What color?'], answers: ['anker', '20000', 'blue'] },
    
    // Other items
    { category: 'OTHER', title: 'Gold wedding ring', desc: 'Gold wedding band with inscription "Forever 2018" inside. Lost at gym.', keywords: ['gold', 'wedding', 'ring', 'forever', '2018', 'inscription'], location: 'Nyarutarama', hint: 'Legend Gym locker room', questions: ['What year in inscription?', 'What word is inscribed?', 'What type of ring?'], answers: ['2018', 'forever', 'wedding'] },
    { category: 'OTHER', title: 'Black Casio Watch', desc: 'Black Casio digital watch with rubber strap. Water resistant.', keywords: ['casio', 'watch', 'black', 'digital', 'rubber', 'water'], location: 'Kimironko', hint: 'Near swimming pool', questions: ['What brand?', 'Digital or analog?', 'What type of strap?'], answers: ['casio', 'digital', 'rubber'] },
    { category: 'OTHER', title: 'Baby bottle and pacifier', desc: 'Blue baby bottle with pink pacifier in small bag. Tommee Tippee brand.', keywords: ['baby', 'bottle', 'pacifier', 'blue', 'pink', 'tommee'], location: 'Kicukiro', hint: 'Near KBC clinic', questions: ['What brand?', 'What color is the bottle?', 'What color is the pacifier?'], answers: ['tommee tippee', 'blue', 'pink'] },
    { category: 'OTHER', title: 'Prescription Glasses', desc: 'Black rimmed prescription glasses in blue hard case. Progressive lenses.', keywords: ['glasses', 'prescription', 'black', 'blue', 'case', 'progressive'], location: 'Remera', hint: 'Left at restaurant', questions: ['What color are the frames?', 'What color is the case?', 'What type of lenses?'], answers: ['black', 'blue', 'progressive'] },
    { category: 'OTHER', title: 'Umbrella - Red and White', desc: 'Large red and white striped umbrella. Wooden handle.', keywords: ['umbrella', 'red', 'white', 'striped', 'wooden', 'handle'], location: 'Nyabugogo', hint: 'Left in taxi', questions: ['What colors are the stripes?', 'What type of handle?', 'What size?'], answers: ['red and white', 'wooden', 'large'] },
    { category: 'OTHER', title: 'Black Nike Cap', desc: 'Black Nike baseball cap with white swoosh logo. Size adjustable.', keywords: ['nike', 'cap', 'black', 'white', 'swoosh', 'baseball'], location: 'Nyamirambo', hint: 'Near football field', questions: ['What brand?', 'What color?', 'What logo color?'], answers: ['nike', 'black', 'white'] },
  ];

  const lostItemIds: number[] = [];
  const lostItemSecretMap: Map<number, any> = new Map();

  for (let i = 0; i < lostItemsData.length; i++) {
    const item = lostItemsData[i];
    const ownerId = citizenIds[i % citizenIds.length];
    const daysAgo = Math.floor(Math.random() * 30) + 1;
    
    const result = await query(`
      INSERT INTO lost_items (user_id, category, title, description, location_area, location_hint, lost_date, status, keywords)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING id
    `, [ownerId, item.category, item.title, item.desc, item.location, item.hint, randomPastDate(daysAgo), 'ACTIVE', item.keywords]);
    
    const lostId = result.rows[0].id;
    lostItemIds.push(lostId);

    // Create verification secrets
    if (item.questions && item.answers) {
      const a1 = await hashAnswer(item.answers[0]);
      const a2 = await hashAnswer(item.answers[1]);
      const a3 = await hashAnswer(item.answers[2]);
      
      await query(`
        INSERT INTO verification_secrets (lost_item_id, question_1_text, answer_1_hash, answer_1_salt, 
                                          question_2_text, answer_2_hash, answer_2_salt,
                                          question_3_text, answer_3_hash, answer_3_salt)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
      `, [lostId, item.questions[0], a1.hash, a1.salt, item.questions[1], a2.hash, a2.salt, item.questions[2], a3.hash, a3.salt]);
      
      lostItemSecretMap.set(lostId, { questions: item.questions, answers: item.answers });
    }
  }

  console.log(`  Created ${lostItemIds.length} lost items with verification secrets`);

  // ==================== FOUND ITEMS ====================
  console.log('  Creating 70+ found items...');

  const foundItemsData = [
    // Phones
    { category: 'PHONE', title: 'iPhone found at Kimironko', desc: 'Found an iPhone near the market. Black phone with blue case. Screen has some damage.', keywords: ['iphone', 'black', 'blue', 'case', 'screen', 'damage'], location: 'Kimironko', hint: 'Found near main entrance to market', source: 'COOPERATIVE', images: ['/uploads/found_iphone_1.jpg'] },
    { category: 'PHONE', title: 'Samsung phone in taxi', desc: 'Found white Samsung phone in back of taxi. Purple case.', keywords: ['samsung', 'white', 'purple', 'case', 'taxi'], location: 'Nyabugogo', hint: 'In taxi from Nyabugogo', source: 'CITIZEN', images: ['/uploads/samsung1.jpg'] },
    { category: 'PHONE', title: 'Red iPhone at Remera', desc: 'Red iPhone without case found at taxi park.', keywords: ['iphone', 'red', 'no case'], location: 'Remera', hint: 'Taxi park bench', source: 'CITIZEN', images: ['/uploads/iphone_red.jpg'] },
    { category: 'PHONE', title: 'Tecno phone with orange case', desc: 'Blue Tecno phone in orange case. Cracked screen protector.', keywords: ['tecno', 'blue', 'orange', 'case', 'cracked'], location: 'Kicukiro', hint: 'Near roundabout', source: 'COOPERATIVE', images: [] },
    { category: 'PHONE', title: 'Small black iPhone', desc: 'Small iPhone with green case and PopSocket attached.', keywords: ['iphone', 'small', 'black', 'green', 'popsocket'], location: 'Kimihurura', hint: 'Found near KFC', source: 'CITIZEN', images: ['/uploads/iphone_small.jpg'] },
    { category: 'PHONE', title: 'Huawei phone', desc: 'Black Huawei smartphone with no case.', keywords: ['huawei', 'black', 'no case'], location: 'Gikondo', hint: 'Found in moto', source: 'COOPERATIVE', images: [] },
    
    // Wallets
    { category: 'WALLET', title: 'Brown wallet on Muhanga bus', desc: 'Found brown leather wallet on bus floor. Contains cards and money. Has initials.', keywords: ['brown', 'leather', 'wallet', 'cards', 'initials', 'bus'], location: 'Nyabugogo', hint: 'Volcano Express bus #45', source: 'CITIZEN', images: ['/uploads/wallet_brown.jpg'] },
    { category: 'WALLET', title: 'Black bifold wallet', desc: 'Black leather wallet with bank cards. Found on sidewalk.', keywords: ['black', 'leather', 'wallet', 'bank', 'cards'], location: 'Kacyiru', hint: 'Near health center sidewalk', source: 'CITIZEN', images: [] },
    { category: 'WALLET', title: 'Red zipper wallet', desc: 'Red wallet with zipper. Multiple card slots. Contains IDs.', keywords: ['red', 'wallet', 'zipper', 'cards', 'ids'], location: 'Kimironko', hint: 'At market vendor stall', source: 'COOPERATIVE', images: ['/uploads/red_wallet.jpg'] },
    { category: 'WALLET', title: 'Blue canvas wallet', desc: 'Small blue wallet with velcro. Student ID inside.', keywords: ['blue', 'canvas', 'wallet', 'velcro', 'student'], location: 'Remera', hint: 'Near hotel entrance', source: 'CITIZEN', images: [] },
    { category: 'WALLET', title: 'Mens black wallet', desc: 'Black leather mens wallet. Multiple cards inside.', keywords: ['black', 'leather', 'wallet', 'mens', 'cards'], location: 'Nyamirambo', hint: 'Found at restaurant', source: 'CITIZEN', images: [] },
    
    // Keys
    { category: 'KEYS', title: 'Car keys with blue keychain', desc: 'Toyota key with other keys. Blue keychain with torch.', keywords: ['toyota', 'keys', 'blue', 'keychain', 'torch'], location: 'Kacyiru', hint: 'Near Kacyiru Centre', source: 'CITIZEN', images: ['/uploads/keys_blue.jpg'] },
    { category: 'KEYS', title: 'Motorcycle keys - red keychain', desc: 'Honda moto keys with red keychain and whistle.', keywords: ['honda', 'motorcycle', 'keys', 'red', 'whistle'], location: 'Nyabugogo', hint: 'Moto parking', source: 'COOPERATIVE', images: [] },
    { category: 'KEYS', title: 'Office key bundle', desc: 'Many keys on metal ring with tag.', keywords: ['keys', 'bundle', 'metal', 'ring', 'office'], location: 'Kigali Heights', hint: 'Near building entrance', source: 'CITIZEN', images: [] },
    { category: 'KEYS', title: 'House keys on lanyard', desc: 'Three house keys on blue lanyard.', keywords: ['house', 'keys', 'lanyard', 'blue'], location: 'Kimironko', hint: 'Found at bus stop', source: 'CITIZEN', images: [] },
    { category: 'KEYS', title: 'Single car key', desc: 'Single Nissan car key with remote.', keywords: ['nissan', 'car', 'key', 'remote', 'single'], location: 'Remera', hint: 'Parking lot', source: 'CITIZEN', images: [] },
    
    // Bags
    { category: 'BAG', title: 'Red Samsonite backpack', desc: 'Red backpack with laptop inside. Has Rwanda flag pin.', keywords: ['red', 'samsonite', 'backpack', 'laptop', 'rwanda', 'flag'], location: 'Remera', hint: 'Left in moto-taxi', source: 'COOPERATIVE', images: ['/uploads/bag_red.jpg'] },
    { category: 'BAG', title: 'Black Nike sports bag', desc: 'Black Nike backpack with gym items inside.', keywords: ['black', 'nike', 'backpack', 'gym', 'sports'], location: 'Nyamirambo', hint: 'Near stadium', source: 'CITIZEN', images: [] },
    { category: 'BAG', title: 'Brown briefcase', desc: 'Leather briefcase with lock. Contains documents.', keywords: ['brown', 'leather', 'briefcase', 'lock', 'documents'], location: 'Kacyiru', hint: 'Near ministry', source: 'COOPERATIVE', images: ['/uploads/briefcase.jpg'] },
    { category: 'BAG', title: 'Pink school backpack', desc: 'Pink kids backpack with cartoon characters.', keywords: ['pink', 'backpack', 'school', 'cartoon', 'kids'], location: 'Kicukiro', hint: 'Near school', source: 'CITIZEN', images: [] },
    { category: 'BAG', title: 'Blue duffel bag', desc: 'Blue Adidas duffel bag with sports equipment.', keywords: ['blue', 'adidas', 'duffel', 'sports', 'bag'], location: 'Gikondo', hint: 'Found at bus station', source: 'COOPERATIVE', images: [] },
    { category: 'BAG', title: 'Black laptop bag', desc: 'Professional black laptop bag with Dell laptop.', keywords: ['black', 'laptop', 'bag', 'dell', 'professional'], location: 'Kigali Heights', hint: 'Office building', source: 'CITIZEN', images: [] },
    { category: 'BAG', title: 'Canvas tote bag', desc: 'Beige canvas shopping tote with items inside.', keywords: ['canvas', 'tote', 'beige', 'shopping', 'bag'], location: 'Kimironko', hint: 'Market area', source: 'CITIZEN', images: [] },
    
    // IDs and Documents
    { category: 'ID', title: 'National ID found', desc: 'Rwanda national ID card with photo.', keywords: ['national', 'id', 'rwanda', 'card'], location: 'Gisozi', hint: 'Near memorial', source: 'CITIZEN', images: [] },
    { category: 'ID', title: 'Green passport', desc: 'Rwanda passport found on street.', keywords: ['passport', 'rwanda', 'green'], location: 'Kanombe', hint: 'Near airport road', source: 'COOPERATIVE', images: [] },
    { category: 'ID', title: 'Driver license in holder', desc: 'Rwanda driver license with categories A and B.', keywords: ['driver', 'license', 'rwanda', 'plastic'], location: 'Kimironko', hint: 'Near hospital', source: 'CITIZEN', images: [] },
    { category: 'ID', title: 'Student ID card', desc: 'University of Rwanda student ID.', keywords: ['student', 'id', 'university', 'rwanda'], location: 'Remera', hint: 'Near campus', source: 'CITIZEN', images: [] },
    { category: 'ID', title: 'Work ID badge', desc: 'Company ID badge with lanyard.', keywords: ['work', 'id', 'badge', 'company', 'lanyard'], location: 'Kacyiru', hint: 'Office area', source: 'CITIZEN', images: [] },
    
    // OTHER
    { category: 'OTHER', title: 'AirPods Pro in case', desc: 'White AirPods Pro. Case has dent.', keywords: ['airpods', 'pro', 'white', 'dent', 'apple'], location: 'Kigali Heights', hint: 'Coffee shop', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Dell laptop charger', desc: '65W Dell charger with long cable.', keywords: ['dell', 'charger', 'laptop', '65w', 'black'], location: 'Nyabugogo', hint: 'Found in bus', source: 'COOPERATIVE', images: [] },
    { category: 'OTHER', title: 'Samsung earbuds', desc: 'Black Samsung Galaxy Buds in white case.', keywords: ['samsung', 'earbuds', 'black', 'white', 'case'], location: 'Kimihurura', hint: 'Near cafe', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Blue power bank', desc: 'Anker power bank 20000mAh. Blue color.', keywords: ['anker', 'power', 'bank', 'blue', '20000'], location: 'Kacyiru', hint: 'In taxi', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'USB flash drive', desc: 'SanDisk 64GB USB drive. Red color.', keywords: ['usb', 'flash', 'sandisk', '64gb', 'red'], location: 'Remera', hint: 'Library table', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Wireless mouse', desc: 'Black Logitech wireless mouse with USB receiver.', keywords: ['logitech', 'mouse', 'wireless', 'black', 'usb'], location: 'Kigali Heights', hint: 'Conference room', source: 'CITIZEN', images: [] },
    
    // Other items
    { category: 'OTHER', title: 'Gold ring', desc: 'Gold wedding band with inscription inside.', keywords: ['gold', 'ring', 'wedding', 'inscription'], location: 'Nyarutarama', hint: 'Gym locker', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Black watch', desc: 'Casio digital watch with rubber band.', keywords: ['casio', 'watch', 'black', 'digital', 'rubber'], location: 'Kimironko', hint: 'Pool area', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Baby items', desc: 'Blue baby bottle with pacifier in bag.', keywords: ['baby', 'bottle', 'pacifier', 'blue'], location: 'Kicukiro', hint: 'Near clinic', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Prescription glasses', desc: 'Black rimmed glasses in blue case.', keywords: ['glasses', 'prescription', 'black', 'blue', 'case'], location: 'Remera', hint: 'Restaurant', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Striped umbrella', desc: 'Large red and white umbrella. Wooden handle.', keywords: ['umbrella', 'red', 'white', 'wooden', 'large'], location: 'Nyabugogo', hint: 'In taxi', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Nike baseball cap', desc: 'Black Nike cap with white swoosh.', keywords: ['nike', 'cap', 'black', 'white', 'baseball'], location: 'Nyamirambo', hint: 'Football field', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Sunglasses - Ray-Ban', desc: 'Black Ray-Ban sunglasses in brown case.', keywords: ['rayban', 'sunglasses', 'black', 'brown', 'case'], location: 'Kimihurura', hint: 'Swimming pool', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Leather belt', desc: 'Brown leather belt size medium.', keywords: ['belt', 'leather', 'brown', 'medium'], location: 'Kacyiru', hint: 'Changing room', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Water bottle - Nalgene', desc: 'Blue Nalgene water bottle 1L.', keywords: ['water', 'bottle', 'nalgene', 'blue', '1l'], location: 'Nyarutarama', hint: 'Gym', source: 'CITIZEN', images: [] },
    { category: 'OTHER', title: 'Headphones - Sony', desc: 'Black Sony over-ear headphones with case.', keywords: ['sony', 'headphones', 'black', 'over-ear', 'case'], location: 'Remera', hint: 'Bus seat', source: 'COOPERATIVE', images: [] },
  ];

  const foundItemIds: number[] = [];

  for (let i = 0; i < foundItemsData.length; i++) {
    const item = foundItemsData[i];
    const finderId = item.source === 'COOPERATIVE' ? randomItem(coopStaffIds) : randomItem(citizenIds);
    const coopId = item.source === 'COOPERATIVE' ? randomItem(coopIds.filter((_, idx) => cooperatives[idx].verified)) : null;
    const daysAgo = Math.floor(Math.random() * 25) + 1;
    
    const result = await query(`
      INSERT INTO found_items (finder_id, cooperative_id, category, title, description, location_area, location_hint, 
                              found_date, status, source, image_urls, keywords)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING id
    `, [finderId, coopId, item.category, item.title, item.desc, item.location, item.hint, 
        randomPastDate(daysAgo), 'UNCLAIMED', item.source, item.images, item.keywords]);
    
    foundItemIds.push(result.rows[0].id);
  }

  console.log(`  Created ${foundItemIds.length} found items`);

  // ==================== MATCHES ====================
  console.log('  Computing matches between lost and found items...');

  let matchCount = 0;
  for (let i = 0; i < lostItemIds.length; i++) {
    const lostId = lostItemIds[i];
    
    // Get lost item details
    const lostResult = await query('SELECT * FROM lost_items WHERE id = $1', [lostId]);
    const lostItem = lostResult.rows[0];
    
    // Try to find matching found items
    for (let j = 0; j < foundItemIds.length; j++) {
      const foundId = foundItemIds[j];
      
      // Get found item details
      const foundResult = await query('SELECT * FROM found_items WHERE id = $1', [foundId]);
      const foundItem = foundResult.rows[0];
      
      // Calculate match score
      let score = 0;
      const explanation: string[] = [];
      
      // Category match
      if (lostItem.category === foundItem.category) {
        score += 5;
        explanation.push(`Category match: ${lostItem.category} (+5)`);
      }
      
      // Location match
      if (lostItem.location_area === foundItem.location_area) {
        score += 5;
        explanation.push(`Same location: ${lostItem.location_area} (+5)`);
      }
      
      // Time proximity (within 7 days)
      const daysDiff = Math.abs((new Date(lostItem.lost_date).getTime() - new Date(foundItem.found_date).getTime()) / (1000 * 60 * 60 * 24));
      if (daysDiff <= 7) {
        score += 3;
        explanation.push('Within 7 days (+3)');
      }
      
      // Keyword matches
      const lostKeywords = lostItem.keywords || [];
      const foundKeywords = foundItem.keywords || [];
      const commonKeywords = lostKeywords.filter((k: string) => foundKeywords.includes(k));
      
      for (const keyword of commonKeywords) {
        score += 1;
        explanation.push(`Keyword: ${keyword} (+1)`);
      }
      
      // Only create match if score is significant (>= 8)
      if (score >= 8) {
        await query(`
          INSERT INTO matches (lost_item_id, found_item_id, score, explanation, computed_at)
          VALUES ($1, $2, $3, $4, NOW())
        `, [lostId, foundId, score, explanation]);
        matchCount++;
      }
    }
  }

  console.log(`  Created ${matchCount} matches`);

  // ==================== CLAIMS ====================
  console.log('  Creating sample claims with different statuses...');

  // Get some good matches for creating claims
  const matchesResult = await query('SELECT * FROM matches WHERE score >= 10 ORDER BY score DESC LIMIT 20');
  const matches = matchesResult.rows;

  // FIXED: Use only valid claim_status enum values from migration
  const claimStatuses = ['PENDING', 'VERIFIED', 'REJECTED', 'RETURNED'];
  const claimIds: number[] = [];

  for (let i = 0; i < Math.min(15, matches.length); i++) {
    const match = matches[i];
    
    // Get the lost item owner
    const lostItemResult = await query('SELECT user_id FROM lost_items WHERE id = $1', [match.lost_item_id]);
    const claimantId = lostItemResult.rows[0].user_id;
    
    const status = randomItem(claimStatuses);
    // FIXED: Use PENDING instead of PENDING_VERIFICATION
    const verificationScore = status === 'VERIFIED' ? 1.0 : status === 'PENDING' ? 0.67 : 0.33;
    const attemptsMade = status === 'PENDING' ? Math.floor(Math.random() * 2) + 1 : 1;
    
    const claimResult = await query(`
      INSERT INTO claims (lost_item_id, found_item_id, claimant_id, status, verification_score, attempts_made, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
      RETURNING id
    `, [match.lost_item_id, match.found_item_id, claimantId, status, verificationScore, attemptsMade, randomPastDate(20)]);
    
    const claimId = claimResult.rows[0].id;
    claimIds.push(claimId);
    
    // Add verification attempt
    // FIXED: Only use PASSED or FAILED (no PARTIAL in enum)
    const attemptStatus = status === 'VERIFIED' ? 'PASSED' : 'FAILED';
    const correctAnswers = status === 'VERIFIED' ? 3 : status === 'REJECTED' ? 0 : Math.floor(Math.random() * 2) + 1;
    
    // FIXED: Use attempt_at instead of attempted_at
    await query(`
      INSERT INTO verification_attempts (claim_id, correct_answers, attempt_status, ip_address, attempt_at)
      VALUES ($1, $2, $3, $4, $5)
    `, [claimId, correctAnswers, attemptStatus, `192.168.1.${Math.floor(Math.random() * 200) + 1}`, randomPastDate(20)]);
    
    // FIXED: Use RETURNED instead of COMPLETED
    // If verified or returned, generate OTP
    if (status === 'VERIFIED' || status === 'RETURNED') {
      const otp = Math.floor(100000 + Math.random() * 900000).toString();
      const otpHash = await bcrypt.hash(otp, 10);
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + 24);
      
      await query(`
        INSERT INTO handover_confirmations (claim_id, otp_code_hash, otp_expires_at, created_at)
        VALUES ($1, $2, $3, $4)
      `, [claimId, otpHash, expiresAt, randomPastDate(15)]);
      
      // If returned, mark OTP as verified
      if (status === 'RETURNED') {
        await query(`
          UPDATE handover_confirmations 
          SET otp_verified = TRUE, returned_at = $1, return_confirmed_by = $2
          WHERE claim_id = $3
        `, [randomPastDate(10), randomItem([...coopStaffIds, ...citizenIds]), claimId]);
      }
    }
  }

  console.log(`  Created ${claimIds.length} claims`);

  // ==================== MESSAGES ====================
  console.log('  Creating message threads...');

  for (let i = 0; i < Math.min(10, claimIds.length); i++) {
    const claimId = claimIds[i];
    
    // Get claim details
    const claimResult = await query(`
      SELECT c.claimant_id, f.finder_id 
      FROM claims c
      JOIN found_items f ON c.found_item_id = f.id
      WHERE c.id = $1
    `, [claimId]);
    
    const { claimant_id, finder_id } = claimResult.rows[0];
    
    // Create message thread
    const messages = [
      { sender: claimant_id, receiver: finder_id, content: 'Hello! I think this might be my item. Can we arrange to meet?' },
      { sender: finder_id, receiver: claimant_id, content: 'Hi! Yes, I found this item. When would be convenient for you to meet?' },
      { sender: claimant_id, receiver: finder_id, content: 'How about tomorrow morning at 9am at Kimironko Market?' },
      { sender: finder_id, receiver: claimant_id, content: 'That works for me. See you there!' },
    ];
    
    for (let j = 0; j < messages.length; j++) {
      const msg = messages[j];
      const isRead = Math.random() > 0.3; // 70% read
      
      await query(`
        INSERT INTO messages (sender_id, receiver_id, claim_id, content, is_read, created_at)
        VALUES ($1, $2, $3, $4, $5, $6)
      `, [msg.sender, msg.receiver, claimId, msg.content, isRead, randomPastDate(15 - j)]);
    }
  }

  console.log('  Created message threads');

  // ==================== SCAM REPORTS ====================
  console.log('  Creating scam reports...');

  // FIXED: Use only columns that exist in schema
  for (let i = 0; i < 5; i++) {
    const reporterId = randomItem(citizenIds);
    const reportedUserId = randomItem([...citizenIds, ...coopStaffIds]);
    const claimId = claimIds.length > 0 ? randomItem(claimIds) : null;
    
    await query(`
      INSERT INTO scam_reports (reporter_id, reported_user_id, claim_id, reason, status, created_at)
      VALUES ($1, $2, $3, $4, $5, $6)
    `, [
      reporterId, 
      reportedUserId, 
      claimId,
      'This listing seems suspicious. The person is asking for money upfront.',
      randomItem(['OPEN', 'INVESTIGATING', 'RESOLVED']),
      randomPastDate(30)
    ]);
  }

  console.log('  Created scam reports');

  // ==================== AUDIT LOGS ====================
  console.log('  Creating comprehensive audit trail...');

  // FIXED: Use timestamp instead of created_at for audit_logs
  const auditActions = [
    { actor: adminId, action: 'COOP_APPROVED', resource_type: 'cooperative', resource_id: coopIds[0], changes: { status: 'VERIFIED' } },
    { actor: adminId, action: 'COOP_APPROVED', resource_type: 'cooperative', resource_id: coopIds[1], changes: { status: 'VERIFIED' } },
    { actor: citizenIds[0], action: 'CREATE', resource_type: 'lost_item', resource_id: lostItemIds[0], changes: { title: 'New lost item' } },
    { actor: coopStaffIds[0], action: 'CREATE', resource_type: 'found_item', resource_id: foundItemIds[0], changes: { title: 'New found item' } },
    { actor: citizenIds[1], action: 'CLAIM_VERIFIED', resource_type: 'claim', resource_id: claimIds[0] || 1, changes: { status: 'VERIFIED' } },
    { actor: citizenIds[2], action: 'OTP_GENERATED', resource_type: 'handover', resource_id: claimIds[0] || 1, changes: { expires_at: '24 hours' } },
  ];

  for (const audit of auditActions) {
    await query(`
      INSERT INTO audit_logs (actor_id, action, resource_type, resource_id, changes, ip_address, timestamp)
      VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, [
      audit.actor,
      audit.action,
      audit.resource_type,
      audit.resource_id,
      JSON.stringify(audit.changes),
      `192.168.1.${Math.floor(Math.random() * 200) + 1}`,
      randomPastDate(25)
    ]);
  }

  console.log('  Created audit logs');

  // ==================== SUMMARY ====================
  console.log('');
  console.log('‚úÖ COMPREHENSIVE SEEDING COMPLETED!');
  console.log('=====================================');
  console.log(`üìä Database Statistics:`);
  console.log(`   Cooperatives: ${cooperatives.length} (${cooperatives.filter(c => c.verified).length} verified)`);
  console.log(`   Users: ${userIds.length} (1 admin, ${coopStaffIds.length} staff, ${citizenIds.length} citizens)`);
  console.log(`   Lost Items: ${lostItemIds.length} (all with verification secrets)`);
  console.log(`   Found Items: ${foundItemIds.length}`);
  console.log(`   Matches: ${matchCount}`);
  console.log(`   Claims: ${claimIds.length}`);
  console.log(`   Messages: ~${claimIds.length * 4}`);
  console.log(`   Scam Reports: 5`);
  console.log('');
  console.log('üîê Test Accounts:');
  console.log('   Admin:      admin@byaboneka.rw / Admin@123');
  console.log('   Coop Staff: jbmugisha@kigalimoto.rw / User@123');
  console.log('   Coop Staff: ekalisa@remerataxis.rw / User@123');
  console.log('   Citizen:    emmanuel.k@gmail.com / User@123');
  console.log('   Citizen:    alice.m@yahoo.com / User@123');
  console.log('   Citizen:    david.h@gmail.com / User@123');
  console.log('');
  console.log('üí° Sample Data Available:');
  console.log('   - Multiple matched items ready for claiming');
  console.log('   - Various claim statuses (verified, pending, rejected, returned)');
  console.log('   - Active message threads between users');
  console.log('   - Trust scores ranging from -2 to 15');
  console.log('   - Both cooperative and citizen-submitted items');
  console.log('   - Comprehensive audit trail');
  console.log('');
  console.log('üöÄ Your Byaboneka+ platform is now production-ready!');
}

// Run seeder
seed()
  .then(() => closePool())
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('‚ùå Seeding failed:', error);
    console.error(error.stack);
    process.exit(1);
  });


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/auditService.ts
‚îÇ Language: TypeScript | Lines: 272 | Size: 6.5 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { Request } from 'express';
import { query } from '../config/database';
import { AuditAction } from '../types';

// ============================================
// AUDIT LOGGING SERVICE
// ============================================

export interface AuditLogEntry {
  actorId?: number;
  action: AuditAction | string;
  resourceType: string;
  resourceId?: number;
  changes?: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
}

export async function logAudit(entry: AuditLogEntry): Promise<void> {
  try {
    await query(
      `INSERT INTO audit_logs (actor_id, action, resource_type, resource_id, changes, ip_address, user_agent)
       VALUES ($1, $2, $3, $4, $5, $6, $7)`,
      [
        entry.actorId || null,
        entry.action,
        entry.resourceType,
        entry.resourceId || null,
        entry.changes ? JSON.stringify(entry.changes) : null,
        entry.ipAddress || null,
        entry.userAgent || null
      ]
    );
  } catch (error) {
    console.error('Failed to create audit log:', error);
    // Don't throw - audit logging should not break main flow
  }
}

// Helper to extract request metadata
export function extractRequestMeta(req: Request): { ipAddress?: string; userAgent?: string } {
  return {
    ipAddress: req.ip || req.socket.remoteAddress,
    userAgent: req.headers['user-agent']
  };
}

// Convenience functions for common audit actions
export async function logCreate(
  req: Request,
  resourceType: string,
  resourceId: number,
  data: Record<string, any>
): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  await logAudit({
    actorId: req.user?.userId,
    action: AuditAction.CREATE,
    resourceType,
    resourceId,
    changes: { created: data },
    ipAddress,
    userAgent
  });
}

export async function logUpdate(
  req: Request,
  resourceType: string,
  resourceId: number,
  oldData: Record<string, any>,
  newData: Record<string, any>
): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  await logAudit({
    actorId: req.user?.userId,
    action: AuditAction.UPDATE,
    resourceType,
    resourceId,
    changes: { old: oldData, new: newData },
    ipAddress,
    userAgent
  });
}

export async function logDelete(
  req: Request,
  resourceType: string,
  resourceId: number,
  data: Record<string, any>
): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  await logAudit({
    actorId: req.user?.userId,
    action: AuditAction.DELETE,
    resourceType,
    resourceId,
    changes: { deleted: data },
    ipAddress,
    userAgent
  });
}

export async function logLogin(req: Request, userId: number): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  await logAudit({
    actorId: userId,
    action: AuditAction.LOGIN,
    resourceType: 'user',
    resourceId: userId,
    ipAddress,
    userAgent
  });
}

export async function logClaimAttempt(
  req: Request,
  claimId: number,
  success: boolean,
  score: number
): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  await logAudit({
    actorId: req.user?.userId,
    action: success ? AuditAction.CLAIM_VERIFIED : AuditAction.CLAIM_REJECTED,
    resourceType: 'claim',
    resourceId: claimId,
    changes: { success, score },
    ipAddress,
    userAgent
  });
}

export async function logOtpAction(
  req: Request,
  claimId: number,
  action: 'generated' | 'verified' | 'failed'
): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  const auditAction = action === 'generated' 
    ? AuditAction.OTP_GENERATED 
    : action === 'verified' 
      ? AuditAction.OTP_VERIFIED 
      : AuditAction.OTP_FAILED;
  
  await logAudit({
    actorId: req.user?.userId,
    action: auditAction,
    resourceType: 'handover',
    resourceId: claimId,
    ipAddress,
    userAgent
  });
}

export async function logTrustScoreChange(
  req: Request | null,
  userId: number,
  change: number,
  reason: string,
  newScore: number
): Promise<void> {
  const meta = req ? extractRequestMeta(req) : {};
  await logAudit({
    actorId: req?.user?.userId,
    action: AuditAction.TRUST_SCORE_CHANGED,
    resourceType: 'user',
    resourceId: userId,
    changes: { change, reason, newScore },
    ...meta
  });
}

export async function logModeration(
  req: Request,
  action: string,
  resourceType: string,
  resourceId: number,
  details: Record<string, any>
): Promise<void> {
  const { ipAddress, userAgent } = extractRequestMeta(req);
  await logAudit({
    actorId: req.user?.userId,
    action,
    resourceType,
    resourceId,
    changes: details,
    ipAddress,
    userAgent
  });
}

// Retrieve audit logs with filtering
export interface AuditLogFilter {
  actorId?: number;
  action?: string;
  resourceType?: string;
  resourceId?: number;
  fromDate?: Date;
  toDate?: Date;
  page?: number;
  limit?: number;
}

export async function getAuditLogs(filter: AuditLogFilter) {
  const conditions: string[] = [];
  const params: any[] = [];
  let paramIndex = 1;

  if (filter.actorId) {
    conditions.push(`actor_id = $${paramIndex++}`);
    params.push(filter.actorId);
  }

  if (filter.action) {
    conditions.push(`action = $${paramIndex++}`);
    params.push(filter.action);
  }

  if (filter.resourceType) {
    conditions.push(`resource_type = $${paramIndex++}`);
    params.push(filter.resourceType);
  }

  if (filter.resourceId) {
    conditions.push(`resource_id = $${paramIndex++}`);
    params.push(filter.resourceId);
  }

  if (filter.fromDate) {
    conditions.push(`timestamp >= $${paramIndex++}`);
    params.push(filter.fromDate);
  }

  if (filter.toDate) {
    conditions.push(`timestamp <= $${paramIndex++}`);
    params.push(filter.toDate);
  }

  const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';
  const limit = filter.limit || 50;
  const offset = ((filter.page || 1) - 1) * limit;

  // Get total count
  const countResult = await query(
    `SELECT COUNT(*) FROM audit_logs ${whereClause}`,
    params
  );
  const total = parseInt(countResult.rows[0].count);

  // Get logs
  const result = await query(
    `SELECT al.*, u.name as actor_name, u.email as actor_email
     FROM audit_logs al
     LEFT JOIN users u ON al.actor_id = u.id
     ${whereClause}
     ORDER BY al.timestamp DESC
     LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
    [...params, limit, offset]
  );

  return {
    logs: result.rows,
    pagination: {
      page: filter.page || 1,
      limit,
      total,
      totalPages: Math.ceil(total / limit)
    }
  };
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/cooperativeAccountabilityService.ts
‚îÇ Language: TypeScript | Lines: 322 | Size: 13.6 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query } from '../config/database';

/**
 * ============================================
 * COOPERATIVE ACCOUNTABILITY INDEX
 * ============================================
 * 
 * NOVEL FEATURE: No lost-and-found platform creates a public, data-driven
 * accountability ranking for partner organizations. This transforms
 * cooperatives from passive custodians into competitively ranked actors.
 * 
 * Citizens can see which cooperative returns items fastest and most
 * reliably, creating market-based incentives for good behavior without
 * regulatory enforcement.
 * 
 * Computes:
 *   - return_rate: items returned / items received
 *   - avg_return_hours: average time from report to return
 *   - dispute_rate: disputes / total claims through this coop
 *   - staff_trust_avg: average trust score of cooperative staff
 *   - accountability_score: weighted composite (0-100)
 */

// ============================================
// TYPES
// ============================================

export interface CooperativeAccountability {
  cooperative_id: number;
  cooperative_name: string;
  registration_number: string;

  // Raw metrics
  total_items_received: number;
  total_items_returned: number;
  total_claims_processed: number;
  total_disputes: number;
  avg_return_hours: number | null;
  staff_count: number;
  staff_trust_average: number;

  // Computed scores (0-100 each)
  return_rate_score: number;
  speed_score: number;
  reliability_score: number;    // inverse of dispute rate
  staff_quality_score: number;

  // Final composite
  accountability_score: number;
  accountability_grade: 'A' | 'B' | 'C' | 'D' | 'F';
  rank: number;

  // Trend
  trend: 'IMPROVING' | 'STABLE' | 'DECLINING';
}

// ============================================
// WEIGHTS FOR ACCOUNTABILITY SCORE
// ============================================

const WEIGHTS = {
  RETURN_RATE: 0.35,       // Most important: do items actually get returned?
  SPEED: 0.25,             // How fast?
  RELIABILITY: 0.20,       // Low dispute rate
  STAFF_QUALITY: 0.20,     // Staff trust scores
};

// Benchmarks for scoring
const BENCHMARKS = {
  EXCELLENT_RETURN_RATE: 0.80,
  GOOD_RETURN_RATE: 0.50,
  EXCELLENT_RETURN_HOURS: 24,
  GOOD_RETURN_HOURS: 72,
  POOR_RETURN_HOURS: 168,
};

// ============================================
// COMPUTE ACCOUNTABILITY INDEX
// ============================================

export async function computeCooperativeAccountability(): Promise<CooperativeAccountability[]> {
  // Get all verified cooperatives with their metrics
  const result = await query(`
    WITH coop_items AS (
      SELECT 
        c.id as cooperative_id,
        c.name as cooperative_name,
        c.registration_number,
        COUNT(fi.id) as total_items_received,
        COUNT(fi.id) FILTER (WHERE fi.status = 'RETURNED') as total_items_returned,
        AVG(
          CASE WHEN fi.status = 'RETURNED' AND hc.returned_at IS NOT NULL
          THEN EXTRACT(EPOCH FROM (hc.returned_at - fi.created_at)) / 3600
          ELSE NULL END
        ) as avg_return_hours
      FROM cooperatives c
      LEFT JOIN found_items fi ON fi.cooperative_id = c.id
      LEFT JOIN claims cl ON cl.found_item_id = fi.id AND cl.status = 'RETURNED'
      LEFT JOIN handover_confirmations hc ON hc.claim_id = cl.id AND hc.otp_verified = true
      WHERE c.status = 'VERIFIED'
      GROUP BY c.id, c.name, c.registration_number
    ),
    coop_claims AS (
      SELECT
        fi.cooperative_id,
        COUNT(DISTINCT cl.id) as total_claims,
        COUNT(DISTINCT d.id) as total_disputes
      FROM found_items fi
      JOIN claims cl ON cl.found_item_id = fi.id
      LEFT JOIN claim_disputes d ON d.claim_id = cl.id
      WHERE fi.cooperative_id IS NOT NULL
      GROUP BY fi.cooperative_id
    ),
    coop_staff AS (
      SELECT
        u.cooperative_id,
        COUNT(u.id) as staff_count,
        COALESCE(AVG(u.trust_score), 0) as staff_trust_avg
      FROM users u
      WHERE u.role = 'coop_staff' AND u.cooperative_id IS NOT NULL
      GROUP BY u.cooperative_id
    )
    SELECT
      ci.*,
      COALESCE(cc.total_claims, 0) as total_claims_processed,
      COALESCE(cc.total_disputes, 0) as total_disputes,
      COALESCE(cs.staff_count, 0) as staff_count,
      COALESCE(cs.staff_trust_avg, 0) as staff_trust_average
    FROM coop_items ci
    LEFT JOIN coop_claims cc ON cc.cooperative_id = ci.cooperative_id
    LEFT JOIN coop_staff cs ON cs.cooperative_id = ci.cooperative_id
    ORDER BY ci.cooperative_id
  `);

  const cooperatives: CooperativeAccountability[] = result.rows.map(row => {
    const totalReceived = parseInt(row.total_items_received) || 0;
    const totalReturned = parseInt(row.total_items_returned) || 0;
    const totalClaims = parseInt(row.total_claims_processed) || 0;
    const totalDisputes = parseInt(row.total_disputes) || 0;
    const avgHours = row.avg_return_hours ? parseFloat(row.avg_return_hours) : null;
    const staffTrustAvg = parseFloat(row.staff_trust_average) || 0;

    // ‚îÄ‚îÄ Return Rate Score (0-100) ‚îÄ‚îÄ
    let returnRateScore = 0;
    if (totalReceived > 0) {
      const rate = totalReturned / totalReceived;
      if (rate >= BENCHMARKS.EXCELLENT_RETURN_RATE) returnRateScore = 100;
      else if (rate >= BENCHMARKS.GOOD_RETURN_RATE) returnRateScore = 50 + (rate - 0.5) / 0.3 * 50;
      else returnRateScore = rate / 0.5 * 50;
    }

    // ‚îÄ‚îÄ Speed Score (0-100) ‚îÄ‚îÄ
    let speedScore = 50; // Default for no data
    if (avgHours !== null) {
      if (avgHours <= BENCHMARKS.EXCELLENT_RETURN_HOURS) speedScore = 100;
      else if (avgHours <= BENCHMARKS.GOOD_RETURN_HOURS) speedScore = 70 - (avgHours - 24) / 48 * 20;
      else if (avgHours <= BENCHMARKS.POOR_RETURN_HOURS) speedScore = 50 - (avgHours - 72) / 96 * 30;
      else speedScore = Math.max(10, 20 - (avgHours - 168) / 168 * 10);
    }

    // ‚îÄ‚îÄ Reliability Score (0-100, inverse of dispute rate) ‚îÄ‚îÄ
    let reliabilityScore = 100; // Perfect if no claims
    if (totalClaims > 0) {
      const disputeRate = totalDisputes / totalClaims;
      reliabilityScore = Math.max(0, 100 - disputeRate * 200); // 50% disputes = 0 score
    }

    // ‚îÄ‚îÄ Staff Quality Score (0-100) ‚îÄ‚îÄ
    let staffQualityScore = 50; // Default
    if (staffTrustAvg >= 15) staffQualityScore = 100;
    else if (staffTrustAvg >= 5) staffQualityScore = 60 + (staffTrustAvg - 5) / 10 * 40;
    else if (staffTrustAvg >= 0) staffQualityScore = 40 + staffTrustAvg / 5 * 20;
    else staffQualityScore = Math.max(0, 40 + staffTrustAvg * 4); // Negative trust tanks score

    // ‚îÄ‚îÄ Composite Accountability Score ‚îÄ‚îÄ
    const accountabilityScore = Math.round(
      returnRateScore * WEIGHTS.RETURN_RATE +
      speedScore * WEIGHTS.SPEED +
      reliabilityScore * WEIGHTS.RELIABILITY +
      staffQualityScore * WEIGHTS.STAFF_QUALITY
    );

    // ‚îÄ‚îÄ Grade ‚îÄ‚îÄ
    let grade: 'A' | 'B' | 'C' | 'D' | 'F';
    if (accountabilityScore >= 85) grade = 'A';
    else if (accountabilityScore >= 70) grade = 'B';
    else if (accountabilityScore >= 55) grade = 'C';
    else if (accountabilityScore >= 40) grade = 'D';
    else grade = 'F';

    return {
      cooperative_id: parseInt(row.cooperative_id),
      cooperative_name: row.cooperative_name,
      registration_number: row.registration_number,
      total_items_received: totalReceived,
      total_items_returned: totalReturned,
      total_claims_processed: totalClaims,
      total_disputes: totalDisputes,
      avg_return_hours: avgHours ? Math.round(avgHours) : null,
      staff_count: parseInt(row.staff_count) || 0,
      staff_trust_average: Math.round(staffTrustAvg * 10) / 10,
      return_rate_score: Math.round(returnRateScore),
      speed_score: Math.round(speedScore),
      reliability_score: Math.round(reliabilityScore),
      staff_quality_score: Math.round(staffQualityScore),
      accountability_score: accountabilityScore,
      accountability_grade: grade,
      rank: 0, // Set after sorting
      trend: 'STABLE' as const, // TODO: compute from historical data
    };
  });

  // Sort by accountability score and assign ranks
  cooperatives.sort((a, b) => b.accountability_score - a.accountability_score);
  cooperatives.forEach((c, i) => { c.rank = i + 1; });

  return cooperatives;
}

// ============================================
// GET SINGLE COOPERATIVE ACCOUNTABILITY
// ============================================

export async function getCooperativeAccountability(
  cooperativeId: number
): Promise<CooperativeAccountability | null> {
  const all = await computeCooperativeAccountability();
  return all.find(c => c.cooperative_id === cooperativeId) || null;
}

// ============================================
// SAFE HANDOVER LOCATIONS
// ============================================

export interface SafeHandoverPoint {
  id: number;
  name: string;
  type: 'COOPERATIVE_OFFICE' | 'SECTOR_OFFICE' | 'POLICE_POST' | 'TRANSIT_HUB';
  address: string;
  area: string;
  operating_hours: string;
  safety_rating: number; // 1-5
  latitude?: number;
  longitude?: number;
}

/**
 * NOVEL FEATURE: Structured handover location recommendations.
 * Returns safe meeting points ranked by proximity to the item's location area.
 * 
 * Fills spec gap HAND-05 and Algorithm Spec 3.5.2.
 */
export const SAFE_HANDOVER_POINTS: SafeHandoverPoint[] = [
  // Cooperative offices
  { id: 1, name: 'RFTC Nyabugogo Office', type: 'COOPERATIVE_OFFICE', address: 'Nyabugogo Bus Terminal', area: 'Nyabugogo', operating_hours: '06:00-20:00', safety_rating: 5 },
  { id: 2, name: 'Kigali Bus Services Kimironko', type: 'COOPERATIVE_OFFICE', address: 'Kimironko Bus Stop', area: 'Kimironko', operating_hours: '06:00-20:00', safety_rating: 5 },
  { id: 3, name: 'Royal Express Remera', type: 'COOPERATIVE_OFFICE', address: 'Remera Bus Station', area: 'Remera', operating_hours: '06:00-19:00', safety_rating: 4 },
  { id: 4, name: 'Volcano Express Downtown', type: 'COOPERATIVE_OFFICE', address: 'KN 4 Ave, City Center', area: 'Nyarugenge', operating_hours: '07:00-18:00', safety_rating: 5 },
  
  // Sector offices
  { id: 10, name: 'Kimironko Sector Office', type: 'SECTOR_OFFICE', address: 'Kimironko, Gasabo District', area: 'Kimironko', operating_hours: '07:00-17:00 Mon-Fri', safety_rating: 5 },
  { id: 11, name: 'Remera Sector Office', type: 'SECTOR_OFFICE', address: 'Remera, Gasabo District', area: 'Remera', operating_hours: '07:00-17:00 Mon-Fri', safety_rating: 5 },
  { id: 12, name: 'Nyamirambo Sector Office', type: 'SECTOR_OFFICE', address: 'Nyamirambo, Nyarugenge District', area: 'Nyamirambo', operating_hours: '07:00-17:00 Mon-Fri', safety_rating: 5 },
  { id: 13, name: 'Kicukiro Sector Office', type: 'SECTOR_OFFICE', address: 'Kicukiro Center', area: 'Kicukiro', operating_hours: '07:00-17:00 Mon-Fri', safety_rating: 5 },
  
  // Police posts
  { id: 20, name: 'Remera Police Station', type: 'POLICE_POST', address: 'KG 11 Ave, Remera', area: 'Remera', operating_hours: '24/7', safety_rating: 5 },
  { id: 21, name: 'Kacyiru Police Station', type: 'POLICE_POST', address: 'Kacyiru, Gasabo District', area: 'Kacyiru', operating_hours: '24/7', safety_rating: 5 },
  { id: 22, name: 'Nyarugenge Police Station', type: 'POLICE_POST', address: 'City Center', area: 'Nyarugenge', operating_hours: '24/7', safety_rating: 5 },
  
  // Transit hubs
  { id: 30, name: 'Nyabugogo Bus Terminal', type: 'TRANSIT_HUB', address: 'Nyabugogo Main Terminal', area: 'Nyabugogo', operating_hours: '05:00-21:00', safety_rating: 4 },
  { id: 31, name: 'Kigali Bus Terminal (Downtown)', type: 'TRANSIT_HUB', address: 'KN 2 Ave, Nyarugenge', area: 'Nyarugenge', operating_hours: '05:30-20:30', safety_rating: 4 },
  { id: 32, name: 'Kimironko Market Area', type: 'TRANSIT_HUB', address: 'Kimironko Commercial Center', area: 'Kimironko', operating_hours: '06:00-19:00', safety_rating: 3 },
];

export function recommendHandoverLocations(
  itemLocationArea: string,
  itemCategory: string
): SafeHandoverPoint[] {
  const areaLower = itemLocationArea.toLowerCase();
  
  // Score each location by proximity and appropriateness
  const scored = SAFE_HANDOVER_POINTS.map(point => {
    let score = 0;
    
    // Same area = highest score
    if (point.area.toLowerCase() === areaLower) score += 10;
    // Same district area
    else if (isAdjacent(point.area, itemLocationArea)) score += 5;
    
    // For sensitive items (ID, WALLET, PHONE), prefer official locations
    if (['ID', 'WALLET', 'PHONE'].includes(itemCategory)) {
      if (point.type === 'COOPERATIVE_OFFICE' || point.type === 'SECTOR_OFFICE') score += 3;
      if (point.type === 'POLICE_POST') score += 2;
    }
    
    // Safety rating bonus
    score += point.safety_rating;
    
    return { ...point, _score: score };
  });

  // Sort by score descending, return top 5
  scored.sort((a, b) => b._score - a._score);
  return scored.slice(0, 5).map(({ _score, ...point }) => point);
}

function isAdjacent(area1: string, area2: string): boolean {
  const adjacency: Record<string, string[]> = {
    'nyabugogo': ['nyarugenge', 'gitega', 'muhima'],
    'kimironko': ['remera', 'kibagabaga', 'gisozi'],
    'remera': ['kimironko', 'kacyiru', 'gisozi'],
    'kacyiru': ['remera', 'kimihurura', 'nyarutarama'],
    'nyamirambo': ['nyarugenge', 'biryogo', 'rwezamenyo'],
    'kicukiro': ['gatenga', 'gikondo', 'kanombe'],
    'nyarugenge': ['nyabugogo', 'nyamirambo', 'muhima', 'kacyiru'],
  };
  const a1 = area1.toLowerCase();
  const a2 = area2.toLowerCase();
  return adjacency[a1]?.includes(a2) || adjacency[a2]?.includes(a1) || false;
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/disputeService.ts
‚îÇ Language: TypeScript | Lines: 458 | Size: 12.6 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Dispute Service for Byaboneka+
 * 
 * Implements CLAIM-07: Dispute mechanism for edge cases
 * Allows users to dispute claims when verification fails despite ownership,
 * or when there are issues with the handover process.
 */

import { query, transaction } from '../config/database';
import { logAudit, extractRequestMeta } from './auditService';
import { updateTrustScore } from './trustService';
import { Request } from 'express';

export type DisputeStatus = 'OPEN' | 'UNDER_REVIEW' | 'RESOLVED_OWNER' | 'RESOLVED_FINDER' | 'DISMISSED';

export interface Dispute {
  id: number;
  claim_id: number;
  initiated_by: number;
  reason: string;
  evidence_urls: string[];
  status: DisputeStatus;
  admin_notes: string | null;
  resolved_by: number | null;
  resolved_at: Date | null;
  created_at: Date;
  updated_at: Date;
}

export interface DisputeCreationResult {
  success: boolean;
  dispute?: Dispute;
  message: string;
}

export interface DisputeResolutionResult {
  success: boolean;
  message: string;
  trustAdjustments?: {
    ownerId: number;
    ownerAdjustment: number;
    finderId: number;
    finderAdjustment: number;
  };
}

/**
 * Open a dispute for a claim
 * Can be initiated by either the claimant (owner) or the finder
 */
export async function openDispute(
  claimId: number,
  userId: number,
  reason: string,
  evidenceUrls: string[] = [],
  req?: Request
): Promise<DisputeCreationResult> {
  // Get claim details
  const claimResult = await query(
    `SELECT c.*, li.user_id as lost_item_owner, fi.finder_id
     FROM claims c
     JOIN lost_items li ON c.lost_item_id = li.id
     JOIN found_items fi ON c.found_item_id = fi.id
     WHERE c.id = $1`,
    [claimId]
  );
  
  if (claimResult.rows.length === 0) {
    return { success: false, message: 'Claim not found' };
  }
  
  const claim = claimResult.rows[0];
  
  // Check if user is a participant
  const isOwner = claim.claimant_id === userId || claim.lost_item_owner === userId;
  const isFinder = claim.finder_id === userId;
  
  if (!isOwner && !isFinder) {
    return { success: false, message: 'Only claim participants can open a dispute' };
  }
  
  // Check claim status - can dispute PENDING, VERIFIED, or REJECTED claims
  const validStatuses = ['PENDING', 'VERIFIED', 'REJECTED'];
  if (!validStatuses.includes(claim.status)) {
    return { 
      success: false, 
      message: `Cannot dispute a claim with status '${claim.status}'. Only pending, verified, or rejected claims can be disputed.` 
    };
  }
  
  // Check if dispute already exists
  const existingDispute = await query(
    'SELECT id, status FROM claim_disputes WHERE claim_id = $1',
    [claimId]
  );
  
  if (existingDispute.rows.length > 0) {
    const existing = existingDispute.rows[0];
    if (['OPEN', 'UNDER_REVIEW'].includes(existing.status)) {
      return { success: false, message: 'A dispute is already open for this claim' };
    }
  }
  
  // Create dispute
  const disputeResult = await query(
    `INSERT INTO claim_disputes (claim_id, initiated_by, reason, evidence_urls)
     VALUES ($1, $2, $3, $4)
     RETURNING *`,
    [claimId, userId, reason, evidenceUrls]
  );
  
  // Update claim status to DISPUTED
  await query(
    `UPDATE claims SET status = 'DISPUTED' WHERE id = $1`,
    [claimId]
  );
  
  // Log dispute creation
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : {};
  await logAudit({
    actorId: userId,
    action: 'DISPUTE_OPENED',
    resourceType: 'claim_dispute',
    resourceId: disputeResult.rows[0].id,
    changes: { claim_id: claimId, reason: reason.substring(0, 100) },
    ipAddress,
    userAgent
  });
  
  return {
    success: true,
    dispute: disputeResult.rows[0],
    message: 'Dispute opened successfully. An administrator will review your case.'
  };
}

/**
 * Get dispute details
 */
export async function getDispute(disputeId: number): Promise<Dispute | null> {
  const result = await query(
    'SELECT * FROM claim_disputes WHERE id = $1',
    [disputeId]
  );
  
  return result.rows.length > 0 ? result.rows[0] : null;
}

/**
 * Get dispute by claim ID
 */
export async function getDisputeByClaimId(claimId: number): Promise<Dispute | null> {
  const result = await query(
    'SELECT * FROM claim_disputes WHERE claim_id = $1 ORDER BY created_at DESC LIMIT 1',
    [claimId]
  );
  
  return result.rows.length > 0 ? result.rows[0] : null;
}

/**
 * Update dispute status (admin only)
 */
export async function updateDisputeStatus(
  disputeId: number,
  adminId: number,
  newStatus: 'UNDER_REVIEW',
  notes?: string,
  req?: Request
): Promise<{ success: boolean; message: string }> {
  const result = await query(
    `UPDATE claim_disputes 
     SET status = $1, admin_notes = COALESCE($2, admin_notes), updated_at = NOW()
     WHERE id = $3
     RETURNING *`,
    [newStatus, notes, disputeId]
  );
  
  if (result.rows.length === 0) {
    return { success: false, message: 'Dispute not found' };
  }
  
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : {};
  await logAudit({
    actorId: adminId,
    action: 'DISPUTE_UPDATED',
    resourceType: 'claim_dispute',
    resourceId: disputeId,
    changes: { status: newStatus },
    ipAddress,
    userAgent
  });
  
  return { success: true, message: `Dispute status updated to ${newStatus}` };
}

/**
 * Resolve a dispute (admin only)
 * This is a critical function that:
 * 1. Updates the dispute status
 * 2. Updates the claim status based on resolution
 * 3. Adjusts trust scores accordingly
 */
export async function resolveDispute(
  disputeId: number,
  adminId: number,
  resolution: 'RESOLVED_OWNER' | 'RESOLVED_FINDER' | 'DISMISSED',
  resolutionNotes: string,
  req?: Request
): Promise<DisputeResolutionResult> {
  // Get dispute with claim details
  const disputeResult = await query(
    `SELECT d.*, c.claimant_id, c.lost_item_id, c.found_item_id,
            li.user_id as lost_item_owner, fi.finder_id
     FROM claim_disputes d
     JOIN claims c ON d.claim_id = c.id
     JOIN lost_items li ON c.lost_item_id = li.id
     JOIN found_items fi ON c.found_item_id = fi.id
     WHERE d.id = $1`,
    [disputeId]
  );
  
  if (disputeResult.rows.length === 0) {
    return { success: false, message: 'Dispute not found' };
  }
  
  const dispute = disputeResult.rows[0];
  
  // Cannot resolve already resolved disputes
  if (['RESOLVED_OWNER', 'RESOLVED_FINDER', 'DISMISSED'].includes(dispute.status)) {
    return { success: false, message: 'This dispute has already been resolved' };
  }
  
  const ownerId = dispute.claimant_id;
  const finderId = dispute.finder_id;
  
  let ownerAdjustment = 0;
  let finderAdjustment = 0;
  let newClaimStatus = 'DISPUTED';
  
  await transaction(async (client) => {
    // Update dispute
    await client.query(
      `UPDATE claim_disputes 
       SET status = $1, resolved_by = $2, resolved_at = NOW(), 
           admin_notes = $3, updated_at = NOW()
       WHERE id = $4`,
      [resolution, adminId, resolutionNotes, disputeId]
    );
    
    // Determine outcomes based on resolution
    switch (resolution) {
      case 'RESOLVED_OWNER':
        // Owner was right - they get the item
        newClaimStatus = 'VERIFIED';
        ownerAdjustment = 10; // Trust bonus for legitimate dispute
        
        // If dispute was initiated by finder, they might get a penalty
        if (dispute.initiated_by === finderId) {
          finderAdjustment = -5; // Minor penalty for wrongly disputing
        }
        break;
        
      case 'RESOLVED_FINDER':
        // Finder was right - claim rejected
        newClaimStatus = 'REJECTED';
        finderAdjustment = 5; // Small bonus for reporting fraud
        
        // Claimant was trying to claim something not theirs
        ownerAdjustment = -15; // Significant penalty for false claim
        break;
        
      case 'DISMISSED':
        // Dispute was frivolous or inconclusive - revert to previous state
        newClaimStatus = 'PENDING';
        // Small penalty for whoever opened frivolous dispute
        if (dispute.initiated_by === ownerId) {
          ownerAdjustment = -5;
        } else {
          finderAdjustment = -5;
        }
        break;
    }
    
    // Update claim status
    await client.query(
      `UPDATE claims SET status = $1 WHERE id = $2`,
      [newClaimStatus, dispute.claim_id]
    );
    
    // Update item statuses if needed
    if (resolution === 'RESOLVED_OWNER') {
      // Treat as verified claim
      await client.query(
        `UPDATE found_items SET status = 'MATCHED' WHERE id = $1`,
        [dispute.found_item_id]
      );
      await client.query(
        `UPDATE lost_items SET status = 'CLAIMED' WHERE id = $1`,
        [dispute.lost_item_id]
      );
    } else if (resolution === 'RESOLVED_FINDER') {
      // Reset items to available
      await client.query(
        `UPDATE found_items SET status = 'UNCLAIMED' WHERE id = $1`,
        [dispute.found_item_id]
      );
      await client.query(
        `UPDATE lost_items SET status = 'ACTIVE' WHERE id = $1`,
        [dispute.lost_item_id]
      );
    }
  });
  
// Apply trust adjustments (outside transaction for safety)
if (ownerAdjustment !== 0) {
  await updateTrustScore(
    req ?? null,
    ownerId,
    ownerAdjustment,
    `Dispute resolution: ${resolution}`
  );
}

if (finderAdjustment !== 0) {
  await updateTrustScore(
    req ?? null,
    finderId,
    finderAdjustment,
    `Dispute resolution: ${resolution}`
  );
}

  
  // Log resolution
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : {};
  await logAudit({
    actorId: adminId,
    action: 'DISPUTE_RESOLVED',
    resourceType: 'claim_dispute',
    resourceId: disputeId,
    changes: {
      resolution,
      new_claim_status: newClaimStatus,
      owner_trust_adjustment: ownerAdjustment,
      finder_trust_adjustment: finderAdjustment
    },
    ipAddress,
    userAgent
  });
  
  return {
    success: true,
    message: `Dispute resolved: ${resolution}. Trust scores adjusted accordingly.`,
    trustAdjustments: {
      ownerId,
      ownerAdjustment,
      finderId,
      finderAdjustment
    }
  };
}

/**
 * Get all disputes for admin review
 */
export async function getDisputesForReview(
  status?: DisputeStatus,
  page: number = 1,
  limit: number = 20
): Promise<{ disputes: any[]; total: number }> {
  const offset = (page - 1) * limit;
  
  let whereClause = '';
  const params: any[] = [];
  let paramIndex = 1;
  
  if (status) {
    whereClause = `WHERE d.status = $${paramIndex++}`;
    params.push(status);
  }
  
  const countResult = await query(
    `SELECT COUNT(*) FROM claim_disputes d ${whereClause}`,
    params
  );
  
  const result = await query(
    `SELECT d.*, 
            c.status as claim_status,
            initiator.name as initiator_name, initiator.email as initiator_email,
            owner.name as owner_name, owner.email as owner_email,
            finder.name as finder_name, finder.email as finder_email,
            li.title as lost_item_title, li.category,
            fi.title as found_item_title
     FROM claim_disputes d
     JOIN claims c ON d.claim_id = c.id
     JOIN users initiator ON d.initiated_by = initiator.id
     JOIN lost_items li ON c.lost_item_id = li.id
     JOIN found_items fi ON c.found_item_id = fi.id
     JOIN users owner ON li.user_id = owner.id
     JOIN users finder ON fi.finder_id = finder.id
     ${whereClause}
     ORDER BY d.created_at DESC
     LIMIT $${paramIndex++} OFFSET $${paramIndex++}`,
    [...params, limit, offset]
  );
  
  return {
    disputes: result.rows,
    total: parseInt(countResult.rows[0].count)
  };
}

/**
 * Add evidence to an existing dispute
 */
export async function addDisputeEvidence(
  disputeId: number,
  userId: number,
  evidenceUrls: string[]
): Promise<{ success: boolean; message: string }> {
  // Verify user is a participant
  const disputeResult = await query(
    `SELECT d.*, c.claimant_id, fi.finder_id
     FROM claim_disputes d
     JOIN claims c ON d.claim_id = c.id
     JOIN found_items fi ON c.found_item_id = fi.id
     WHERE d.id = $1`,
    [disputeId]
  );
  
  if (disputeResult.rows.length === 0) {
    return { success: false, message: 'Dispute not found' };
  }
  
  const dispute = disputeResult.rows[0];
  
  if (dispute.claimant_id !== userId && dispute.finder_id !== userId) {
    return { success: false, message: 'Only dispute participants can add evidence' };
  }
  
  // Can only add evidence to open disputes
  if (!['OPEN', 'UNDER_REVIEW'].includes(dispute.status)) {
    return { success: false, message: 'Cannot add evidence to a resolved dispute' };
  }
  
  // Append new evidence URLs
  await query(
    `UPDATE claim_disputes 
     SET evidence_urls = evidence_urls || $1, updated_at = NOW()
     WHERE id = $2`,
    [evidenceUrls, disputeId]
  );
  
  return { success: true, message: 'Evidence added successfully' };
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/duplicateDetectionService.ts
‚îÇ Language: TypeScript | Lines: 343 | Size: 10.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Duplicate Detection Service for Byaboneka+
 * 
 * Implements SYS-05: Duplicate detection for similar reports
 * Uses fuzzy matching to identify potentially duplicate reports
 */

import { query } from '../config/database';
import { ItemCategory } from '../types';

interface DuplicateCandidate {
  id: number;
  type: 'lost' | 'found';
  title: string;
  description: string;
  category: string;
  location_area: string;
  date: Date;
  similarity_score: number;
  similarity_reasons: string[];
}

interface DuplicateCheckResult {
  hasPotentialDuplicates: boolean;
  candidates: DuplicateCandidate[];
  highestScore: number;
}

// Similarity thresholds
const SAME_CATEGORY_SCORE = 5;
const SAME_LOCATION_SCORE = 3;
const SIMILAR_LOCATION_SCORE = 1;
const DATE_WITHIN_3_DAYS = 2;
const DATE_WITHIN_7_DAYS = 1;
const KEYWORD_MATCH_SCORE = 1;
const TITLE_SIMILARITY_THRESHOLD = 0.6;
const DUPLICATE_THRESHOLD = 8; // Minimum score to flag as potential duplicate

/**
 * Calculate Jaccard similarity between two strings (based on words)
 */
function calculateTextSimilarity(text1: string, text2: string): number {
  if (!text1 || !text2) return 0;
  
  const normalize = (s: string) => s.toLowerCase()
    .replace(/[^\w\s]/g, '')
    .split(/\s+/)
    .filter(w => w.length > 2);
  
  const words1 = new Set(normalize(text1));
  const words2 = new Set(normalize(text2));
  
  if (words1.size === 0 || words2.size === 0) return 0;
  
  const intersection = new Set([...words1].filter(w => words2.has(w)));
  const union = new Set([...words1, ...words2]);
  
  return intersection.size / union.size;
}

/**
 * Calculate days between two dates
 */
function daysBetween(date1: Date, date2: Date): number {
  const d1 = new Date(date1);
  const d2 = new Date(date2);
  const diffTime = Math.abs(d2.getTime() - d1.getTime());
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * Check for duplicate lost items
 */
export async function checkDuplicateLostItems(
  userId: number,
  category: ItemCategory,
  title: string,
  description: string,
  locationArea: string,
  lostDate: Date
): Promise<DuplicateCheckResult> {
  // Get recent active lost items in the same category
  const result = await query(
    `SELECT id, category, title, description, location_area, lost_date, keywords
     FROM lost_items
     WHERE user_id = $1 
     AND category = $2
     AND status = 'ACTIVE'
     AND created_at > NOW() - INTERVAL '30 days'
     ORDER BY created_at DESC
     LIMIT 20`,
    [userId, category]
  );
  
  const candidates: DuplicateCandidate[] = [];
  
  for (const item of result.rows) {
    let score = 0;
    const reasons: string[] = [];
    
    // Category match (already filtered, but include in score)
    score += SAME_CATEGORY_SCORE;
    reasons.push(`Same category: ${category}`);
    
    // Location comparison
    const locationSimilarity = calculateTextSimilarity(locationArea, item.location_area);
    if (locationArea.toLowerCase() === item.location_area.toLowerCase()) {
      score += SAME_LOCATION_SCORE;
      reasons.push(`Same location: ${locationArea}`);
    } else if (locationSimilarity > 0.5) {
      score += SIMILAR_LOCATION_SCORE;
      reasons.push(`Similar location`);
    }
    
    // Date proximity
    const days = daysBetween(lostDate, item.lost_date);
    if (days <= 3) {
      score += DATE_WITHIN_3_DAYS;
      reasons.push(`Lost within 3 days of each other`);
    } else if (days <= 7) {
      score += DATE_WITHIN_7_DAYS;
      reasons.push(`Lost within 7 days of each other`);
    }
    
    // Title similarity
    const titleSimilarity = calculateTextSimilarity(title, item.title);
    if (titleSimilarity > TITLE_SIMILARITY_THRESHOLD) {
      score += Math.round(titleSimilarity * 3);
      reasons.push(`Similar title (${Math.round(titleSimilarity * 100)}% match)`);
    }
    
    // Description similarity
    const descSimilarity = calculateTextSimilarity(description, item.description);
    if (descSimilarity > 0.4) {
      score += Math.round(descSimilarity * 2);
      reasons.push(`Similar description`);
    }
    
    if (score >= DUPLICATE_THRESHOLD) {
      candidates.push({
        id: item.id,
        type: 'lost',
        title: item.title,
        description: item.description.substring(0, 100) + '...',
        category: item.category,
        location_area: item.location_area,
        date: item.lost_date,
        similarity_score: score,
        similarity_reasons: reasons
      });
    }
  }
  
  // Sort by score descending
  candidates.sort((a, b) => b.similarity_score - a.similarity_score);
  
  return {
    hasPotentialDuplicates: candidates.length > 0,
    candidates: candidates.slice(0, 5), // Return top 5
    highestScore: candidates[0]?.similarity_score || 0
  };
}

/**
 * Check for duplicate found items
 */
export async function checkDuplicateFoundItems(
  finderId: number,
  category: ItemCategory,
  title: string,
  description: string,
  locationArea: string,
  foundDate: Date
): Promise<DuplicateCheckResult> {
  // Get recent unclaimed found items in the same category
  const result = await query(
    `SELECT id, category, title, description, location_area, found_date, keywords
     FROM found_items
     WHERE finder_id = $1 
     AND category = $2
     AND status = 'UNCLAIMED'
     AND created_at > NOW() - INTERVAL '30 days'
     ORDER BY created_at DESC
     LIMIT 20`,
    [finderId, category]
  );
  
  const candidates: DuplicateCandidate[] = [];
  
  for (const item of result.rows) {
    let score = 0;
    const reasons: string[] = [];
    
    score += SAME_CATEGORY_SCORE;
    reasons.push(`Same category: ${category}`);
    
    const locationSimilarity = calculateTextSimilarity(locationArea, item.location_area);
    if (locationArea.toLowerCase() === item.location_area.toLowerCase()) {
      score += SAME_LOCATION_SCORE;
      reasons.push(`Same location: ${locationArea}`);
    } else if (locationSimilarity > 0.5) {
      score += SIMILAR_LOCATION_SCORE;
      reasons.push(`Similar location`);
    }
    
    const days = daysBetween(foundDate, item.found_date);
    if (days <= 3) {
      score += DATE_WITHIN_3_DAYS;
      reasons.push(`Found within 3 days of each other`);
    } else if (days <= 7) {
      score += DATE_WITHIN_7_DAYS;
      reasons.push(`Found within 7 days of each other`);
    }
    
    const titleSimilarity = calculateTextSimilarity(title, item.title);
    if (titleSimilarity > TITLE_SIMILARITY_THRESHOLD) {
      score += Math.round(titleSimilarity * 3);
      reasons.push(`Similar title (${Math.round(titleSimilarity * 100)}% match)`);
    }
    
    const descSimilarity = calculateTextSimilarity(description, item.description);
    if (descSimilarity > 0.4) {
      score += Math.round(descSimilarity * 2);
      reasons.push(`Similar description`);
    }
    
    if (score >= DUPLICATE_THRESHOLD) {
      candidates.push({
        id: item.id,
        type: 'found',
        title: item.title,
        description: item.description.substring(0, 100) + '...',
        category: item.category,
        location_area: item.location_area,
        date: item.found_date,
        similarity_score: score,
        similarity_reasons: reasons
      });
    }
  }
  
  candidates.sort((a, b) => b.similarity_score - a.similarity_score);
  
  return {
    hasPotentialDuplicates: candidates.length > 0,
    candidates: candidates.slice(0, 5),
    highestScore: candidates[0]?.similarity_score || 0
  };
}

/**
 * Cross-check if a new lost item matches any existing found items
 * (useful for immediate suggestions)
 */
export async function findPotentialMatchesForNewLostItem(
  category: ItemCategory,
  title: string,
  description: string,
  locationArea: string,
  lostDate: Date
): Promise<DuplicateCandidate[]> {
  const result = await query(
    `SELECT id, category, title, description, location_area, found_date, keywords
     FROM found_items
     WHERE category = $1
     AND status = 'UNCLAIMED'
     AND found_date >= $2 - INTERVAL '7 days'
     AND found_date <= NOW()
     ORDER BY found_date DESC
     LIMIT 50`,
    [category, lostDate]
  );
  
  const candidates: DuplicateCandidate[] = [];
  
  for (const item of result.rows) {
    let score = 0;
    const reasons: string[] = [];
    
    score += SAME_CATEGORY_SCORE;
    reasons.push(`Same category: ${category}`);
    
    const locationSimilarity = calculateTextSimilarity(locationArea, item.location_area);
    if (locationArea.toLowerCase() === item.location_area.toLowerCase()) {
      score += SAME_LOCATION_SCORE;
      reasons.push(`Same location`);
    } else if (locationSimilarity > 0.3) {
      score += SIMILAR_LOCATION_SCORE;
      reasons.push(`Nearby location`);
    }
    
    const titleSimilarity = calculateTextSimilarity(title, item.title);
    if (titleSimilarity > 0.4) {
      score += Math.round(titleSimilarity * 3);
      reasons.push(`Similar item description`);
    }
    
    const descSimilarity = calculateTextSimilarity(description, item.description);
    if (descSimilarity > 0.3) {
      score += Math.round(descSimilarity * 2);
      reasons.push(`Description matches`);
    }
    
    if (score >= 6) {
      candidates.push({
        id: item.id,
        type: 'found',
        title: item.title,
        description: item.description.substring(0, 100) + '...',
        category: item.category,
        location_area: item.location_area,
        date: item.found_date,
        similarity_score: score,
        similarity_reasons: reasons
      });
    }
  }
  
  candidates.sort((a, b) => b.similarity_score - a.similarity_score);
  return candidates.slice(0, 10);
}

/**
 * Record a potential duplicate for admin review
 */
export async function recordPotentialDuplicate(
  originalId: number,
  originalType: 'lost' | 'found',
  duplicateId: number,
  duplicateType: 'lost' | 'found',
  score: number,
  reasons: string[]
): Promise<void> {
  await query(
    `INSERT INTO potential_duplicates 
     (original_item_id, original_item_type, duplicate_item_id, duplicate_item_type, 
      similarity_score, similarity_reasons)
     VALUES ($1, $2, $3, $4, $5, $6)
     ON CONFLICT DO NOTHING`,
    [originalId, originalType, duplicateId, duplicateType, score, reasons]
  );
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/emailVerificationService.ts
‚îÇ Language: TypeScript | Lines: 188 | Size: 4.6 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Email Verification Service for Byaboneka+
 * 
 * Implements AUTH-01: Email verification requirement
 */

import crypto from 'crypto';
import bcrypt from 'bcryptjs';
import { query } from '../config/database';
import { logAudit, extractRequestMeta } from './auditService';
import { Request } from 'express';

const TOKEN_LENGTH = 32;
const TOKEN_VALIDITY_HOURS = 24;
const SALT_ROUNDS = 10;

export interface VerificationResult {
  success: boolean;
  message: string;
  verified?: boolean;
}

export interface TokenGenerationResult {
  success: boolean;
  token?: string;
  expiresAt?: Date;
  message: string;
}

function generateToken(): string {
  return crypto.randomBytes(TOKEN_LENGTH).toString('hex');
}

export async function generateEmailVerificationToken(
  userId: number,
  req?: Request
): Promise<TokenGenerationResult> {
  const userResult = await query(
    'SELECT id, email, email_verified FROM users WHERE id = $1',
    [userId]
  );
  
  if (userResult.rows.length === 0) {
    return { success: false, message: 'User not found' };
  }
  
  const user = userResult.rows[0];
  
  if (user.email_verified) {
    return { success: false, message: 'Email is already verified' };
  }
  
  await query(
    'DELETE FROM email_verification_tokens WHERE user_id = $1',
    [userId]
  );
  
  const token = generateToken();
  const tokenHash = await bcrypt.hash(token, SALT_ROUNDS);
  const expiresAt = new Date(Date.now() + TOKEN_VALIDITY_HOURS * 60 * 60 * 1000);
  
  await query(
    `INSERT INTO email_verification_tokens (user_id, token_hash, expires_at)
     VALUES ($1, $2, $3)`,
    [userId, tokenHash, expiresAt]
  );
  
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : { ipAddress: undefined, userAgent: undefined };
  await logAudit({
    actorId: userId,
    action: 'EMAIL_VERIFICATION_REQUESTED',
    resourceType: 'user',
    resourceId: userId,
    changes: { expires_at: expiresAt.toISOString() },
    ipAddress,
    userAgent
  });
  
  console.log(`[EMAIL] Verification token for user ${userId}: ${token}`);
  
  return {
    success: true,
    token,
    expiresAt,
    message: 'Verification email sent. Please check your inbox.'
  };
}

export async function verifyEmail(
  userId: number,
  token: string,
  req?: Request
): Promise<VerificationResult> {
  const tokenResult = await query(
    `SELECT * FROM email_verification_tokens 
     WHERE user_id = $1 AND used_at IS NULL
     ORDER BY created_at DESC LIMIT 1`,
    [userId]
  );
  
  if (tokenResult.rows.length === 0) {
    return { 
      success: false, 
      message: 'No verification token found. Please request a new one.' 
    };
  }
  
  const storedToken = tokenResult.rows[0];
  
  if (new Date(storedToken.expires_at) < new Date()) {
    return { 
      success: false, 
      message: 'Verification token has expired. Please request a new one.' 
    };
  }
  
  const isValid = await bcrypt.compare(token, storedToken.token_hash);
  
  if (!isValid) {
    return { success: false, message: 'Invalid verification token' };
  }
  
  await query(
    `UPDATE email_verification_tokens SET used_at = NOW() WHERE id = $1`,
    [storedToken.id]
  );
  
  await query(
    `UPDATE users SET email_verified = TRUE WHERE id = $1`,
    [userId]
  );
  
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : { ipAddress: undefined, userAgent: undefined };
  await logAudit({
    actorId: userId,
    action: 'EMAIL_VERIFIED',
    resourceType: 'user',
    resourceId: userId,
    changes: { email_verified: true },
    ipAddress,
    userAgent
  });
  
  return {
    success: true,
    verified: true,
    message: 'Email verified successfully!'
  };
}

export async function isEmailVerified(userId: number): Promise<boolean> {
  const result = await query(
    'SELECT email_verified FROM users WHERE id = $1',
    [userId]
  );
  
  return result.rows.length > 0 && result.rows[0].email_verified === true;
}

export async function resendVerificationEmail(
  userId: number,
  req?: Request
): Promise<TokenGenerationResult> {
  const recentTokens = await query(
    `SELECT COUNT(*) FROM email_verification_tokens 
     WHERE user_id = $1 AND created_at > NOW() - INTERVAL '1 hour'`,
    [userId]
  );
  
  if (parseInt(recentTokens.rows[0].count) >= 3) {
    return { 
      success: false, 
      message: 'Too many verification requests. Please try again later.' 
    };
  }
  
  return generateEmailVerificationToken(userId, req);
}

export async function cleanupExpiredTokens(): Promise<number> {
  const result = await query(
    `DELETE FROM email_verification_tokens 
     WHERE expires_at < NOW() - INTERVAL '7 days'
     RETURNING id`
  );
  
  return result.rowCount || 0;
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/expiryService.ts
‚îÇ Language: TypeScript | Lines: 210 | Size: 5.9 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query, transaction } from '../config/database';
import { logAudit } from './auditService';
import { clearStaleMatches } from './matchingService';

// ============================================
// AUTO-EXPIRY SERVICE
// Handles automatic expiration of stale reports
// ============================================

const EXPIRY_DAYS = 30; // Items expire after 30 days of inactivity
const WARNING_DAYS = 25; // Warn owners 5 days before expiry

// Expire old lost items
export async function expireLostItems(): Promise<{ expired: number; warned: number }> {
  let expired = 0;
  let warned = 0;

  // Find items to expire
  const toExpire = await query(
    `SELECT id, user_id, title FROM lost_items
     WHERE status = 'ACTIVE'
     AND created_at < NOW() - INTERVAL '${EXPIRY_DAYS} days'`
  );

  for (const item of toExpire.rows) {
    await query(
      `UPDATE lost_items SET status = 'EXPIRED', expired_at = NOW() WHERE id = $1`,
      [item.id]
    );
    
    // Log expiry
    await query(
      `INSERT INTO audit_logs (actor_id, action, resource_type, resource_id, changes)
       VALUES (NULL, 'AUTO_EXPIRED', 'lost_item', $1, $2)`,
      [item.id, JSON.stringify({ reason: 'inactivity', title: item.title })]
    );
    
    expired++;
  }

  // Find items to warn
  const toWarn = await query(
    `SELECT id, user_id, title FROM lost_items
     WHERE status = 'ACTIVE'
     AND expiry_warning_sent = FALSE
     AND created_at < NOW() - INTERVAL '${WARNING_DAYS} days'
     AND created_at >= NOW() - INTERVAL '${EXPIRY_DAYS} days'`
  );

  for (const item of toWarn.rows) {
    await query(
      `UPDATE lost_items SET expiry_warning_sent = TRUE WHERE id = $1`,
      [item.id]
    );
    
    // In production, send email notification here
    warned++;
  }

  return { expired, warned };
}

// Expire old found items
export async function expireFoundItems(): Promise<{ expired: number; warned: number }> {
  let expired = 0;
  let warned = 0;

  // Find items to expire
  const toExpire = await query(
    `SELECT id, finder_id, title FROM found_items
     WHERE status IN ('UNCLAIMED', 'MATCHED')
     AND created_at < NOW() - INTERVAL '${EXPIRY_DAYS} days'`
  );

  for (const item of toExpire.rows) {
    await query(
      `UPDATE found_items SET status = 'EXPIRED', expired_at = NOW() WHERE id = $1`,
      [item.id]
    );
    
    await query(
      `INSERT INTO audit_logs (actor_id, action, resource_type, resource_id, changes)
       VALUES (NULL, 'AUTO_EXPIRED', 'found_item', $1, $2)`,
      [item.id, JSON.stringify({ reason: 'inactivity', title: item.title })]
    );
    
    expired++;
  }

  // Find items to warn
  const toWarn = await query(
    `SELECT id, finder_id, title FROM found_items
     WHERE status IN ('UNCLAIMED', 'MATCHED')
     AND expiry_warning_sent = FALSE
     AND created_at < NOW() - INTERVAL '${WARNING_DAYS} days'
     AND created_at >= NOW() - INTERVAL '${EXPIRY_DAYS} days'`
  );

  for (const item of toWarn.rows) {
    await query(
      `UPDATE found_items SET expiry_warning_sent = TRUE WHERE id = $1`,
      [item.id]
    );
    
    warned++;
  }

  return { expired, warned };
}

// Expire stale claims
export async function expireStaleClaims(): Promise<number> {
  const result = await query(
    `UPDATE claims SET status = 'EXPIRED'
     WHERE status = 'PENDING'
     AND created_at < NOW() - INTERVAL '7 days'
     RETURNING id`
  );
  
  return result.rowCount || 0;
}

// Revoke expired OTPs (cleanup only, validation already checks expiry)
export async function cleanupExpiredOTPs(): Promise<number> {
  const result = await query(
    `DELETE FROM handover_confirmations
     WHERE otp_expires_at < NOW() - INTERVAL '7 days'
     AND otp_verified = FALSE
     RETURNING id`
  );
  
  return result.rowCount || 0;
}

// Clean up old audit logs (keep 90 days)
export async function cleanupOldAuditLogs(): Promise<number> {
  const result = await query(
    `DELETE FROM audit_logs
     WHERE timestamp < NOW() - INTERVAL '90 days'
     RETURNING id`
  );
  
  return result.rowCount || 0;
}

// Clean up expired tokens
export async function cleanupExpiredTokens(): Promise<{ refresh: number; reset: number }> {
  const refreshResult = await query(
    `DELETE FROM refresh_tokens
     WHERE expires_at < NOW()
     RETURNING id`
  );
  
  const resetResult = await query(
    `DELETE FROM password_reset_tokens
     WHERE expires_at < NOW()
     RETURNING id`
  );
  
  return {
    refresh: refreshResult.rowCount || 0,
    reset: resetResult.rowCount || 0
  };
}

// Main cleanup job - run daily
export async function runDailyCleanup(): Promise<void> {
  console.log('üßπ Starting daily cleanup job...');
  
  try {
    const lostExpiry = await expireLostItems();
    console.log(`  Lost items: ${lostExpiry.expired} expired, ${lostExpiry.warned} warned`);
    
    const foundExpiry = await expireFoundItems();
    console.log(`  Found items: ${foundExpiry.expired} expired, ${foundExpiry.warned} warned`);
    
    const staleClaims = await expireStaleClaims();
    console.log(`  Stale claims expired: ${staleClaims}`);
    
    const staleMatches = await clearStaleMatches();
    console.log(`  Stale matches cleared: ${staleMatches}`);
    
    const expiredOTPs = await cleanupExpiredOTPs();
    console.log(`  Expired OTPs cleaned: ${expiredOTPs}`);
    
    const tokens = await cleanupExpiredTokens();
    console.log(`  Expired tokens cleaned: ${tokens.refresh} refresh, ${tokens.reset} reset`);
    
    // Note: Audit log cleanup is optional, keep for compliance
    // const auditLogs = await cleanupOldAuditLogs();
    // console.log(`  Old audit logs cleaned: ${auditLogs}`);
    
    console.log('‚úÖ Daily cleanup completed successfully');
  } catch (error) {
    console.error('‚ùå Daily cleanup failed:', error);
    throw error;
  }
}

// Export for manual triggering or cron job
export default {
  expireLostItems,
  expireFoundItems,
  expireStaleClaims,
  cleanupExpiredOTPs,
  cleanupExpiredTokens,
  cleanupOldAuditLogs,
  runDailyCleanup
};



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/fraudDetectionService.ts
‚îÇ Language: TypeScript | Lines: 413 | Size: 14.7 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query } from '../config/database';
import { logAudit } from './auditService';

/**
 * ============================================
 * BEHAVIORAL FRAUD FINGERPRINTING ENGINE
 * ============================================
 * 
 * NOVEL FEATURE: No existing lost-and-found platform implements
 * multi-factor behavioral fraud scoring. This applies financial-grade
 * transaction monitoring patterns to a lost-and-found context.
 * 
 * Implements Algorithm Spec section 3.4 (was 100% missing from codebase).
 * 
 * 6-Factor Risk Scoring:
 *   Factor 1: Account age (newer = riskier)
 *   Factor 2: Verification status (unverified = riskier)
 *   Factor 3: Recent failed claims (pattern of suspicious behavior)
 *   Factor 4: IP/device anomalies (new device/IP = riskier)
 *   Factor 5: Behavioral velocity (too many actions too fast)
 *   Factor 6: Trust score trajectory (declining = riskier)
 */

// ============================================
// TYPES
// ============================================

export type RiskLevel = 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';

export interface FraudRiskAssessment {
  score: number;           // 0-100
  level: RiskLevel;
  factors: string[];
  requires_review: boolean;
  should_block: boolean;
  recommendation: string;
}

export type ActionType = 
  | 'CLAIM_CREATE'
  | 'CLAIM_VERIFY' 
  | 'REPORT_CREATE'
  | 'MESSAGE_SEND'
  | 'HANDOVER_OTP';

interface ActionContext {
  user_id: number;
  ip_address?: string;
  user_agent?: string;
  target_id?: number;   // item or claim ID
}

// ============================================
// DETECTION RULES (from Algorithm Spec 3.4.1)
// ============================================

const THRESHOLDS = {
  // Risk score thresholds
  BLOCK: 70,              // Auto-block the action
  REVIEW: 40,             // Flag for admin review
  
  // Behavioral velocity
  CLAIMS_PER_HOUR_LIMIT: 5,
  REPORTS_PER_DAY_LIMIT: 10,
  MESSAGES_PER_HOUR_LIMIT: 50,
  ACTIONS_PER_HOUR_LIMIT: 30,
  
  // Account age risk windows (days)
  VERY_NEW_ACCOUNT: 1,
  NEW_ACCOUNT: 7,
  
  // Failure pattern thresholds
  FAILED_CLAIMS_24H_ALERT: 3,
  FAILED_CLAIMS_CROSS_ITEM_ALERT: 5,
};

// ============================================
// CORE FRAUD RISK CALCULATOR
// ============================================

export async function calculateFraudRisk(
  actionType: ActionType,
  context: ActionContext
): Promise<FraudRiskAssessment> {
  let riskScore = 0;
  const factors: string[] = [];

  try {
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FACTOR 1: Account Age
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const ageResult = await query(
      `SELECT EXTRACT(EPOCH FROM (NOW() - created_at)) / 86400 as age_days
       FROM users WHERE id = $1`,
      [context.user_id]
    );
    
    if (ageResult.rows.length > 0) {
      const ageDays = parseFloat(ageResult.rows[0].age_days);
      if (ageDays < THRESHOLDS.VERY_NEW_ACCOUNT) {
        riskScore += 20;
        factors.push(`Very new account (${Math.round(ageDays * 24)}h old): +20`);
      } else if (ageDays < THRESHOLDS.NEW_ACCOUNT) {
        riskScore += 10;
        factors.push(`New account (${Math.round(ageDays)}d old): +10`);
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FACTOR 2: Verification Status
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const verifyResult = await query(
      `SELECT email_verified, phone_verified FROM users WHERE id = $1`,
      [context.user_id]
    );
    
    if (verifyResult.rows.length > 0) {
      const user = verifyResult.rows[0];
      if (!user.email_verified && !user.phone_verified) {
        riskScore += 15;
        factors.push('No email or phone verified: +15');
      } else if (!user.phone_verified) {
        riskScore += 5;
        factors.push('Phone not verified: +5');
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FACTOR 3: Recent Failed Claims
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const failedResult = await query(
      `SELECT 
         COUNT(*) FILTER (WHERE attempt_status = 'FAILED' AND attempt_at > NOW() - INTERVAL '24 hours') as failed_24h,
         COUNT(DISTINCT claim_id) FILTER (WHERE attempt_status = 'FAILED' AND attempt_at > NOW() - INTERVAL '7 days') as failed_items_7d
       FROM verification_attempts va
       JOIN claims c ON va.claim_id = c.id
       WHERE c.claimant_id = $1`,
      [context.user_id]
    );
    
    if (failedResult.rows.length > 0) {
      const failed24h = parseInt(failedResult.rows[0].failed_24h) || 0;
      const failedItems7d = parseInt(failedResult.rows[0].failed_items_7d) || 0;
      
      // Failed claims in last 24h
      if (failed24h > 0) {
        const failScore = Math.min(failed24h * 10, 30);
        riskScore += failScore;
        factors.push(`${failed24h} failed verification(s) in 24h: +${failScore}`);
      }
      
      // Claim spraying: failed on multiple DIFFERENT items (Algorithm Spec 3.4.1)
      if (failedItems7d >= THRESHOLDS.FAILED_CLAIMS_CROSS_ITEM_ALERT) {
        riskScore += 25;
        factors.push(`Claim spraying: failed on ${failedItems7d} different items in 7d: +25`);
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FACTOR 4: IP Anomalies
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if (context.ip_address) {
      // Check if this IP was used by other accounts recently
      const ipResult = await query(
        `SELECT COUNT(DISTINCT actor_id) as unique_users
         FROM audit_logs
         WHERE ip_address = $1
         AND timestamp > NOW() - INTERVAL '24 hours'
         AND actor_id != $2`,
        [context.ip_address, context.user_id]
      );
      
      const otherUsersOnIP = parseInt(ipResult.rows[0]?.unique_users) || 0;
      if (otherUsersOnIP >= 3) {
        riskScore += 15;
        factors.push(`IP shared with ${otherUsersOnIP} other accounts in 24h: +15`);
      } else if (otherUsersOnIP >= 1) {
        riskScore += 5;
        factors.push(`IP shared with ${otherUsersOnIP} other account(s): +5`);
      }
      
      // Check if this is a new IP for this user
      const knownIPResult = await query(
        `SELECT COUNT(*) as count FROM audit_logs
         WHERE actor_id = $1 AND ip_address = $2
         AND timestamp < NOW() - INTERVAL '1 hour'`,
        [context.user_id, context.ip_address]
      );
      
      if (parseInt(knownIPResult.rows[0]?.count) === 0) {
        riskScore += 5;
        factors.push('First time using this IP address: +5');
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FACTOR 5: Behavioral Velocity
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const velocityResult = await query(
      `SELECT 
         COUNT(*) FILTER (WHERE action IN ('CREATE') AND resource_type = 'claim' AND timestamp > NOW() - INTERVAL '1 hour') as claims_1h,
         COUNT(*) FILTER (WHERE action = 'CREATE' AND resource_type IN ('lost_item', 'found_item') AND timestamp > NOW() - INTERVAL '24 hours') as reports_24h,
         COUNT(*) FILTER (WHERE timestamp > NOW() - INTERVAL '1 hour') as all_actions_1h
       FROM audit_logs
       WHERE actor_id = $1`,
      [context.user_id]
    );
    
    if (velocityResult.rows.length > 0) {
      const v = velocityResult.rows[0];
      const claims1h = parseInt(v.claims_1h) || 0;
      const reports24h = parseInt(v.reports_24h) || 0;
      const allActions1h = parseInt(v.all_actions_1h) || 0;
      
      if (claims1h >= THRESHOLDS.CLAIMS_PER_HOUR_LIMIT) {
        riskScore += 25;
        factors.push(`Claim velocity: ${claims1h} claims in 1 hour: +25`);
      }
      
      if (reports24h >= THRESHOLDS.REPORTS_PER_DAY_LIMIT) {
        riskScore += 20;
        factors.push(`Report flooding: ${reports24h} reports in 24h: +20`);
      }
      
      if (allActions1h >= THRESHOLDS.ACTIONS_PER_HOUR_LIMIT) {
        riskScore += 15;
        factors.push(`High activity velocity: ${allActions1h} actions/hour: +15`);
      }
    }

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // FACTOR 6: Trust Score
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const trustResult = await query(
      `SELECT trust_score FROM users WHERE id = $1`,
      [context.user_id]
    );
    
    if (trustResult.rows.length > 0) {
      const trustScore = parseInt(trustResult.rows[0].trust_score) || 0;
      if (trustScore < -10) {
        riskScore += 20;
        factors.push(`Very low trust score (${trustScore}): +20`);
      } else if (trustScore < 0) {
        const penalty = Math.abs(trustScore) * 2;
        riskScore += Math.min(penalty, 15);
        factors.push(`Negative trust (${trustScore}): +${Math.min(penalty, 15)}`);
      }
    }

  } catch (error) {
    console.error('Fraud risk calculation error:', error);
    // On error, don't block - return low risk
    return {
      score: 0,
      level: 'LOW',
      factors: ['Risk calculation error - defaulting to LOW'],
      requires_review: false,
      should_block: false,
      recommendation: 'Proceed (calculation error)'
    };
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // DETERMINE RISK LEVEL
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const cappedScore = Math.min(riskScore, 100);
  let level: RiskLevel;
  let should_block = false;
  let recommendation = '';

  if (cappedScore >= THRESHOLDS.BLOCK) {
    level = 'CRITICAL';
    should_block = true;
    recommendation = 'Block action and notify admin';
  } else if (cappedScore >= THRESHOLDS.REVIEW) {
    level = 'HIGH';
    should_block = false;
    recommendation = 'Allow but flag for admin review';
  } else if (cappedScore >= 20) {
    level = 'MEDIUM';
    should_block = false;
    recommendation = 'Allow with enhanced monitoring';
  } else {
    level = 'LOW';
    should_block = false;
    recommendation = 'Proceed normally';
  }

  const assessment: FraudRiskAssessment = {
    score: cappedScore,
    level,
    factors,
    requires_review: level === 'HIGH' || level === 'CRITICAL',
    should_block,
    recommendation
  };

  // Log the assessment for audit trail
  if (level !== 'LOW') {
    await logFraudAssessment(context.user_id, actionType, assessment, context.ip_address);
  }

  return assessment;
}

// ============================================
// FRAUD ASSESSMENT LOGGING
// ============================================

async function logFraudAssessment(
  userId: number,
  actionType: ActionType,
  assessment: FraudRiskAssessment,
  ipAddress?: string
): Promise<void> {
  try {
    await logAudit({
      actorId: userId,
      action: 'FRAUD_RISK_ASSESSED',
      resourceType: 'fraud_detection',
      resourceId: userId,
      changes: {
        action_type: actionType,
        risk_score: assessment.score,
        risk_level: assessment.level,
        factors: assessment.factors,
        blocked: assessment.should_block,
        recommendation: assessment.recommendation
      },
      ipAddress: ipAddress || 'unknown',
      userAgent: ''
    });
  } catch (error) {
    console.error('Failed to log fraud assessment:', error);
  }
}

// ============================================
// EXPRESS MIDDLEWARE
// ============================================

import { Request, Response, NextFunction } from 'express';

/**
 * Middleware factory that checks fraud risk before allowing an action.
 * Usage: router.post('/claims', fraudCheck('CLAIM_CREATE'), createClaim);
 */
export function fraudCheck(actionType: ActionType) {
  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    if (!req.user) {
      next();
      return;
    }

    const context: ActionContext = {
      user_id: req.user.userId,
      ip_address: req.ip || req.socket?.remoteAddress,
      user_agent: req.get('User-Agent'),
      target_id: parseInt(req.params.id || req.params.claimId) || undefined
    };

    try {
      const assessment = await calculateFraudRisk(actionType, context);

      // Attach to request for downstream use
      (req as any).fraudAssessment = assessment;

      if (assessment.should_block) {
        res.status(403).json({
          success: false,
          message: 'This action has been temporarily blocked due to unusual activity. Please try again later or contact support.',
          risk_level: assessment.level
        });
        return;
      }

      next();
    } catch (error) {
      // On error, don't block legitimate users
      console.error('Fraud check middleware error:', error);
      next();
    }
  };
}

// ============================================
// ADMIN: GET FLAGGED USERS
// ============================================

export async function getFlaggedUsers(): Promise<any[]> {
  const result = await query(
    `SELECT 
       u.id, u.name, u.email, u.trust_score, u.created_at,
       COUNT(DISTINCT al.id) FILTER (WHERE al.action = 'FRAUD_RISK_ASSESSED' 
         AND (al.changes->>'risk_level')::text IN ('HIGH', 'CRITICAL')
         AND al.timestamp > NOW() - INTERVAL '7 days') as high_risk_events,
       COUNT(DISTINCT va.id) FILTER (WHERE va.attempt_status = 'FAILED' 
         AND va.attempt_at > NOW() - INTERVAL '7 days') as failed_verifications_7d
     FROM users u
     LEFT JOIN audit_logs al ON al.actor_id = u.id
     LEFT JOIN claims c ON c.claimant_id = u.id
     LEFT JOIN verification_attempts va ON va.claim_id = c.id
     GROUP BY u.id
     HAVING COUNT(DISTINCT al.id) FILTER (WHERE al.action = 'FRAUD_RISK_ASSESSED' 
       AND (al.changes->>'risk_level')::text IN ('HIGH', 'CRITICAL')
       AND al.timestamp > NOW() - INTERVAL '7 days') > 0
     ORDER BY high_risk_events DESC
     LIMIT 50`,
    []
  );
  return result.rows;
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/matchingService.ts
‚îÇ Language: TypeScript | Lines: 315 | Size: 9.8 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query } from '../config/database';
import {
  LostItem,
  FoundItem,
  MatchResult,
  ItemCategory
} from '../types';
import {
  extractKeywords,
  computeLocationDistance,
  getHoursDifference
} from '../utils';

// ============================================
// MATCHING ENGINE SERVICE
// Deterministic, Explainable Matching Algorithm
// ============================================

// Matching weights
const WEIGHTS = {
  CATEGORY_MATCH: 5,      // Required - must match
  SAME_LOCATION: 5,       // Same sector/area
  ADJACENT_LOCATION: 3,   // Adjacent sector
  NEARBY_LOCATION: 1,     // Same district
  WITHIN_24H: 3,          // Found within 24 hours
  WITHIN_72H: 2,          // Found within 72 hours
  WITHIN_7D: 1,           // Found within 7 days
  KEYWORD_MATCH: 1,       // Per matching keyword
  SUBCATEGORY_MATCH: 2,   // Additional category specificity
};

const MINIMUM_SCORE = 5;  // Minimum score to show as match
const MAX_MATCHES = 5;    // Maximum matches to return

export interface MatchScore {
  score: number;
  explanation: string[];
}

// Compute match score between a lost item and found item
export function computeMatchScore(lost: LostItem, found: FoundItem): MatchScore {
  let score = 0;
  const explanation: string[] = [];

  // GATE 1: Category MUST match (required)
  if (lost.category !== found.category) {
    return { score: 0, explanation: ['Category mismatch'] };
  }
  score += WEIGHTS.CATEGORY_MATCH;
  explanation.push(`Category match: ${lost.category} (+${WEIGHTS.CATEGORY_MATCH})`);

  // GATE 2: Location proximity
  const distance = computeLocationDistance(lost.location_area, found.location_area);
  if (distance === 0) {
    score += WEIGHTS.SAME_LOCATION;
    explanation.push(`Same location: ${lost.location_area} (+${WEIGHTS.SAME_LOCATION})`);
  } else if (distance === 1) {
    score += WEIGHTS.ADJACENT_LOCATION;
    explanation.push(`Adjacent location (+${WEIGHTS.ADJACENT_LOCATION})`);
  } else if (distance <= 2) {
    score += WEIGHTS.NEARBY_LOCATION;
    explanation.push(`Nearby area (+${WEIGHTS.NEARBY_LOCATION})`);
  }

  // GATE 3: Temporal correlation
  const lostDate = new Date(lost.lost_date);
  const foundDate = new Date(found.found_date);
  const hoursDiff = getHoursDifference(lostDate, foundDate);

  // Found item should be after or around the same time as lost
  if (foundDate >= lostDate || hoursDiff <= 24) {
    if (hoursDiff <= 24) {
      score += WEIGHTS.WITHIN_24H;
      explanation.push(`Within 24 hours (+${WEIGHTS.WITHIN_24H})`);
    } else if (hoursDiff <= 72) {
      score += WEIGHTS.WITHIN_72H;
      explanation.push(`Within 72 hours (+${WEIGHTS.WITHIN_72H})`);
    } else if (hoursDiff <= 168) { // 7 days
      score += WEIGHTS.WITHIN_7D;
      explanation.push(`Within 7 days (+${WEIGHTS.WITHIN_7D})`);
    }
  }

  // GATE 4: Keyword overlap
  const lostKeywords = lost.keywords || extractKeywords(lost.title + ' ' + lost.description);
  const foundKeywords = found.keywords || extractKeywords(found.title + ' ' + found.description);

  const overlappingKeywords = lostKeywords.filter(kw => 
    foundKeywords.some(fkw => fkw.toLowerCase() === kw.toLowerCase())
  );

  for (const keyword of overlappingKeywords.slice(0, 5)) { // Cap at 5 keyword bonuses
    score += WEIGHTS.KEYWORD_MATCH;
    explanation.push(`Keyword: "${keyword}" (+${WEIGHTS.KEYWORD_MATCH})`);
  }

  return { score, explanation };
}

// Find matches for a lost item
export async function findMatchesForLostItem(
  lostItemId: number,
  forceRefresh: boolean = false
): Promise<MatchResult[]> {
  // Check cache first (unless force refresh)
  if (!forceRefresh) {
    // FIX BUG-01: Explicitly alias columns to avoid id collision between matches and found_items
    const cachedResult = await query(
      `SELECT m.score, m.explanation,
              f.id, f.finder_id, f.cooperative_id, f.category,
              f.title, f.description, f.location_area, f.location_hint,
              f.found_date, f.status, f.source, f.image_urls, f.keywords,
              f.expiry_warning_sent, f.expired_at, f.created_at, f.updated_at
       FROM matches m
       JOIN found_items f ON m.found_item_id = f.id
       WHERE m.lost_item_id = $1
       AND m.computed_at > NOW() - INTERVAL '1 hour'
       ORDER BY m.score DESC
       LIMIT $2`,
      [lostItemId, MAX_MATCHES]
    );

    if (cachedResult.rows.length > 0) {
      return cachedResult.rows.map(row => ({
        found_item: {
          id: row.id,
          finder_id: row.finder_id,
          cooperative_id: row.cooperative_id,
          category: row.category,
          title: row.title,
          description: row.description,
          location_area: row.location_area,
          location_hint: row.location_hint,
          found_date: row.found_date,
          status: row.status,
          source: row.source,
          image_urls: row.image_urls,
          keywords: row.keywords,
          expiry_warning_sent: row.expiry_warning_sent,
          expired_at: row.expired_at,
          created_at: row.created_at,
          updated_at: row.updated_at
        },
        score: row.score,
        explanation: row.explanation
      }));
    }
  }

  // Get the lost item
  const lostResult = await query(
    'SELECT * FROM lost_items WHERE id = $1',
    [lostItemId]
  );

  if (lostResult.rows.length === 0) {
    throw new Error('Lost item not found');
  }

  const lostItem = lostResult.rows[0] as LostItem;

  // Get potential found items (same category, unclaimed, recent)
  const foundResult = await query(
    `SELECT * FROM found_items
     WHERE category = $1
     AND status = 'UNCLAIMED'
     AND found_date >= ($2::date - INTERVAL '7 days')
     ORDER BY found_date DESC
     LIMIT 100`,
    [lostItem.category, lostItem.lost_date]
  );

  const foundItems = foundResult.rows as FoundItem[];

  // Compute scores
  const scoredMatches: MatchResult[] = [];

  for (const foundItem of foundItems) {
    const { score, explanation } = computeMatchScore(lostItem, foundItem);

    if (score >= MINIMUM_SCORE) {
      scoredMatches.push({
        found_item: foundItem,
        score,
        explanation
      });
    }
  }

  // Sort by score descending and take top N
  scoredMatches.sort((a, b) => b.score - a.score);
  const topMatches = scoredMatches.slice(0, MAX_MATCHES);

  // Cache results
  await cacheMatches(lostItemId, topMatches);

  return topMatches;
}

// Find matches for a found item (reverse lookup)
export async function findMatchesForFoundItem(
  foundItemId: number,
  forceRefresh: boolean = false
): Promise<{ lost_item: LostItem; score: number; explanation: string[] }[]> {
  // Get the found item
  const foundResult = await query(
    'SELECT * FROM found_items WHERE id = $1',
    [foundItemId]
  );

  if (foundResult.rows.length === 0) {
    throw new Error('Found item not found');
  }

  const foundItem = foundResult.rows[0] as FoundItem;

  // Get potential lost items (same category, active, recent)
  const lostResult = await query(
    `SELECT * FROM lost_items
     WHERE category = $1
     AND status = 'ACTIVE'
     AND lost_date <= ($2::date + INTERVAL '7 days')
     ORDER BY lost_date DESC
     LIMIT 100`,
    [foundItem.category, foundItem.found_date]
  );

  const lostItems = lostResult.rows as LostItem[];

  // Compute scores
  const scoredMatches: { lost_item: LostItem; score: number; explanation: string[] }[] = [];

  for (const lostItem of lostItems) {
    const { score, explanation } = computeMatchScore(lostItem, foundItem);

    if (score >= MINIMUM_SCORE) {
      scoredMatches.push({
        lost_item: lostItem,
        score,
        explanation
      });
    }
  }

  // Sort by score descending and take top N
  scoredMatches.sort((a, b) => b.score - a.score);
  return scoredMatches.slice(0, MAX_MATCHES);
}

// Cache match results
async function cacheMatches(lostItemId: number, matches: MatchResult[]): Promise<void> {
  // Clear old cache for this lost item
  await query('DELETE FROM matches WHERE lost_item_id = $1', [lostItemId]);

  // Insert new matches
  for (const match of matches) {
    await query(
      `INSERT INTO matches (lost_item_id, found_item_id, score, explanation, computed_at)
       VALUES ($1, $2, $3, $4, NOW())
       ON CONFLICT (lost_item_id, found_item_id) 
       DO UPDATE SET score = $3, explanation = $4, computed_at = NOW()`,
      [lostItemId, match.found_item.id, match.score, match.explanation]
    );
  }
}

// Trigger matching when a new item is created
export async function onItemCreated(
  itemType: 'lost' | 'found',
  itemId: number
): Promise<void> {
  try {
    if (itemType === 'lost') {
      // Find matches for the new lost item
      await findMatchesForLostItem(itemId, true);
    } else {
      // For found items, update matches for all potentially matching lost items
      const foundResult = await query(
        'SELECT category, found_date FROM found_items WHERE id = $1',
        [itemId]
      );

      if (foundResult.rows.length > 0) {
        const { category, found_date } = foundResult.rows[0];

        // Get all active lost items in same category
        const lostItems = await query(
          `SELECT id FROM lost_items
           WHERE category = $1
           AND status = 'ACTIVE'
           AND lost_date <= ($2::date + INTERVAL '7 days')`,
          [category, found_date]
        );

        // Refresh matches for each (limited to avoid overload)
        for (const item of lostItems.rows.slice(0, 20)) {
          await findMatchesForLostItem(item.id, true);
        }
      }
    }
  } catch (error) {
    // Don't let matching errors crash the main flow
    console.error(`Matching error for ${itemType} item ${itemId}:`, error);
  }
}

// Clear stale matches
export async function clearStaleMatches(): Promise<number> {
  const result = await query(
    `DELETE FROM matches
     WHERE computed_at < NOW() - INTERVAL '24 hours'
     RETURNING id`
  );
  return result.rowCount || 0;
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/otpService.ts
‚îÇ Language: TypeScript | Lines: 371 | Size: 10.8 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Enhanced OTP Handover Service for Byaboneka+
 * 
 * Implements secure handover OTP requirements:
 * - HAND-01: OTP generation for verified claims only
 * - HAND-02: 24-hour validity
 * - HAND-03: Single-use enforcement
 * - HAND-04: Finder/coop staff enters OTP
 * - HAND-05: Max 3 OTP verification attempts
 * - HAND-06: Status changes only after OTP validation
 * - HAND-07: Comprehensive audit logging
 */

import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import { query, transaction } from '../config/database';
import { logAudit, extractRequestMeta } from './auditService';
import { onSuccessfulReturn } from './trustService';
import { Request } from 'express';

const OTP_LENGTH = 6;
const OTP_VALIDITY_HOURS = 24;
const MAX_OTP_ATTEMPTS = 3;
const SALT_ROUNDS = 10;

export interface OTPGenerationResult {
  success: boolean;
  otp?: string;
  expiresAt?: Date;
  message: string;
}

export interface OTPVerificationResult {
  success: boolean;
  message: string;
  attemptsRemaining?: number;
  handoverCompleted?: boolean;
}

export interface HandoverDetails {
  handoverId: number;
  claimId: number;
  lostItemId: number;
  foundItemId: number;
  ownerId: number;
  finderId: number;
  otpExpiresAt: Date;
  otpVerified: boolean;
  verificationAttempts: number;
}

/**
 * Generate a secure 6-digit OTP
 */
function generateSecureOTP(): string {
  const bytes = crypto.randomBytes(4);
  const num = bytes.readUInt32BE(0) % 1000000;
  return num.toString().padStart(OTP_LENGTH, '0');
}

/**
 * Generate handover OTP for a verified claim
 * Only the item owner (claimant) can generate the OTP
 */
export async function generateHandoverOTP(
  claimId: number,
  userId: number,
  req?: Request
): Promise<OTPGenerationResult> {
  // Verify claim exists and user is the owner
  const claimResult = await query(
    `SELECT c.*, li.user_id as owner_id, fi.finder_id, li.id as lost_item_id, fi.id as found_item_id
     FROM claims c
     JOIN lost_items li ON c.lost_item_id = li.id
     JOIN found_items fi ON c.found_item_id = fi.id
     WHERE c.id = $1`,
    [claimId]
  );
  
  if (claimResult.rows.length === 0) {
    return { success: false, message: 'Claim not found' };
  }
  
  const claim = claimResult.rows[0];
  
  // Only the claimant (verified owner) can generate OTP
  if (claim.claimant_id !== userId) {
    return { success: false, message: 'Only the verified item owner can generate the handover code' };
  }
  
  // Claim must be verified
  if (claim.status !== 'VERIFIED') {
    return { 
      success: false, 
      message: 'Claim must be verified before generating a handover code. Current status: ' + claim.status 
    };
  }
  
  // Check for existing valid OTP
  const existingOTP = await query(
    `SELECT id, otp_expires_at, otp_verified FROM handover_confirmations
     WHERE claim_id = $1`,
    [claimId]
  );
  
  if (existingOTP.rows.length > 0) {
    const existing = existingOTP.rows[0];
    
    if (existing.otp_verified) {
      return { success: false, message: 'Handover has already been completed for this claim' };
    }
    
    if (new Date(existing.otp_expires_at) > new Date()) {
      const remainingMs = new Date(existing.otp_expires_at).getTime() - Date.now();
      const remainingHours = Math.ceil(remainingMs / (60 * 60 * 1000));
      return { 
        success: false, 
        message: `A handover code is already active. It expires in ${remainingHours} hours. Please use the existing code or wait for it to expire.` 
      };
    }
    
    // Expired - delete old OTP before creating new one
    await query('DELETE FROM handover_confirmations WHERE id = $1', [existing.id]);
  }
  
  // Generate new OTP
  const otp = generateSecureOTP();
  const otpHash = await bcrypt.hash(otp, SALT_ROUNDS);
  const expiresAt = new Date(Date.now() + OTP_VALIDITY_HOURS * 60 * 60 * 1000);
  
  await query(
    `INSERT INTO handover_confirmations 
     (claim_id, otp_code_hash, otp_expires_at, generated_by, max_attempts)
     VALUES ($1, $2, $3, $4, $5)`,
    [claimId, otpHash, expiresAt, userId, MAX_OTP_ATTEMPTS]
  );
  
  // Log OTP generation
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : { ipAddress: undefined, userAgent: undefined };
  await logAudit({
    actorId: userId,
    action: 'OTP_GENERATED',
    resourceType: 'handover',
    resourceId: claimId,
    changes: { 
      expires_at: expiresAt.toISOString(),
      claim_status: claim.status 
    },
    ipAddress,
    userAgent
  });
  
  return {
    success: true,
    otp,
    expiresAt,
    message: `Handover code generated successfully. Share this code ONLY when physically meeting the finder. Valid for 24 hours.`
  };
}

/**
 * Verify OTP and complete handover
 * Only the finder or cooperative staff can verify the OTP
 */
export async function verifyHandoverOTP(
  claimId: number,
  otp: string,
  verifierId: number,
  req?: Request
): Promise<OTPVerificationResult> {
  // Get handover details
  const handoverResult = await query(
    `SELECT h.*, c.status as claim_status, c.claimant_id as owner_id,
            li.id as lost_item_id, li.user_id as lost_item_owner,
            fi.id as found_item_id, fi.finder_id, fi.cooperative_id
     FROM handover_confirmations h
     JOIN claims c ON h.claim_id = c.id
     JOIN lost_items li ON c.lost_item_id = li.id
     JOIN found_items fi ON c.found_item_id = fi.id
     WHERE h.claim_id = $1`,
    [claimId]
  );
  
  if (handoverResult.rows.length === 0) {
    return { success: false, message: 'No handover code found for this claim. The owner needs to generate one first.' };
  }
  
  const handover = handoverResult.rows[0];
  
  if (handover.otp_verified) {
    return { success: false, message: 'This handover has already been completed.' };
  }
  
  // Check if verifier is authorized (finder or coop staff)
  const isAuthorizedVerifier = await checkVerifierAuthorization(verifierId, handover);
  if (!isAuthorizedVerifier.authorized) {
    return { success: false, message: isAuthorizedVerifier.reason };
  }
  
  if (new Date(handover.otp_expires_at) < new Date()) {
    return { success: false, message: 'Handover code has expired. Please ask the owner to generate a new one.' };
  }
  
  if (handover.verification_attempts >= (handover.max_attempts || MAX_OTP_ATTEMPTS)) {
    return { 
      success: false, 
      message: 'Maximum verification attempts exceeded. Please ask the owner to generate a new code.',
      attemptsRemaining: 0
    };
  }
  
  // Verify OTP
  const isValid = await bcrypt.compare(otp, handover.otp_code_hash);
  
  const { ipAddress, userAgent } = req ? extractRequestMeta(req) : { ipAddress: undefined, userAgent: undefined };
  
  if (!isValid) {
    await query(
      `UPDATE handover_confirmations SET verification_attempts = verification_attempts + 1 WHERE id = $1`,
      [handover.id]
    );
    
    await logAudit({
      actorId: verifierId,
      action: 'OTP_FAILED',
      resourceType: 'handover',
      resourceId: claimId,
      changes: { attempts: handover.verification_attempts + 1 },
      ipAddress,
      userAgent
    });
    
    const maxAttempts = handover.max_attempts || MAX_OTP_ATTEMPTS;
    const attemptsRemaining = maxAttempts - handover.verification_attempts - 1;
    return {
      success: false,
      message: `Invalid handover code. ${attemptsRemaining} attempt${attemptsRemaining !== 1 ? 's' : ''} remaining.`,
      attemptsRemaining
    };
  }
  
  // OTP is valid - complete handover in a transaction
  await transaction(async (client) => {
    await client.query(
      `UPDATE handover_confirmations 
       SET otp_verified = TRUE, returned_at = NOW(), return_confirmed_by = $1
       WHERE id = $2`,
      [verifierId, handover.id]
    );
    
    await client.query(
      `UPDATE claims SET status = 'RETURNED' WHERE id = $1`,
      [claimId]
    );
    
    await client.query(
      `UPDATE lost_items SET status = 'RETURNED' WHERE id = $1`,
      [handover.lost_item_id]
    );
    
    await client.query(
      `UPDATE found_items SET status = 'RETURNED' WHERE id = $1`,
      [handover.found_item_id]
    );
  });
  
  // Log successful handover
  await logAudit({
    actorId: verifierId,
    action: 'OTP_VERIFIED',
    resourceType: 'handover',
    resourceId: claimId,
    changes: { 
      handover_completed: true,
      confirmed_by: verifierId,
      owner_id: handover.owner_id,
      finder_id: handover.finder_id
    },
    ipAddress,
    userAgent
  });

  // Update trust scores for successful return
  if (req) {
    await onSuccessfulReturn(req, handover.finder_id, handover.owner_id);
  }
  
  return {
    success: true,
    message: 'Handover completed successfully! The item has been marked as returned. Thank you for using Byaboneka+.',
    handoverCompleted: true
  };
}

/**
 * Check if a user is authorized to verify the OTP
 */
async function checkVerifierAuthorization(
  verifierId: number,
  handover: any
): Promise<{ authorized: boolean; reason: string }> {
  if (verifierId === handover.finder_id) {
    return { authorized: true, reason: 'Verifier is the finder' };
  }
  
  if (verifierId === handover.owner_id || verifierId === handover.lost_item_owner) {
    return { 
      authorized: false, 
      reason: 'The item owner cannot verify the handover code. Only the finder or cooperative staff can do this.' 
    };
  }
  
  if (handover.cooperative_id) {
    const staffCheck = await query(
      `SELECT id FROM users WHERE id = $1 AND cooperative_id = $2 AND role = 'coop_staff'`,
      [verifierId, handover.cooperative_id]
    );
    
    if (staffCheck.rows.length > 0) {
      return { authorized: true, reason: 'Verifier is cooperative staff' };
    }
  }
  
  return { 
    authorized: false, 
    reason: 'Only the finder or authorized cooperative staff can verify the handover code.' 
  };
}

/**
 * Get handover status for a claim
 */
export async function getHandoverStatus(claimId: number): Promise<HandoverDetails | null> {
  const result = await query(
    `SELECT h.*, c.claimant_id as owner_id,
            li.id as lost_item_id, fi.id as found_item_id, fi.finder_id
     FROM handover_confirmations h
     JOIN claims c ON h.claim_id = c.id
     JOIN lost_items li ON c.lost_item_id = li.id
     JOIN found_items fi ON c.found_item_id = fi.id
     WHERE h.claim_id = $1`,
    [claimId]
  );
  
  if (result.rows.length === 0) return null;
  
  const h = result.rows[0];
  return {
    handoverId: h.id,
    claimId: h.claim_id,
    lostItemId: h.lost_item_id,
    foundItemId: h.found_item_id,
    ownerId: h.owner_id,
    finderId: h.finder_id,
    otpExpiresAt: h.otp_expires_at,
    otpVerified: h.otp_verified,
    verificationAttempts: h.verification_attempts
  };
}

/**
 * Regenerate OTP (invalidates old one)
 */
export async function regenerateOTP(
  claimId: number,
  userId: number,
  req?: Request
): Promise<OTPGenerationResult> {
  await query('DELETE FROM handover_confirmations WHERE claim_id = $1', [claimId]);
  return generateHandoverOTP(claimId, userId, req);
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/sensitiveRedactionService.ts
‚îÇ Language: TypeScript | Lines: 261 | Size: 8.3 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * ============================================
 * PRIVACY-PRESERVING SENSITIVE ITEM REDACTION
 * ============================================
 * 
 * NOVEL FEATURE: Intelligent content-level redaction that detects and
 * masks specific sensitive patterns (Rwanda national ID numbers, phone 
 * numbers, IMEI numbers, bank account numbers) in descriptions while 
 * keeping the rest of the content visible.
 * 
 * Unlike crude show/hide toggles, this provides surgical, pattern-aware
 * redaction specific to Rwandan document formats.
 * 
 * Fills spec gap THREAT-7.4 (Privacy leak prevention).
 */

// ============================================
// TYPES
// ============================================

export interface RedactionResult {
  redacted_text: string;
  redactions_applied: RedactionMatch[];
  sensitivity_level: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH';
}

export interface RedactionMatch {
  pattern_type: string;
  original_length: number;
  position: number;
  reason: string;
}

// ============================================
// RWANDA-SPECIFIC SENSITIVE PATTERNS
// ============================================

const PATTERNS: Array<{
  name: string;
  regex: RegExp;
  reason: string;
  sensitivity: 'LOW' | 'MEDIUM' | 'HIGH';
  mask: (match: string) => string;
}> = [
  {
    // Rwanda National ID: 16 digits starting with 1
    // Format: 1 YYYY MM DD X XXXXX XX (e.g., 1199880012345678)
    name: 'RWANDA_NATIONAL_ID',
    regex: /\b(1[12]\d{14})\b/g,
    reason: 'Rwanda national ID number detected',
    sensitivity: 'HIGH',
    mask: (m) => m[0] + '*'.repeat(m.length - 2) + m[m.length - 1],
  },
  {
    // Rwanda phone numbers: +250 7XX XXX XXX or 07XX XXX XXX
    name: 'PHONE_NUMBER_RW',
    regex: /(\+?250\s?|0)([7]\d{2}[\s.-]?\d{3}[\s.-]?\d{3})\b/g,
    reason: 'Phone number detected - hidden for privacy',
    sensitivity: 'MEDIUM',
    mask: (m) => {
      const digits = m.replace(/\D/g, '');
      return digits.slice(0, 4) + '***' + digits.slice(-2);
    },
  },
  {
    // IMEI numbers: 15 digits
    name: 'IMEI_NUMBER',
    regex: /(?<!\d)(\d{15})(?!\d)/g,
    reason: 'Possible IMEI number detected',
    sensitivity: 'HIGH',
    mask: (m) => m.slice(0, 4) + '***********',
  },
  {
    // Bank account numbers: 10-16 digit sequences with common prefixes
    name: 'BANK_ACCOUNT',
    regex: /(?<!\d)(\d{10,13})(?!\d)/g,
    reason: 'Possible bank/account number detected',
    sensitivity: 'HIGH',
    mask: (m) => m.slice(0, 2) + '*'.repeat(m.length - 4) + m.slice(-2),
  },
  {
    // Email addresses
    name: 'EMAIL',
    regex: /\b([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})\b/g,
    reason: 'Email address detected',
    sensitivity: 'MEDIUM',
    mask: (m) => {
      const [local, domain] = m.split('@');
      return local[0] + '***@' + domain;
    },
  },
  {
    // Rwanda driver license pattern
    name: 'DRIVER_LICENSE_RW',
    regex: /\b(DL[-\s]?\d{6,8})\b/gi,
    reason: 'Possible driver license number detected',
    sensitivity: 'HIGH',
    mask: (m) => m.slice(0, 3) + '****',
  },
  {
    // Passport numbers (common format: 2 letters + 7 digits)
    name: 'PASSPORT',
    regex: /\b([A-Z]{2}\d{7})\b/g,
    reason: 'Possible passport number detected',
    sensitivity: 'HIGH',
    mask: (m) => m.slice(0, 2) + '*****' + m.slice(-2),
  },
];

// ============================================
// CORE REDACTION FUNCTION
// ============================================

/**
 * Redact sensitive information from text.
 * 
 * @param text - The text to redact
 * @param category - Item category (ID/WALLET get stricter redaction)
 * @param isOwner - If true, skip redaction (owner can see their own data)
 * @returns RedactionResult with masked text and metadata
 */
export function redactSensitiveContent(
  text: string,
  category?: string,
  isOwner: boolean = false
): RedactionResult {
  // Owner always sees full text
  if (isOwner) {
    return {
      redacted_text: text,
      redactions_applied: [],
      sensitivity_level: 'NONE'
    };
  }

  let redactedText = text;
  const redactions: RedactionMatch[] = [];
  let highestSensitivity: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' = 'NONE';

  // Apply patterns
  for (const pattern of PATTERNS) {
    // For non-ID/WALLET categories, skip bank account pattern (too many false positives)
    if (pattern.name === 'BANK_ACCOUNT' && !['ID', 'WALLET'].includes(category || '')) {
      continue;
    }

    let match;
    const regex = new RegExp(pattern.regex.source, pattern.regex.flags);
    
    while ((match = regex.exec(text)) !== null) {
      const original = match[0];
      const masked = pattern.mask(original);
      
      // Only redact if the mask actually changes something
      if (masked !== original) {
        redactedText = redactedText.replace(original, masked);
        redactions.push({
          pattern_type: pattern.name,
          original_length: original.length,
          position: match.index,
          reason: pattern.reason
        });

        // Track highest sensitivity
        const levels = { NONE: 0, LOW: 1, MEDIUM: 2, HIGH: 3 };
        if (levels[pattern.sensitivity] > levels[highestSensitivity]) {
          highestSensitivity = pattern.sensitivity;
        }
      }
    }
  }

  // For ID/WALLET categories, apply extra strictness
  if (['ID', 'WALLET'].includes(category || '') && highestSensitivity === 'NONE') {
    // Even if no patterns matched, truncate long descriptions for sensitive categories
    if (text.length > 200) {
      redactedText = text.substring(0, 200) + '... [Full details visible after verification]';
      highestSensitivity = 'LOW';
    }
  }

  return {
    redacted_text: redactedText,
    redactions_applied: redactions,
    sensitivity_level: highestSensitivity
  };
}

// ============================================
// EXPRESS MIDDLEWARE
// ============================================

import { Request, Response, NextFunction } from 'express';

/**
 * Middleware that automatically redacts sensitive content in item responses.
 * Attach after the main handler has set res.locals.itemData.
 * 
 * Usage in routes:
 *   router.get('/found-items/:id', getFoundItem, redactItemMiddleware);
 * 
 * Or call directly in controller:
 *   const result = redactSensitiveContent(item.description, item.category, isOwner);
 */
export function redactItemResponse(isOwnerCheck: (req: Request, itemData: any) => boolean) {
  return (req: Request, res: Response, next: NextFunction): void => {
    // Hook into res.json to intercept the response
    const originalJson = res.json.bind(res);
    
    res.json = (body: any) => {
      if (body?.success && body?.data) {
        const item = body.data;
        const isOwner = isOwnerCheck(req, item);

        // Redact description
        if (item.description) {
          const descResult = redactSensitiveContent(item.description, item.category, isOwner);
          item.description = descResult.redacted_text;
          if (descResult.redactions_applied.length > 0) {
            item._privacy_notice = 'Some sensitive information has been redacted for privacy protection.';
            item._redaction_count = descResult.redactions_applied.length;
          }
        }

        // Redact title too
        if (item.title) {
          const titleResult = redactSensitiveContent(item.title, item.category, isOwner);
          item.title = titleResult.redacted_text;
        }

        body.data = item;
      }
      return originalJson(body);
    };

    next();
  };
}

// ============================================
// BATCH REDACTION (for list endpoints)
// ============================================

export function redactItemList(
  items: any[],
  userId?: number
): any[] {
  return items.map(item => {
    const isOwner = userId !== undefined && (item.user_id === userId || item.finder_id === userId);
    
    if (item.description) {
      const result = redactSensitiveContent(item.description, item.category, isOwner);
      item.description = result.redacted_text;
    }
    if (item.title) {
      const result = redactSensitiveContent(item.title, item.category, isOwner);
      item.title = result.redacted_text;
    }
    return item;
  });
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/trustService.ts
‚îÇ Language: TypeScript | Lines: 287 | Size: 6.7 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query } from '../config/database';
import { Request } from 'express';
import { logTrustScoreChange } from './auditService';
import { TRUST_CHANGES, getTrustLevel } from '../utils';
import { TrustLevel } from '../types';

// ============================================
// TRUST SCORE SERVICE
// Adaptive Trust Scoring System
// ============================================

export interface TrustScoreUpdate {
  userId: number;
  change: number;
  reason: string;
}

// Get user's current trust score
export async function getUserTrustScore(userId: number): Promise<number> {
  const result = await query(
    'SELECT trust_score FROM users WHERE id = $1',
    [userId]
  );
  
  if (result.rows.length === 0) {
    throw new Error('User not found');
  }
  
  return result.rows[0].trust_score;
}

// Update user's trust score
export async function updateTrustScore(
  req: Request | null,
  userId: number,
  change: number,
  reason: string
): Promise<number> {
  // Get current score
  const currentScore = await getUserTrustScore(userId);
  
  // Calculate new score (bounded between -100 and 100)
  const newScore = Math.max(-100, Math.min(100, currentScore + change));
  
  // Update in database
  await query(
    'UPDATE users SET trust_score = $1 WHERE id = $2',
    [newScore, userId]
  );
  
  // Log the change
  await logTrustScoreChange(req, userId, change, reason, newScore);
  
  // Check if user should be auto-suspended
  if (newScore <= -10 && currentScore > -10) {
    await suspendUserForLowTrust(userId);
  }
  
  return newScore;
}

// Batch update trust scores
export async function batchUpdateTrustScores(
  req: Request | null,
  updates: TrustScoreUpdate[]
): Promise<void> {
  for (const update of updates) {
    await updateTrustScore(req, update.userId, update.change, update.reason);
  }
}

// Specific trust score operations
export async function onSuccessfulReturn(
  req: Request,
  finderId: number,
  ownerId: number
): Promise<void> {
  await updateTrustScore(
    req,
    finderId,
    TRUST_CHANGES.SUCCESSFUL_RETURN_FINDER,
    'Successfully returned a found item'
  );
  
  await updateTrustScore(
    req,
    ownerId,
    TRUST_CHANGES.SUCCESSFUL_RECOVERY_OWNER,
    'Successfully recovered lost item'
  );
}

export async function onFailedVerification(
  req: Request,
  userId: number
): Promise<void> {
  await updateTrustScore(
    req,
    userId,
    TRUST_CHANGES.FAILED_VERIFICATION,
    'Failed verification attempt'
  );
}

export async function onMultipleFailedClaims(
  req: Request,
  userId: number,
  failCount: number
): Promise<void> {
  if (failCount >= 3) {
    await updateTrustScore(
      req,
      userId,
      TRUST_CHANGES.MULTIPLE_FAILED_CLAIMS,
      `Multiple failed claim attempts (${failCount})`
    );
  }
}

export async function onScamReported(
  req: Request,
  userId: number
): Promise<void> {
  await updateTrustScore(
    req,
    userId,
    TRUST_CHANGES.SCAM_REPORTED,
    'Reported for scam (pending investigation)'
  );
}

export async function onScamConfirmed(
  req: Request,
  userId: number
): Promise<void> {
  await updateTrustScore(
    req,
    userId,
    TRUST_CHANGES.SCAM_CONFIRMED,
    'Scam confirmed by admin'
  );
}

export async function onFalseScamReport(
  req: Request,
  reporterId: number
): Promise<void> {
  await updateTrustScore(
    req,
    reporterId,
    TRUST_CHANGES.FALSE_SCAM_REPORT,
    'Filed false scam report'
  );
}

export async function onEmailVerified(
  req: Request,
  userId: number
): Promise<void> {
  await updateTrustScore(
    req,
    userId,
    TRUST_CHANGES.EMAIL_VERIFIED,
    'Email address verified'
  );
}

export async function onPhoneVerified(
  req: Request,
  userId: number
): Promise<void> {
  await updateTrustScore(
    req,
    userId,
    TRUST_CHANGES.PHONE_VERIFIED,
    'Phone number verified'
  );
}

// Auto-suspend user for very low trust
async function suspendUserForLowTrust(userId: number): Promise<void> {
  await query(
    `UPDATE users 
     SET is_banned = true, 
         banned_at = NOW(), 
         ban_reason = 'Automatically suspended due to very low trust score'
     WHERE id = $1`,
    [userId]
  );
}

// Get trust level and permissions for a user
export async function getUserTrustInfo(userId: number): Promise<{
  score: number;
  level: TrustLevel;
  claimLimit: number;
  reportLimit: number;
}> {
  const score = await getUserTrustScore(userId);
  const level = getTrustLevel(score);
  
  // Calculate limits based on trust level
  const claimLimit = getClaimLimitForLevel(level);
  const reportLimit = getReportLimitForLevel(level);
  
  return {
    score,
    level,
    claimLimit,
    reportLimit
  };
}

function getClaimLimitForLevel(level: TrustLevel): number {
  switch (level) {
    case TrustLevel.SUSPENDED: return 0;
    case TrustLevel.RESTRICTED: return 1;
    case TrustLevel.NEW: return 3;
    case TrustLevel.ESTABLISHED: return 5;
    case TrustLevel.TRUSTED: return 7;
    default: return 3;
  }
}

function getReportLimitForLevel(level: TrustLevel): number {
  switch (level) {
    case TrustLevel.SUSPENDED: return 0;
    case TrustLevel.RESTRICTED: return 1;
    case TrustLevel.NEW: return 3;
    case TrustLevel.ESTABLISHED: return 5;
    case TrustLevel.TRUSTED: return 10;
    default: return 3;
  }
}

// Get users with suspicious trust patterns
export async function getSuspiciousUsers(): Promise<any[]> {
  const result = await query(
    `SELECT u.id, u.name, u.email, u.trust_score, u.created_at,
            COUNT(DISTINCT va.id) as failed_verifications,
            COUNT(DISTINCT sr.id) as scam_reports
     FROM users u
     LEFT JOIN claims c ON c.claimant_id = u.id
     LEFT JOIN verification_attempts va ON va.claim_id = c.id AND va.attempt_status = 'FAILED'
     LEFT JOIN scam_reports sr ON sr.reported_user_id = u.id AND sr.status != 'RESOLVED'
     WHERE u.trust_score < 0 OR u.is_banned = true
     GROUP BY u.id
     HAVING COUNT(DISTINCT va.id) >= 3 OR COUNT(DISTINCT sr.id) >= 1
     ORDER BY u.trust_score ASC
     LIMIT 50`
  );
  
  return result.rows;
}

// Recalculate trust score based on history (for admin correction)
export async function recalculateTrustScore(userId: number): Promise<number> {
  // Get all trust-related events from audit log
  const result = await query(
    `SELECT changes->>'change' as change
     FROM audit_logs
     WHERE actor_id = $1
       AND action = 'TRUST_SCORE_CHANGED'
     ORDER BY timestamp ASC`,
    [userId]
  );
  
  // Sum all changes
  let totalScore = 0;
  for (const row of result.rows) {
    if (row.change) {
      totalScore += parseInt(row.change);
    }
  }
  
  // Bound the score
  totalScore = Math.max(-100, Math.min(100, totalScore));
  
  // Update user
  await query(
    'UPDATE users SET trust_score = $1 WHERE id = $2',
    [totalScore, userId]
  );
  
  return totalScore;
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/verificationAttemptsService.ts
‚îÇ Language: TypeScript | Lines: 62 | Size: 2.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { query } from '../config/database';

function startOfToday(): Date {
  const d = new Date();
  d.setHours(0, 0, 0, 0);
  return d;
}

export async function getVerificationLimits(params: {
  claimId: number;
  userId: number;
}): Promise<{
  attemptsToday: number;
  failuresToday: number;
  blockedUntil: Date | null;
}> {
  const { claimId, userId } = params;
  const from = startOfToday();

  const res = await query(
    `SELECT attempt_at, attempt_status
     FROM verification_attempts
     WHERE claim_id = $1 AND user_id = $2 AND attempt_at >= $3
     ORDER BY attempt_at DESC`,
    [claimId, userId, from]
  );

  const rows = res.rows as { attempt_at: string; attempt_status: string }[];
  const attemptsToday = rows.length;
  const failuresToday = rows.filter(r => r.attempt_status === 'FAILED').length;

  // Progressive cooldown based on failures today
  // 1st fail -> 1 hour, 2nd -> 4 hours, 3rd+ -> 24 hours
  const cooldownMinutes =
    failuresToday <= 0 ? 0 :
    failuresToday === 1 ? 60 :
    failuresToday === 2 ? 240 : 1440;

  if (cooldownMinutes === 0) return { attemptsToday, failuresToday, blockedUntil: null };

  const lastAttempt = rows[0] ? new Date(rows[0].attempt_at) : null;
  if (!lastAttempt) return { attemptsToday, failuresToday, blockedUntil: null };

  const blockedUntil = new Date(lastAttempt.getTime() + cooldownMinutes * 60_000);
  return { attemptsToday, failuresToday, blockedUntil };
}

export async function recordVerificationAttempt(params: {
  claimId: number;
  userId: number;
  success: boolean;
  correctAnswers: number;
  ipAddress?: string;
}): Promise<void> {
  const { claimId, userId, success, correctAnswers, ipAddress } = params;

  await query(
    `INSERT INTO verification_attempts (claim_id, user_id, correct_answers, attempt_status, ip_address)
     VALUES ($1, $2, $3, $4, $5)`,
    [claimId, userId, correctAnswers, success ? 'PASSED' : 'FAILED', ipAddress || null]
  );
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/verificationCooldownService.ts
‚îÇ Language: TypeScript | Lines: 264 | Size: 7.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Verification Cooldown Service for Byaboneka+
 * 
 * Implements CLAIM-04/05: Progressive cooldown for failed verification attempts
 * - 1 hour after first failure
 * - 4 hours after second failure
 * - 24 hours after third failure
 */

import { query } from '../config/database';

// Cooldown durations in milliseconds
const COOLDOWN_DURATIONS = {
  1: 60 * 60 * 1000,        // 1 hour after 1 failure
  2: 4 * 60 * 60 * 1000,    // 4 hours after 2 failures  
  3: 24 * 60 * 60 * 1000    // 24 hours after 3 failures
};

const MAX_DAILY_ATTEMPTS = 3;

export interface CooldownStatus {
  canAttempt: boolean;
  cooldownUntil: Date | null;
  remainingSeconds: number;
  attemptsToday: number;
  failuresToday: number;
  message: string;
}

export interface AttemptResult {
  attemptId: number;
  newCooldown: Date | null;
  consecutiveFailures: number;
}

/**
 * Check if a user can make a verification attempt for a specific claim
 */
export async function checkCooldownStatus(
  claimId: number,
  userId: number
): Promise<CooldownStatus> {
  // Get claim cooldown info
  const claimResult = await query(
    `SELECT next_attempt_at, consecutive_failures 
     FROM claims WHERE id = $1`,
    [claimId]
  );
  
  if (claimResult.rows.length === 0) {
    throw new Error('Claim not found');
  }
  
  const claim = claimResult.rows[0];
  
  // Check claim-level cooldown
  if (claim.next_attempt_at && new Date(claim.next_attempt_at) > new Date()) {
    const cooldownUntil = new Date(claim.next_attempt_at);
    const remainingMs = cooldownUntil.getTime() - Date.now();
    
    return {
      canAttempt: false,
      cooldownUntil,
      remainingSeconds: Math.ceil(remainingMs / 1000),
      attemptsToday: claim.consecutive_failures,
      failuresToday: claim.consecutive_failures,
      message: formatCooldownMessage(remainingMs)
    };
  }
  
  // Count attempts in last 24 hours
  const attemptsResult = await query(
    `SELECT 
       COUNT(*) as total_attempts,
       COUNT(*) FILTER (WHERE attempt_status = 'FAILED') as failed_attempts
     FROM verification_attempts
     WHERE claim_id = $1 
     AND attempt_at > NOW() - INTERVAL '24 hours'`,
    [claimId]
  );
  
  const attemptsToday = parseInt(attemptsResult.rows[0].total_attempts);
  const failuresToday = parseInt(attemptsResult.rows[0].failed_attempts);
  
  // Check max daily attempts
  if (attemptsToday >= MAX_DAILY_ATTEMPTS) {
    // Find when the oldest attempt expires
    const oldestAttempt = await query(
      `SELECT attempt_at FROM verification_attempts
       WHERE claim_id = $1
       ORDER BY attempt_at ASC
       LIMIT 1`,
      [claimId]
    );
    
    if (oldestAttempt.rows.length > 0) {
      const expiresAt = new Date(oldestAttempt.rows[0].attempt_at);
      expiresAt.setHours(expiresAt.getHours() + 24);
      const remainingMs = expiresAt.getTime() - Date.now();
      
      return {
        canAttempt: false,
        cooldownUntil: expiresAt,
        remainingSeconds: Math.ceil(remainingMs / 1000),
        attemptsToday,
        failuresToday,
        message: 'Maximum daily verification attempts reached. Please try again tomorrow.'
      };
    }
  }
  
  return {
    canAttempt: true,
    cooldownUntil: null,
    remainingSeconds: 0,
    attemptsToday,
    failuresToday,
    message: `You have ${MAX_DAILY_ATTEMPTS - attemptsToday} attempts remaining today.`
  };
}

/**
 * Record a verification attempt and calculate new cooldown if failed
 */
export async function recordVerificationAttempt(
  claimId: number,
  userId: number,
  passed: boolean,
  correctAnswers: number,
  ipAddress?: string
): Promise<AttemptResult> {
  // Insert attempt record
  const attemptResult = await query(
    `INSERT INTO verification_attempts 
     (claim_id, user_id, correct_answers, attempt_status, ip_address)
     VALUES ($1, $2, $3, $4, $5)
     RETURNING id`,
    [claimId, userId, correctAnswers, passed ? 'PASSED' : 'FAILED', ipAddress]
  );
  
  const attemptId = attemptResult.rows[0].id;
  
  if (passed) {
    // Success - reset consecutive failures
    await query(
      `UPDATE claims SET consecutive_failures = 0, next_attempt_at = NULL WHERE id = $1`,
      [claimId]
    );
    
    return {
      attemptId,
      newCooldown: null,
      consecutiveFailures: 0
    };
  }
  
  // Failure - increment consecutive failures and set cooldown
  const updateResult = await query(
    `UPDATE claims 
     SET consecutive_failures = consecutive_failures + 1,
         last_attempt_at = NOW()
     WHERE id = $1
     RETURNING consecutive_failures`,
    [claimId]
  );
  
  const consecutiveFailures = updateResult.rows[0].consecutive_failures;
  
  // Calculate cooldown based on consecutive failures
  const cooldownMs = COOLDOWN_DURATIONS[Math.min(consecutiveFailures, 3) as keyof typeof COOLDOWN_DURATIONS];
  const cooldownUntil = cooldownMs ? new Date(Date.now() + cooldownMs) : null;
  
  if (cooldownUntil) {
    await query(
      `UPDATE claims SET next_attempt_at = $1 WHERE id = $2`,
      [cooldownUntil, claimId]
    );
  }
  
  return {
    attemptId,
    newCooldown: cooldownUntil,
    consecutiveFailures
  };
}

/**
 * Format a human-readable cooldown message
 */
function formatCooldownMessage(remainingMs: number): string {
  const hours = Math.floor(remainingMs / (60 * 60 * 1000));
  const minutes = Math.floor((remainingMs % (60 * 60 * 1000)) / (60 * 1000));
  
  if (hours > 0) {
    return `Please wait ${hours} hour${hours > 1 ? 's' : ''} and ${minutes} minute${minutes > 1 ? 's' : ''} before trying again.`;
  }
  return `Please wait ${minutes} minute${minutes > 1 ? 's' : ''} before trying again.`;
}

/**
 * Get verification attempt history for a claim
 */
export async function getAttemptHistory(
  claimId: number,
  limit: number = 10
): Promise<any[]> {
  const result = await query(
    `SELECT va.*, u.name as user_name
     FROM verification_attempts va
     JOIN users u ON va.user_id = u.id
     WHERE va.claim_id = $1
     ORDER BY va.attempt_at DESC
     LIMIT $2`,
    [claimId, limit]
  );
  
  return result.rows;
}

/**
 * Clear cooldown for a claim (admin function)
 */
export async function clearCooldown(claimId: number): Promise<void> {
  await query(
    `UPDATE claims 
     SET next_attempt_at = NULL, consecutive_failures = 0 
     WHERE id = $1`,
    [claimId]
  );
}

/**
 * Check if user has suspicious verification patterns
 * (multiple failures across different claims)
 */
export async function checkSuspiciousPatterns(userId: number): Promise<{
  isSuspicious: boolean;
  recentFailures: number;
  uniqueClaimsFailed: number;
}> {
  const result = await query(
    `SELECT 
       COUNT(*) as total_failures,
       COUNT(DISTINCT claim_id) as unique_claims
     FROM verification_attempts
     WHERE user_id = $1
     AND attempt_status = 'FAILED'
     AND attempt_at > NOW() - INTERVAL '7 days'`,
    [userId]
  );
  
  const recentFailures = parseInt(result.rows[0].total_failures);
  const uniqueClaimsFailed = parseInt(result.rows[0].unique_claims);
  
  // Suspicious if: 5+ failures across 3+ different claims in a week
  const isSuspicious = recentFailures >= 5 && uniqueClaimsFailed >= 3;
  
  return {
    isSuspicious,
    recentFailures,
    uniqueClaimsFailed
  };
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/services/verificationStrengthService.ts
‚îÇ Language: TypeScript | Lines: 311 | Size: 13.2 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * ============================================
 * VERIFICATION STRENGTH ANALYZER
 * ============================================
 * 
 * NOVEL FEATURE: No lost-and-found platform analyzes the QUALITY of
 * verification questions. This service scores questions on specificity,
 * guessability, and redundancy, then gives users actionable feedback.
 * 
 * Also provides category-specific question templates as defined in
 * Algorithm Spec section 3.2.2 (was missing from codebase).
 */

// ============================================
// TYPES
// ============================================

export type StrengthLevel = 'WEAK' | 'MODERATE' | 'STRONG';

export interface QuestionAnalysis {
  question_index: number;
  strength: StrengthLevel;
  score: number;       // 0-100
  issues: string[];
  suggestions: string[];
}

export interface VerificationStrengthResult {
  overall_strength: StrengthLevel;
  overall_score: number;        // 0-100
  questions: QuestionAnalysis[];
  redundancy_warning: boolean;
  improvement_tips: string[];
}

export interface QuestionTemplate {
  category: string;
  question: string;
  why_effective: string;
}

// ============================================
// CATEGORY-SPECIFIC TEMPLATES (from Algo Spec 3.2.2)
// ============================================

export const QUESTION_TEMPLATES: Record<string, QuestionTemplate[]> = {
  PHONE: [
    { category: 'PHONE', question: 'What is your lockscreen wallpaper?', why_effective: 'Only the owner would know this - it cannot be guessed from the phone exterior.' },
    { category: 'PHONE', question: 'What color/design is the phone case?', why_effective: 'Specific physical detail that requires having seen the phone.' },
    { category: 'PHONE', question: 'What are the last 4 digits of the IMEI number?', why_effective: 'Unique identifier that only the owner would have recorded.' },
    { category: 'PHONE', question: 'Name one specific app on the home screen', why_effective: 'Personal customization that is unique to each user.' },
    { category: 'PHONE', question: 'What is the phone ringtone or notification sound?', why_effective: 'Personal setting that distinguishes one phone from others.' },
  ],
  ID: [
    { category: 'ID', question: 'What are the last 3 characters of the ID number?', why_effective: 'Partial identifier that the owner would know.' },
    { category: 'ID', question: 'What are the name initials on the document?', why_effective: 'Verifies the document belongs to the claimant.' },
    { category: 'ID', question: 'Which district issued the document?', why_effective: 'Administrative detail that only the holder would know.' },
    { category: 'ID', question: 'What year was the document issued?', why_effective: 'Temporal detail specific to this particular document.' },
  ],
  WALLET: [
    { category: 'WALLET', question: 'How many cards are inside the wallet?', why_effective: 'Specific content count that requires having owned the wallet.' },
    { category: 'WALLET', question: 'Name one specific card (bank/ID/other) inside', why_effective: 'Identifies specific contents only the owner would know.' },
    { category: 'WALLET', question: 'Approximately how much cash was inside (in RWF)?', why_effective: 'Content detail that is hard to guess correctly.' },
    { category: 'WALLET', question: 'Are there any photos inside? If yes, describe one.', why_effective: 'Personal content that uniquely identifies the wallet.' },
    { category: 'WALLET', question: 'What color is the wallet interior?', why_effective: 'Physical detail only visible when the wallet is open.' },
  ],
  BAG: [
    { category: 'BAG', question: 'Describe any distinctive marks, stickers, or damage', why_effective: 'Unique physical features that identify this specific bag.' },
    { category: 'BAG', question: 'What brand is the bag?', why_effective: 'Manufacturer detail that narrows identification.' },
    { category: 'BAG', question: 'How many compartments does it have?', why_effective: 'Structural detail requiring familiarity with the bag.' },
    { category: 'BAG', question: 'Name one specific item that was inside', why_effective: 'Contents knowledge only the owner would have.' },
  ],
  KEYS: [
    { category: 'KEYS', question: 'How many keys are on the keyring?', why_effective: 'Specific count that the owner would know.' },
    { category: 'KEYS', question: 'Describe the keychain or any attachment', why_effective: 'Decorative details unique to this key set.' },
    { category: 'KEYS', question: 'Are there any distinctive or unusual key shapes?', why_effective: 'Physical detail that distinguishes these keys.' },
  ],
  OTHER: [
    { category: 'OTHER', question: 'Describe a specific unique mark or feature on the item', why_effective: 'Physical uniqueness proves familiarity.' },
    { category: 'OTHER', question: 'What was the item being used for when last seen?', why_effective: 'Contextual detail only the owner would know.' },
    { category: 'OTHER', question: 'Where exactly was the item stored or placed before loss?', why_effective: 'Specific location knowledge proves ownership.' },
  ],
};

// ============================================
// WEAK QUESTION PATTERNS
// ============================================

const GENERIC_PATTERNS = [
  /^what colou?r/i,
  /^what is the colou?r/i,
  /^is it (a |my )?/i,
  /^what brand/i,
  /^where did/i,
  /^when did/i,
  /^how old/i,
];

const TOO_SHORT_THRESHOLD = 15;   // Characters
const TOO_VAGUE_WORDS = ['thing', 'stuff', 'something', 'item', 'object', 'it'];
const YES_NO_PATTERNS = [/^is /i, /^are /i, /^was /i, /^were /i, /^do /i, /^does /i, /^did /i, /^can /i, /^has /i, /^have /i];

// ============================================
// CORE ANALYSIS FUNCTION
// ============================================

export function analyzeVerificationStrength(
  questions: string[],
  answers: string[],
  itemCategory: string,
  itemDescription: string
): VerificationStrengthResult {
  const questionAnalyses: QuestionAnalysis[] = [];

  // Analyze each question individually
  for (let i = 0; i < questions.length; i++) {
    const q = questions[i] || '';
    const a = answers[i] || '';
    questionAnalyses.push(analyzeQuestion(q, a, itemDescription, i));
  }

  // Check for redundancy (all questions asking about the same thing)
  const redundancyWarning = checkRedundancy(questions);

  // Calculate overall score
  const avgScore = questionAnalyses.reduce((sum, qa) => sum + qa.score, 0) / questionAnalyses.length;
  const redundancyPenalty = redundancyWarning ? 15 : 0;
  const overallScore = Math.max(0, Math.round(avgScore - redundancyPenalty));

  let overallStrength: StrengthLevel;
  if (overallScore >= 70) overallStrength = 'STRONG';
  else if (overallScore >= 40) overallStrength = 'MODERATE';
  else overallStrength = 'WEAK';

  // Generate tips
  const tips: string[] = [];
  if (overallStrength === 'WEAK') {
    tips.push('Your verification questions may not protect your item. Consider using our suggested templates.');
  }
  if (redundancyWarning) {
    tips.push('Your questions are too similar. Use different types of questions for better security.');
  }
  const weakQ = questionAnalyses.filter(qa => qa.strength === 'WEAK');
  if (weakQ.length > 0) {
    tips.push(`${weakQ.length} of your ${questions.length} questions are weak. Tap on each for improvement suggestions.`);
  }

  // Add category-specific tips
  const templates = QUESTION_TEMPLATES[itemCategory] || QUESTION_TEMPLATES['OTHER'];
  if (overallStrength !== 'STRONG') {
    tips.push(`For ${itemCategory.toLowerCase()} items, try questions like: "${templates[0].question}"`);
  }

  return {
    overall_strength: overallStrength,
    overall_score: overallScore,
    questions: questionAnalyses,
    redundancy_warning: redundancyWarning,
    improvement_tips: tips
  };
}

// ============================================
// INDIVIDUAL QUESTION ANALYSIS
// ============================================

function analyzeQuestion(
  question: string,
  answer: string,
  itemDescription: string,
  index: number
): QuestionAnalysis {
  let score = 50; // Start at middle
  const issues: string[] = [];
  const suggestions: string[] = [];

  // ‚îÄ‚îÄ Check 1: Question length (too short = vague) ‚îÄ‚îÄ
  if (question.length < TOO_SHORT_THRESHOLD) {
    score -= 20;
    issues.push('Question is too short and vague');
    suggestions.push('Add more specific details to your question');
  }

  // ‚îÄ‚îÄ Check 2: Yes/No questions (low entropy) ‚îÄ‚îÄ
  const isYesNo = YES_NO_PATTERNS.some(p => p.test(question));
  if (isYesNo) {
    score -= 25;
    issues.push('Yes/no questions are easy to guess (50% chance)');
    suggestions.push('Rephrase as an open-ended question (e.g., "What is..." or "Describe...")');
  }

  // ‚îÄ‚îÄ Check 3: Generic patterns ‚îÄ‚îÄ
  const isGeneric = GENERIC_PATTERNS.some(p => p.test(question));
  if (isGeneric) {
    score -= 15;
    issues.push('This is a very common question type that others might guess');
    suggestions.push('Ask about something more specific and personal to the item');
  }

  // ‚îÄ‚îÄ Check 4: Answer quality ‚îÄ‚îÄ
  if (answer.length <= 2) {
    score -= 20;
    issues.push('Answer is too short - easy to guess');
    suggestions.push('Use a more detailed answer (at least 3 characters)');
  } else if (answer.length <= 5) {
    score -= 10;
    issues.push('Short answers are easier to brute-force');
  } else if (answer.length >= 10) {
    score += 10; // Bonus for detailed answers
  }

  // ‚îÄ‚îÄ Check 5: Answer in item description (guessable!) ‚îÄ‚îÄ
  const descLower = itemDescription.toLowerCase();
  const ansLower = answer.toLowerCase().trim();
  if (ansLower.length > 2 && descLower.includes(ansLower)) {
    score -= 30;
    issues.push('CRITICAL: Your answer appears in the item description! Anyone can see it.');
    suggestions.push('Choose a secret that is NOT mentioned in your public item description');
  }

  // ‚îÄ‚îÄ Check 6: Common/guessable answers ‚îÄ‚îÄ
  const commonAnswers = ['yes', 'no', 'black', 'white', 'red', 'blue', 'green', '1', '2', '3', 'none', 'n/a'];
  if (commonAnswers.includes(ansLower)) {
    score -= 15;
    issues.push('This answer is very common and easy to guess');
    suggestions.push('Use a more unique and specific answer');
  }

  // ‚îÄ‚îÄ Check 7: Vague words ‚îÄ‚îÄ
  const hasVagueWords = TOO_VAGUE_WORDS.some(w => question.toLowerCase().includes(w));
  if (hasVagueWords) {
    score -= 10;
    issues.push('Question uses vague words');
    suggestions.push('Replace vague terms with specific details');
  }

  // ‚îÄ‚îÄ Check 8: Good question patterns (bonus) ‚îÄ‚îÄ
  const specificPatterns = [/how many/i, /describe/i, /last \d/i, /name (one|a|the)/i, /specific/i, /exact/i];
  const isSpecific = specificPatterns.some(p => p.test(question));
  if (isSpecific) {
    score += 15;
  }

  // Clamp score
  score = Math.max(0, Math.min(100, score));

  let strength: StrengthLevel;
  if (score >= 65) strength = 'STRONG';
  else if (score >= 35) strength = 'MODERATE';
  else strength = 'WEAK';

  return {
    question_index: index,
    strength,
    score,
    issues,
    suggestions
  };
}

// ============================================
// REDUNDANCY CHECK
// ============================================

function checkRedundancy(questions: string[]): boolean {
  if (questions.length < 2) return false;

  // Spelling normalization (UK‚ÜíUS, common synonyms)
  const NORMALIZE_MAP: Record<string, string> = {
    'colour': 'color', 'colours': 'color', 'coloured': 'color', 'colored': 'color',
    'grey': 'gray', 'favourite': 'favorite', 'centre': 'center',
    'describe': 'detail', 'description': 'detail', 'explain': 'detail',
  };

  const normalizeWord = (w: string): string => NORMALIZE_MAP[w] || w;

  // Extract key topic words from each question
  const stopwords = new Set(['what', 'is', 'the', 'a', 'an', 'of', 'my', 'your', 'it', 'this', 'that', 'how', 'where', 'when', 'which', 'does', 'do', 'are', 'was', 'were', 'on', 'in', 'about', 'can', 'you', 'tell', 'me']);
  
  const topicSets = questions.map(q => {
    const words = q.toLowerCase().replace(/[?.,!]/g, '').split(/\s+/)
      .filter(w => !stopwords.has(w) && w.length > 2)
      .map(normalizeWord);
    return new Set(words);
  });

  // Check overlap between all pairs
  let highOverlapCount = 0;
  for (let i = 0; i < topicSets.length; i++) {
    for (let j = i + 1; j < topicSets.length; j++) {
      const intersection = [...topicSets[i]].filter(w => topicSets[j].has(w));
      const minSize = Math.min(topicSets[i].size, topicSets[j].size);
      if (minSize > 0 && intersection.length / minSize >= 0.5) {
        highOverlapCount++;
      }
    }
  }

  // If most question pairs have high overlap, flag redundancy
  const totalPairs = (questions.length * (questions.length - 1)) / 2;
  return highOverlapCount / totalPairs >= 0.5;
}

// ============================================
// API ENDPOINT HELPER
// ============================================

export function getTemplatesForCategory(category: string): QuestionTemplate[] {
  return QUESTION_TEMPLATES[category.toUpperCase()] || QUESTION_TEMPLATES['OTHER'];
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/types/index.ts
‚îÇ Language: TypeScript | Lines: 380 | Size: 7.4 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// ============================================
// BYABONEKA+ TYPE DEFINITIONS
// Trust-Aware Lost & Found Infrastructure
// ============================================

// ==================== ENUMS ====================

export enum UserRole {
  CITIZEN = 'citizen',
  COOP_STAFF = 'coop_staff',
  ADMIN = 'admin'
}

export enum ItemCategory {
  PHONE = 'PHONE',
  ID = 'ID',
  WALLET = 'WALLET',
  BAG = 'BAG',
  KEYS = 'KEYS',
  OTHER = 'OTHER'
}

export enum LostItemStatus {
  ACTIVE = 'ACTIVE',
  CLAIMED = 'CLAIMED',
  RETURNED = 'RETURNED',
  EXPIRED = 'EXPIRED'
}

export enum FoundItemStatus {
  UNCLAIMED = 'UNCLAIMED',
  MATCHED = 'MATCHED',
  RETURNED = 'RETURNED',
  EXPIRED = 'EXPIRED'
}

export enum ItemSource {
  CITIZEN = 'CITIZEN',
  COOPERATIVE = 'COOPERATIVE'
}

export enum ClaimStatus {
  PENDING = 'PENDING',
  VERIFIED = 'VERIFIED',
  REJECTED = 'REJECTED',
  RETURNED = 'RETURNED',
  DISPUTED = 'DISPUTED',
  CANCELLED = 'CANCELLED',
  EXPIRED = 'EXPIRED'
}

export enum VerificationAttemptStatus {
  PASSED = 'PASSED',
  FAILED = 'FAILED'
}

export enum CooperativeStatus {
  PENDING = 'PENDING',
  VERIFIED = 'VERIFIED',
  SUSPENDED = 'SUSPENDED'
}

export enum ScamReportStatus {
  OPEN = 'OPEN',
  INVESTIGATING = 'INVESTIGATING',
  RESOLVED = 'RESOLVED'
}

export enum AuditAction {
  CREATE = 'CREATE',
  UPDATE = 'UPDATE',
  DELETE = 'DELETE',
  VERIFY = 'VERIFY',
  LOGIN = 'LOGIN',
  LOGOUT = 'LOGOUT',
  CLAIM_ATTEMPT = 'CLAIM_ATTEMPT',
  CLAIM_VERIFIED = 'CLAIM_VERIFIED',
  CLAIM_REJECTED = 'CLAIM_REJECTED',
  OTP_GENERATED = 'OTP_GENERATED',
  OTP_VERIFIED = 'OTP_VERIFIED',
  OTP_FAILED = 'OTP_FAILED',
  ITEM_RETURNED = 'ITEM_RETURNED',
  SCAM_REPORTED = 'SCAM_REPORTED',
  USER_BANNED = 'USER_BANNED',
  USER_SUSPENDED = 'USER_SUSPENDED',
  COOP_APPROVED = 'COOP_APPROVED',
  COOP_SUSPENDED = 'COOP_SUSPENDED',
  TRUST_SCORE_CHANGED = 'TRUST_SCORE_CHANGED',
  REPORT_EXPIRED = 'REPORT_EXPIRED'
}

export enum TrustLevel {
  SUSPENDED = 'SUSPENDED',
  RESTRICTED = 'RESTRICTED',
  NEW = 'NEW',
  ESTABLISHED = 'ESTABLISHED',
  TRUSTED = 'TRUSTED'
}

// ==================== INTERFACES ====================

// Base entity with timestamps
export interface BaseEntity {
  id: number;
  created_at: Date;
  updated_at: Date;
}

// User
export interface User extends BaseEntity {
  email: string;
  phone?: string;
  password_hash: string;
  name: string;
  role: UserRole;
  trust_score: number;
  cooperative_id?: number;
  email_verified: boolean;
  phone_verified: boolean;
  is_banned: boolean;
  banned_at?: Date;
  ban_reason?: string;
}

export interface UserPublic {
  id: number;
  name: string;
  role: UserRole;
  trust_score: number;
  created_at: Date;
}

// Cooperative
export interface Cooperative extends BaseEntity {
  name: string;
  registration_number: string;
  status: CooperativeStatus;
  contact_info: string;
  address?: string;
  verified_at?: Date;
  verified_by?: number;
}

// Lost Item
export interface LostItem extends BaseEntity {
  user_id: number;
  category: ItemCategory;
  title: string;
  description: string;
  location_area: string;
  location_hint?: string;
  lost_date: Date;
  status: LostItemStatus;
  keywords: string[];
  photo_url?: string;
  expiry_warning_sent: boolean;
  expired_at?: Date;
}

// Found Item
export interface FoundItem extends BaseEntity {
  finder_id: number;
  cooperative_id?: number;
  category: ItemCategory;
  title: string;
  description: string;
  location_area: string;
  location_hint?: string;
  found_date: Date;
  status: FoundItemStatus;
  source: ItemSource;
  image_urls: string[];
  keywords: string[];
  expiry_warning_sent: boolean;
  expired_at?: Date;
}

// Verification Secrets
export interface VerificationSecret extends BaseEntity {
  lost_item_id: number;
  question_1_text: string;
  answer_1_hash: string;
  answer_1_salt: string;
  question_2_text: string;
  answer_2_hash: string;
  answer_2_salt: string;
  question_3_text: string;
  answer_3_hash: string;
  answer_3_salt: string;
}

// Claim
export interface Claim extends BaseEntity {
  lost_item_id: number;
  found_item_id: number;
  claimant_id: number;
  status: ClaimStatus;
  verification_score: number;
  attempts_made: number;
  last_attempt_at?: Date;
  dispute_reason?: string;
}

// Verification Attempt
export interface VerificationAttempt extends BaseEntity {
  claim_id: number;
  correct_answers: number;
  attempt_status: VerificationAttemptStatus;
  attempt_at: Date;
  ip_address?: string;
}

// Handover Confirmation
export interface HandoverConfirmation extends BaseEntity {
  claim_id: number;
  otp_code_hash: string;
  otp_expires_at: Date;
  otp_verified: boolean;
  verification_attempts: number;
  returned_at?: Date;
  return_confirmed_by?: number;
}

// Message
export interface Message extends BaseEntity {
  sender_id: number;
  receiver_id: number;
  claim_id: number;
  content: string;
  is_read: boolean;
  is_flagged: boolean;
  flag_reason?: string;
}

// Scam Report
export interface ScamReport extends BaseEntity {
  reporter_id: number;
  message_id?: number;
  reported_user_id: number;
  claim_id?: number;
  reason: string;
  status: ScamReportStatus;
  resolved_at?: Date;
  resolved_by?: number;
  resolution_notes?: string;
}

// Audit Log
export interface AuditLog {
  id: number;
  actor_id?: number;
  action: AuditAction;
  resource_type: string;
  resource_id?: number;
  changes?: Record<string, any>;
  ip_address?: string;
  user_agent?: string;
  timestamp: Date;
}

// Match Result
export interface MatchResult {
  found_item: FoundItem;
  score: number;
  explanation: string[];
}

// ==================== DTOs ====================

// Auth DTOs
export interface RegisterDTO {
  email: string;
  password: string;
  name: string;
  phone?: string;
}

export interface LoginDTO {
  email: string;
  password: string;
}

export interface TokenPayload {
  userId: number;
  email: string;
  role: UserRole;
  iat?: number;
  exp?: number;
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
}

// Lost Item DTOs
export interface CreateLostItemDTO {
  category: ItemCategory;
  title: string;
  description: string;
  location_area: string;
  location_hint?: string;
  lost_date: string;
  photo_url?: string;
  verification_questions: VerificationQuestionDTO[];
}

export interface VerificationQuestionDTO {
  question: string;
  answer: string;
}

// Found Item DTOs
export interface CreateFoundItemDTO {
  category: ItemCategory;
  title: string;
  description: string;
  location_area: string;
  location_hint?: string;
  found_date: string;
  cooperative_id?: number;
}

// Claim DTOs
export interface CreateClaimDTO {
  lost_item_id: number;
  found_item_id: number;
}

export interface VerifyClaimDTO {
  answers: string[];
}

// Message DTOs
export interface SendMessageDTO {
  content: string;
}

// Pagination
export interface PaginationParams {
  page: number;
  limit: number;
}

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// API Response
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  errors?: any[];
}

// Search/Filter
export interface ItemSearchParams {
  category?: ItemCategory;
  location_area?: string;
  date_from?: string;
  date_to?: string;
  keyword?: string;
  status?: string;
}

// Trust Score Change
export interface TrustScoreChange {
  user_id: number;
  change: number;
  reason: string;
  new_score: number;
}



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/utils/index.ts
‚îÇ Language: TypeScript | Lines: 374 | Size: 12.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';
import { TokenPayload, UserRole, TrustLevel } from '../types';

// ============================================
// PASSWORD & HASHING UTILITIES
// ============================================

const BCRYPT_COST = 10;

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, BCRYPT_COST);
}

export async function verifyPassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

// For secret answers - normalize and hash with salt
export async function hashSecretAnswer(answer: string): Promise<{ hash: string; salt: string }> {
  const salt = crypto.randomBytes(16).toString('hex');
  const normalized = normalizeAnswer(answer);
  const hash = await bcrypt.hash(normalized + salt, BCRYPT_COST);
  return { hash, salt };
}

export async function verifySecretAnswer(
  submittedAnswer: string,
  storedHash: string,
  salt: string
): Promise<boolean> {
  const normalized = normalizeAnswer(submittedAnswer);
  return bcrypt.compare(normalized + salt, storedHash);
}

function normalizeAnswer(answer: string): string {
  return answer
    .toLowerCase()
    .trim()
    .replace(/[^\w\s]/g, '') // Remove punctuation
    .replace(/\s+/g, ' ');   // Collapse whitespace
}

// ============================================
// JWT UTILITIES
// ============================================

function getJwtSecret(): string {
  const secret = process.env.JWT_SECRET;
  if (!secret && process.env.NODE_ENV === 'production') {
    throw new Error('FATAL: JWT_SECRET environment variable must be set in production');
  }
  return secret || 'dev_jwt_secret_change_in_production_min_32_chars';
}

function getJwtRefreshSecret(): string {
  const secret = process.env.JWT_REFRESH_SECRET;
  if (!secret && process.env.NODE_ENV === 'production') {
    throw new Error('FATAL: JWT_REFRESH_SECRET environment variable must be set in production');
  }
  return secret || 'dev_refresh_secret_change_in_production_min_32';
}

const ACCESS_TOKEN_EXPIRY = '15m';
const REFRESH_TOKEN_EXPIRY = '7d';

export function generateAccessToken(payload: TokenPayload): string {
  return jwt.sign(payload, getJwtSecret(), { expiresIn: ACCESS_TOKEN_EXPIRY } as jwt.SignOptions);
}

export function generateRefreshToken(payload: TokenPayload): string {
  return jwt.sign(payload, getJwtRefreshSecret(), { expiresIn: REFRESH_TOKEN_EXPIRY } as jwt.SignOptions);
}

export function verifyAccessToken(token: string): TokenPayload {
  return jwt.verify(token, getJwtSecret()) as TokenPayload;
}

export function verifyRefreshToken(token: string): TokenPayload {
  return jwt.verify(token, getJwtRefreshSecret()) as TokenPayload;
}

export function hashToken(token: string): string {
  return crypto.createHash('sha256').update(token).digest('hex');
}

// ============================================
// OTP UTILITIES (unified ‚Äî uses bcryptjs)
// ============================================

export function generateOTP(): string {
  // Generate 6-digit OTP using crypto for security
  const bytes = crypto.randomBytes(4);
  const num = bytes.readUInt32BE(0) % 1000000;
  return num.toString().padStart(6, '0');
}

export async function hashOTP(otp: string): Promise<string> {
  return bcrypt.hash(otp, BCRYPT_COST);
}

export async function verifyOTP(otp: string, hash: string): Promise<boolean> {
  return bcrypt.compare(otp, hash);
}

// ============================================
// KEYWORD EXTRACTION
// ============================================

// Common stopwords to filter out (English + Kinyarwanda)
const STOPWORDS = new Set([
  // English
  'the', 'a', 'an', 'in', 'on', 'at', 'to', 'for', 'of', 'and', 'or', 'is', 'it',
  'was', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will',
  'would', 'could', 'should', 'may', 'might', 'must', 'shall', 'can', 'need', 'dare',
  'ought', 'used', 'my', 'your', 'his', 'her', 'its', 'our', 'their', 'this', 'that',
  'these', 'those', 'i', 'you', 'he', 'she', 'we', 'they', 'what', 'which', 'who',
  'whom', 'whose', 'where', 'when', 'why', 'how', 'all', 'each', 'every', 'both',
  'few', 'more', 'most', 'other', 'some', 'such', 'no', 'not', 'only', 'same', 'so',
  'than', 'too', 'very', 'just', 'also', 'now', 'here', 'there', 'then', 'once',
  'with', 'about', 'after', 'before', 'above', 'below', 'between', 'into', 'through',
  'during', 'under', 'again', 'further', 'while', 'lost', 'found', 'item',
  // Kinyarwanda common
  'mu', 'ku', 'ni', 'na', 'ndi', 'uri', 'ari', 'dufite', 'nta', 'hari', 'ya', 'yo',
  'by', 'bya', 'cy', 'cya', 'ry', 'rya', 'wa', 'wo', 'ba', 'bo', 'ka', 'ko', 'ha',
]);

// High-value keywords to always include if found
const COLOR_PATTERNS = [
  'black', 'white', 'red', 'blue', 'green', 'yellow', 'orange', 'pink', 'purple',
  'brown', 'grey', 'gray', 'silver', 'gold', 'dark', 'light',
  'umukara', 'umweru', 'umutuku', 'ubururu'
];

const BRAND_PATTERNS = [
  'iphone', 'samsung', 'galaxy', 'tecno', 'infinix', 'itel', 'huawei', 'xiaomi',
  'redmi', 'oppo', 'vivo', 'nokia', 'motorola', 'pixel', 'oneplus', 'realme',
  'nike', 'adidas', 'samsonite', 'puma', 'gucci', 'louis', 'vuitton', 'zara',
  'bk', 'equity', 'kcb', 'cogebanque', 'bpr', 'i&m', 'access',
  'toyota', 'honda', 'hp', 'dell', 'lenovo', 'asus', 'acer', 'macbook'
];

export function extractKeywords(text: string): string[] {
  if (!text) return [];

  const normalized = text
    .toLowerCase()
    .replace(/[^\w\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  const words = normalized.split(' ');
  const keywords: Set<string> = new Set();

  for (const word of words) {
    if (word.length < 3 || STOPWORDS.has(word)) {
      continue;
    }

    if (COLOR_PATTERNS.includes(word) || BRAND_PATTERNS.includes(word)) {
      keywords.add(word);
      continue;
    }

    if (word.length >= 3) {
      keywords.add(word);
    }
  }

  return Array.from(keywords);
}

// ============================================
// TRUST SCORE UTILITIES
// ============================================

export function getTrustLevel(trustScore: number): TrustLevel {
  if (trustScore < -10) return TrustLevel.SUSPENDED;
  if (trustScore < 0) return TrustLevel.RESTRICTED;
  if (trustScore < 5) return TrustLevel.NEW;
  if (trustScore < 15) return TrustLevel.ESTABLISHED;
  return TrustLevel.TRUSTED;
}

export function getClaimAttemptLimit(trustLevel: TrustLevel): number {
  switch (trustLevel) {
    case TrustLevel.SUSPENDED: return 0;
    case TrustLevel.RESTRICTED: return 1;
    case TrustLevel.NEW: return 3;
    case TrustLevel.ESTABLISHED: return 5;
    case TrustLevel.TRUSTED: return 7;
    default: return 3;
  }
}

export function getReportDailyLimit(trustLevel: TrustLevel): number {
  switch (trustLevel) {
    case TrustLevel.SUSPENDED: return 0;
    case TrustLevel.RESTRICTED: return 1;
    case TrustLevel.NEW: return 3;
    case TrustLevel.ESTABLISHED: return 5;
    case TrustLevel.TRUSTED: return 10;
    default: return 3;
  }
}

// Trust score changes
export const TRUST_CHANGES = {
  SUCCESSFUL_RETURN_FINDER: 3,
  SUCCESSFUL_RECOVERY_OWNER: 2,
  EMAIL_VERIFIED: 1,
  PHONE_VERIFIED: 2,
  FAILED_VERIFICATION: -2,
  MULTIPLE_FAILED_CLAIMS: -5,
  SCAM_REPORTED: -5,
  SCAM_CONFIRMED: -20,
  FALSE_SCAM_REPORT: -3,
  ACCURATE_REPORT_CONFIRMED: 1,
};

// ============================================
// LOCATION UTILITIES
// ============================================

const KIGALI_AREAS: { [key: string]: string[] } = {
  'Nyarugenge': ['Gitega', 'Nyarugenge', 'Nyamirambo', 'Muhima', 'Rwezamenyo', 'Kimisagara'],
  'Gasabo': ['Kimironko', 'Remera', 'Kacyiru', 'Gisozi', 'Kimihurura', 'Nyarutarama', 'Kibagabaga', 'Kinyinya'],
  'Kicukiro': ['Gikondo', 'Kagarama', 'Kicukiro', 'Kanombe', 'Niboye', 'Masaka', 'Nyarugunga'],
};

const ADJACENT_AREAS: { [key: string]: string[] } = {
  'kimironko': ['remera', 'kibagabaga', 'kinyinya'],
  'remera': ['kimironko', 'kicukiro', 'kibagabaga', 'nyarugunga'],
  'kacyiru': ['kimihurura', 'gisozi', 'nyarutarama'],
  'nyabugogo': ['muhima', 'gitega', 'nyamirambo'],
  'gisozi': ['kacyiru', 'kinyinya', 'jabana'],
  'nyamirambo': ['muhima', 'nyabugogo', 'rwezamenyo'],
  'kibagabaga': ['kimironko', 'remera', 'kinyinya'],
  'kinyinya': ['kimironko', 'kibagabaga', 'gisozi'],
  'kicukiro': ['remera', 'gikondo', 'nyarugunga'],
  'muhima': ['nyabugogo', 'nyamirambo', 'gitega'],
  'kimihurura': ['kacyiru', 'nyarutarama'],
  'nyarutarama': ['kacyiru', 'kimihurura'],
  'gikondo': ['kicukiro', 'kagarama'],
  'kagarama': ['gikondo', 'kicukiro'],
};

export function computeLocationDistance(area1: string, area2: string): number {
  const a1 = area1.toLowerCase().trim();
  const a2 = area2.toLowerCase().trim();

  if (a1 === a2) return 0;

  const adjacentToA1 = ADJACENT_AREAS[a1] || [];
  if (adjacentToA1.includes(a2)) return 1;

  const adjacentToA2 = ADJACENT_AREAS[a2] || [];
  if (adjacentToA2.includes(a1)) return 1;

  for (const district of Object.values(KIGALI_AREAS)) {
    const lowerDistrict = district.map(a => a.toLowerCase());
    if (lowerDistrict.includes(a1) && lowerDistrict.includes(a2)) {
      return 2;
    }
  }

  return 3;
}

// ============================================
// FRAUD DETECTION UTILITIES
// ============================================

const PAYMENT_KEYWORDS = [
  'pay', 'money', 'cash', 'mtn', 'momo', 'airtel', 'transfer', 'send',
  'price', 'reward', 'fee', 'cost', 'charge',
  'amafaranga', 'hishyura', 'ohereze'
];

const CONDITIONAL_KEYWORDS = ['first', 'before'];

export function detectExtortionKeywords(message: string): string[] {
  const lower = message.toLowerCase();

  const hasPayment = PAYMENT_KEYWORDS.some(k => lower.includes(k));
  const hasCondition = CONDITIONAL_KEYWORDS.some(k => lower.includes(k));

  // Only flag when it sounds like ‚Äúpay first / pay before‚Ä¶‚Äù
  if (hasPayment && hasCondition) return ['payment_before_return'];

  return [];
}

export function isMessageFlaggable(message: string): { flagged: boolean; reason?: string } {
  const suspicious = detectExtortionKeywords(message);

  if (suspicious.length >= 1) {
    return {
      flagged: true,
      reason: `Message suggests payment before return (${suspicious.join(', ')})`
    };
  }

  return { flagged: false };
}


// ============================================
// DATE UTILITIES
// ============================================

export function getHoursDifference(date1: Date, date2: Date): number {
  const diff = Math.abs(date1.getTime() - date2.getTime());
  return diff / (1000 * 60 * 60);
}

export function getDaysDifference(date1: Date, date2: Date): number {
  return getHoursDifference(date1, date2) / 24;
}

export function isWithinHours(date1: Date, date2: Date, hours: number): boolean {
  return getHoursDifference(date1, date2) <= hours;
}

// ============================================
// VALIDATION UTILITIES
// ============================================

export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

export function isValidPhone(phone: string): boolean {
  const phoneRegex = /^\+?250\d{9}$/;
  return phoneRegex.test(phone.replace(/\s/g, ''));
}

export function sanitizeInput(input: string): string {
  return input
    .replace(/<[^>]*>/g, '') // Remove HTML tags
    .trim();
}

/**
 * Escape special LIKE pattern characters to prevent pattern injection.
 * Use with parameterized queries: WHERE col LIKE $1
 */
export function escapeLikePattern(input: string): string {
  return input
    .replace(/\\/g, '\\\\')
    .replace(/%/g, '\\%')
    .replace(/_/g, '\\_');
}

// ============================================
// ID/PAGINATION UTILITIES
// ============================================

export function generateUUID(): string {
  return crypto.randomUUID();
}

export function parsePaginationParams(
  page?: string | number,
  limit?: string | number
): { page: number; limit: number; offset: number } {
  const parsedPage = Math.max(1, parseInt(String(page)) || 1);
  const parsedLimit = Math.min(100, Math.max(1, parseInt(String(limit)) || 20));
  const offset = (parsedPage - 1) * parsedLimit;

  return { page: parsedPage, limit: parsedLimit, offset };
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/index.swagger-patch.ts
‚îÇ Language: TypeScript | Lines: 32 | Size: 1016 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// ============================================
// ADD THESE IMPORTS at the top of src/index.ts
// (after the existing imports)
// ============================================

import swaggerUi from 'swagger-ui-express';
import { swaggerSpec } from './config/swagger';
import app from '.';

// ============================================
// ADD THIS BLOCK in src/index.ts
// AFTER: app.use('/api/v1', enhancedRoutes);
// BEFORE: // Root endpoint
// ============================================

// Swagger API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
  customCss: '.swagger-ui .topbar { display: none }',
  customSiteTitle: 'Byaboneka+ API Documentation',
  swaggerOptions: {
    persistAuthorization: true,
    docExpansion: 'none',
    filter: true,
    tagsSorter: 'alpha',
  },
}));

// Serve raw OpenAPI JSON spec
app.get('/api-docs.json', (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  res.send(swaggerSpec);
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: src/index.ts
‚îÇ Language: TypeScript | Lines: 216 | Size: 6.5 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import express, { Express, Request, Response, NextFunction } from 'express';
import cors from 'cors';
import helmet from 'helmet';
import morgan from 'morgan';
import dotenv from 'dotenv';
import path from 'path';
import cron from 'node-cron';

import routes from './routes';
import enhancedRoutes from './routes/enhancedRoutes';
import novelFeatureRoutes from './routes/novelFeatureRoutes';
import { checkConnection, closePool, query } from './config/database';
import { apiLimiter } from './middleware/rateLimiter';
import { notFoundHandler, errorHandler } from './middleware/errorHandler';
import { runMigrations } from './migrations/001_initial';

// Load environment variables
dotenv.config();

const app: Express = express();
const PORT = process.env.PORT || 4000;

// ============================================
// MIDDLEWARE
// ============================================

// Security headers
app.use(helmet({
  crossOriginResourcePolicy: { policy: 'cross-origin' }
}));

// CORS ‚Äî support multiple origins for Vercel + localhost
const allowedOrigins = (process.env.CORS_ORIGIN || 'http://localhost:3000')
  .split(',')
  .map(o => o.trim());

app.use(cors({
  origin: (origin, callback) => {
    // Allow requests with no origin (mobile apps, curl, etc.)
    if (!origin) return callback(null, true);
    if (allowedOrigins.includes(origin)) {
      return callback(null, true);
    }
    callback(new Error(`Origin ${origin} not allowed by CORS`));
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

// Request logging
if (process.env.NODE_ENV !== 'test') {
  app.use(morgan('dev'));
}

// Body parsing ‚Äî 1MB default, upload routes handle larger payloads
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// Rate limiting
app.use('/api', apiLimiter);

// Static files for uploads
const uploadPath = process.env.UPLOAD_PATH || './uploads';
app.use('/uploads', express.static(path.resolve(uploadPath)));

// ============================================
// ROUTES
// ============================================

// API routes (core + enhanced)
app.use('/api/v1', routes);
app.use('/api/v1', enhancedRoutes);
app.use('/api/v1', novelFeatureRoutes);

// Root endpoint
app.get('/', (req: Request, res: Response) => {
  res.json({
    name: 'Byaboneka+ API',
    version: '1.0.0',
    description: 'Trust-Aware Lost & Found Infrastructure for Rwanda',
    health: '/api/v1/health'
  });
});

// ============================================
// ERROR HANDLING (using middleware from errorHandler.ts)
// ============================================

app.use(notFoundHandler);
app.use(errorHandler);

// ============================================
// SCHEDULED JOBS
// ============================================

// Auto-expire old reports (daily at 2 AM)
cron.schedule('0 2 * * *', async () => {
  console.log('üïê Running auto-expiry job...');
  try {
    const expiredLost = await query(`
      UPDATE lost_items 
      SET status = 'EXPIRED', expired_at = NOW()
      WHERE status = 'ACTIVE' 
      AND updated_at < NOW() - INTERVAL '30 days'
      RETURNING id
    `);

    const expiredFound = await query(`
      UPDATE found_items 
      SET status = 'EXPIRED', expired_at = NOW()
      WHERE status = 'UNCLAIMED' 
      AND updated_at < NOW() - INTERVAL '30 days'
      RETURNING id
    `);

    const expiredClaims = await query(`
      UPDATE claims 
      SET status = 'EXPIRED'
      WHERE status = 'PENDING' 
      AND created_at < NOW() - INTERVAL '7 days'
      RETURNING id
    `);

    console.log(`‚úÖ Expired: ${expiredLost.rowCount} lost items, ${expiredFound.rowCount} found items, ${expiredClaims.rowCount} claims`);
  } catch (error) {
    console.error('‚ùå Auto-expiry job failed:', error);
  }
});

// Send expiry warnings (daily at 1 AM)
cron.schedule('0 1 * * *', async () => {
  console.log('üïê Sending expiry warnings...');
  try {
    await query(`
      UPDATE lost_items 
      SET expiry_warning_sent = true
      WHERE status = 'ACTIVE' 
      AND updated_at < NOW() - INTERVAL '23 days'
      AND expiry_warning_sent = false
    `);

    await query(`
      UPDATE found_items 
      SET expiry_warning_sent = true
      WHERE status = 'UNCLAIMED' 
      AND updated_at < NOW() - INTERVAL '23 days'
      AND expiry_warning_sent = false
    `);

    console.log('‚úÖ Expiry warnings sent');
  } catch (error) {
    console.error('‚ùå Expiry warning job failed:', error);
  }
});

// ============================================
// SERVER STARTUP
// ============================================

async function startServer() {
  try {
    // Check database connection
    const connected = await checkConnection();
    if (!connected) {
      throw new Error('Failed to connect to database');
    }
    console.log('‚úÖ Database connected');

    // Run migrations
    await runMigrations();

    // Create uploads directory if it doesn't exist
    const fs = await import('fs');
    if (!fs.existsSync(uploadPath)) {
      fs.mkdirSync(uploadPath, { recursive: true });
    }

    // Start server
    const server = app.listen(PORT, () => {
      console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                            ‚ïë
‚ïë   üöÄ Byaboneka+ API Server                                 ‚ïë
‚ïë                                                            ‚ïë
‚ïë   Port: ${PORT}                                              ‚ïë
‚ïë   Environment: ${process.env.NODE_ENV || 'development'}                            ‚ïë
‚ïë   API: http://localhost:${PORT}/api/v1                        ‚ïë
‚ïë                                                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
      `);
    });

    // Graceful shutdown
    const shutdown = async () => {
      console.log('\nüõë Shutting down server...');
      server.close(async () => {
        await closePool();
        console.log('‚úÖ Server shut down gracefully');
        process.exit(0);
      });
    };

    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);

  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

startServer();

export default app;




‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  SECTION: tests/
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/integration/api.test.ts
‚îÇ Language: TypeScript | Lines: 319 | Size: 12.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Integration Tests: Full API Workflows
 * Tests the complete user journey with real HTTP requests.
 * Requires DATABASE_URL env var pointing to test database.
 *
 * Flow tested:
 * 1. Register ‚Üí Login ‚Üí Get Profile
 * 2. Create Lost Item ‚Üí Create Found Item ‚Üí Match
 * 3. Create Claim ‚Üí Verify ‚Üí Generate OTP ‚Üí Confirm Handover
 * 4. Messaging ‚Üí Report Scam
 * 5. Admin operations
 */

import supertest from 'supertest';

// Skip integration tests if no DATABASE_URL
const DATABASE_URL = process.env.DATABASE_URL;
const describeIf = DATABASE_URL ? describe : describe.skip;

describeIf('Integration: Full API Flow', () => {
  let app: any;
  let request: ReturnType<typeof supertest>;
  let citizenToken: string;
  let finderToken: string;
  let adminToken: string;
  let citizenId: number;
  let finderId: number;
  let lostItemId: number;
  let foundItemId: number;
  let claimId: number;

  beforeAll(async () => {
    // Dynamic import to avoid loading DB module when skipping
    const { default: expressApp } = await import('../../src/index');
    app = expressApp;
    request = supertest(app);

    // Wait for migrations to complete
    await new Promise(resolve => setTimeout(resolve, 3000));
  });

  afterAll(async () => {
    const { closePool } = await import('../../src/config/database');
    await closePool();
  });

  // ============================================
  // 1. AUTHENTICATION
  // ============================================
  describe('Authentication Flow', () => {
    it('POST /auth/register ‚Äî citizen registration', async () => {
      const res = await request.post('/api/v1/auth/register').send({
        email: 'citizen@test.com',
        password: 'Citizen1Pass!',
        name: 'Test Citizen',
        phone: '+250788111111',
      });
      expect(res.status).toBe(201);
      expect(res.body.success).toBe(true);
      expect(res.body.data.user.role).toBe('citizen');
      expect(res.body.data.tokens.accessToken).toBeDefined();
      citizenToken = res.body.data.tokens.accessToken;
      citizenId = res.body.data.user.id;
    });

    it('POST /auth/register ‚Äî finder registration', async () => {
      const res = await request.post('/api/v1/auth/register').send({
        email: 'finder@test.com',
        password: 'Finder1Pass!',
        name: 'Test Finder',
        phone: '+250788222222',
      });
      expect(res.status).toBe(201);
      finderToken = res.body.data.tokens.accessToken;
      finderId = res.body.data.user.id;
    });

    it('POST /auth/register ‚Äî reject duplicate email', async () => {
      const res = await request.post('/api/v1/auth/register').send({
        email: 'citizen@test.com',
        password: 'Another1Pass!',
        name: 'Duplicate',
      });
      expect(res.status).toBe(409);
    });

    it('POST /auth/login ‚Äî valid login', async () => {
      const res = await request.post('/api/v1/auth/login').send({
        email: 'citizen@test.com',
        password: 'Citizen1Pass!',
      });
      expect(res.status).toBe(200);
      expect(res.body.data.tokens.accessToken).toBeDefined();
      citizenToken = res.body.data.tokens.accessToken;
    });

    it('POST /auth/login ‚Äî invalid password', async () => {
      const res = await request.post('/api/v1/auth/login').send({
        email: 'citizen@test.com',
        password: 'WrongPassword1',
      });
      expect(res.status).toBe(401);
    });

    it('GET /auth/profile ‚Äî authenticated', async () => {
      const res = await request.get('/api/v1/auth/profile')
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data.email).toBe('citizen@test.com');
    });

    it('GET /auth/profile ‚Äî unauthenticated returns 401', async () => {
      const res = await request.get('/api/v1/auth/profile');
      expect(res.status).toBe(401);
    });
  });

  // ============================================
  // 2. LOST & FOUND ITEMS
  // ============================================
  describe('Item Reporting', () => {
    it('POST /lost-items ‚Äî create lost item with verification questions', async () => {
      const res = await request.post('/api/v1/lost-items')
        .set('Authorization', `Bearer ${citizenToken}`)
        .send({
          category: 'PHONE',
          title: 'Samsung Galaxy S23',
          description: 'Black Samsung phone with blue case found near bus station',
          location_area: 'Nyabugogo',
          lost_date: '2026-02-10T14:00:00Z',
          verification_questions: [
            { question: 'What is the wallpaper?', answer: 'my dog' },
            { question: 'What color is the case?', answer: 'blue' },
            { question: 'Lock screen PIN digits?', answer: 'six' },
          ],
        });
      expect(res.status).toBe(201);
      expect(res.body.data.status).toBe('ACTIVE');
      expect(res.body.data.keywords).toBeInstanceOf(Array);
      lostItemId = res.body.data.id;
    });

    it('POST /found-items ‚Äî create found item', async () => {
      const res = await request.post('/api/v1/found-items')
        .set('Authorization', `Bearer ${finderToken}`)
        .send({
          category: 'PHONE',
          title: 'Black Samsung found on KBS bus',
          description: 'Samsung phone with blue case left on bus seat in Nyabugogo area',
          location_area: 'Nyabugogo',
          found_date: '2026-02-10T16:30:00Z',
        });
      expect(res.status).toBe(201);
      expect(res.body.data.source).toBe('CITIZEN');
      foundItemId = res.body.data.id;
    });

    it('GET /lost-items ‚Äî public listing', async () => {
      const res = await request.get('/api/v1/lost-items');
      expect(res.status).toBe(200);
      expect(res.body.data.length).toBeGreaterThanOrEqual(1);
      expect(res.body.pagination).toBeDefined();
    });

    it('GET /lost-items?category=PHONE ‚Äî filtered listing', async () => {
      const res = await request.get('/api/v1/lost-items?category=PHONE');
      expect(res.status).toBe(200);
      res.body.data.forEach((item: any) => {
        expect(item.category).toBe('PHONE');
      });
    });

    it('GET /lost-items/:id/matches ‚Äî matching engine', async () => {
      const res = await request.get(`/api/v1/lost-items/${lostItemId}/matches`)
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      // Should find the matching found item
      if (res.body.data.length > 0) {
        expect(res.body.data[0].score).toBeGreaterThanOrEqual(5);
        expect(res.body.data[0].explanation).toBeInstanceOf(Array);
      }
    });

    it('GET /users/me/lost-items ‚Äî own items', async () => {
      const res = await request.get('/api/v1/users/me/lost-items')
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data.length).toBeGreaterThanOrEqual(1);
    });
  });

  // ============================================
  // 3. CLAIM & VERIFICATION
  // ============================================
  describe('Claim & Verification Flow', () => {
    it('POST /claims ‚Äî create claim', async () => {
      const res = await request.post('/api/v1/claims')
        .set('Authorization', `Bearer ${citizenToken}`)
        .send({ lost_item_id: lostItemId, found_item_id: foundItemId });
      expect(res.status).toBe(201);
      expect(res.body.data.status).toBe('PENDING');
      claimId = res.body.data.id;
    });

    it('POST /claims ‚Äî reject duplicate active claim', async () => {
      const res = await request.post('/api/v1/claims')
        .set('Authorization', `Bearer ${citizenToken}`)
        .send({ lost_item_id: lostItemId, found_item_id: foundItemId });
      expect(res.status).toBe(409);
    });

    it('GET /claims/:id/questions ‚Äî get verification questions', async () => {
      const res = await request.get(`/api/v1/claims/${claimId}/questions`)
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data.questions).toHaveLength(3);
      expect(res.body.data.attempts_remaining).toBe(3);
    });

    it('POST /claims/:id/verify ‚Äî wrong answers fail', async () => {
      const res = await request.post(`/api/v1/claims/${claimId}/verify`)
        .set('Authorization', `Bearer ${citizenToken}`)
        .send({ answers: ['wrong', 'wrong', 'wrong'] });
      expect(res.status).toBe(200);
      expect(res.body.data.passed).toBe(false);
      expect(res.body.data.score).toBe(0);
    });

    it('POST /claims/:id/verify ‚Äî correct answers pass (2/3)', async () => {
      const res = await request.post(`/api/v1/claims/${claimId}/verify`)
        .set('Authorization', `Bearer ${citizenToken}`)
        .send({ answers: ['my dog', 'blue', 'wrong answer'] });
      expect(res.status).toBe(200);
      expect(res.body.data.passed).toBe(true);
      expect(res.body.data.score).toBeGreaterThanOrEqual(2);
    });

    it('GET /claims/:id ‚Äî claim is now VERIFIED', async () => {
      const res = await request.get(`/api/v1/claims/${claimId}`)
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data.status).toBe('VERIFIED');
    });
  });

  // ============================================
  // 4. HANDOVER (OTP)
  // ============================================
  describe('OTP Handover Flow', () => {
    let otp: string;

    it('POST /claims/:id/handover/otp ‚Äî generate OTP (owner)', async () => {
      const res = await request.post(`/api/v1/claims/${claimId}/handover/otp`)
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data.otp).toMatch(/^\d{6}$/);
      otp = res.body.data.otp;
    });

    it('POST /claims/:id/handover/verify ‚Äî wrong OTP rejected', async () => {
      const res = await request.post(`/api/v1/claims/${claimId}/handover/verify`)
        .set('Authorization', `Bearer ${finderToken}`)
        .send({ otp: '000000' });
      expect(res.status).toBe(400);
    });

    it('POST /claims/:id/handover/verify ‚Äî correct OTP completes return', async () => {
      const res = await request.post(`/api/v1/claims/${claimId}/handover/verify`)
        .set('Authorization', `Bearer ${finderToken}`)
        .send({ otp });
      expect(res.status).toBe(200);
      expect(res.body.success).toBe(true);
    });

    it('claim status is now RETURNED', async () => {
      const res = await request.get(`/api/v1/claims/${claimId}`)
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.body.data.status).toBe('RETURNED');
    });
  });

  // ============================================
  // 5. MESSAGING
  // ============================================
  describe('Messaging', () => {
    it('POST /messages/threads/:claimId ‚Äî send message', async () => {
      const res = await request.post(`/api/v1/messages/threads/${claimId}`)
        .set('Authorization', `Bearer ${citizenToken}`)
        .send({ content: 'Thank you for finding my phone!' });
      expect(res.status).toBe(201);
    });

    it('GET /messages/threads/:claimId ‚Äî get messages', async () => {
      const res = await request.get(`/api/v1/messages/threads/${claimId}`)
        .set('Authorization', `Bearer ${citizenToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data.length).toBeGreaterThanOrEqual(1);
    });

    it('GET /messages/unread-count', async () => {
      const res = await request.get('/api/v1/messages/unread-count')
        .set('Authorization', `Bearer ${finderToken}`);
      expect(res.status).toBe(200);
      expect(res.body.data).toHaveProperty('count');
    });
  });

  // ============================================
  // 6. SYSTEM
  // ============================================
  describe('System Endpoints', () => {
    it('GET /health ‚Äî returns ok', async () => {
      const res = await request.get('/api/v1/health');
      expect(res.status).toBe(200);
      expect(res.body.status).toBe('ok');
      expect(res.body.database).toBe('connected');
    });
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/unit/matching.test.ts
‚îÇ Language: TypeScript | Lines: 143 | Size: 5.2 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Unit Tests: Matching Algorithm
 * Tests the scoring logic defined in the spec:
 * - Category match: +5 (required)
 * - Same location area: +3
 * - Within 72 hours: +2
 * - Keyword overlap: +1 per match
 * - Minimum score to display: 5
 */

// We test the pure scoring logic by importing the scoring functions
// If they're not exported, we test indirectly through findMatchesForLostItem

describe('Matching Score Calculation', () => {
  // Score constants from spec
  const CATEGORY_MATCH = 5;
  const LOCATION_MATCH = 3;
  const TIME_WINDOW_MATCH = 2;
  const KEYWORD_MATCH = 1;
  const MIN_DISPLAY_SCORE = 5;

  // Helper to calculate score (mirrors matchingService logic)
  function calculateScore(params: {
    sameCategory: boolean;
    sameLocation: boolean;
    withinTimeWindow: boolean;
    keywordOverlap: number;
  }): number {
    let score = 0;
    if (params.sameCategory) score += CATEGORY_MATCH;
    if (params.sameLocation) score += LOCATION_MATCH;
    if (params.withinTimeWindow) score += TIME_WINDOW_MATCH;
    score += params.keywordOverlap * KEYWORD_MATCH;
    return score;
  }

  it('should score category match as +5', () => {
    expect(calculateScore({
      sameCategory: true, sameLocation: false, withinTimeWindow: false, keywordOverlap: 0,
    })).toBe(5);
  });

  it('should score category + location as +8', () => {
    expect(calculateScore({
      sameCategory: true, sameLocation: true, withinTimeWindow: false, keywordOverlap: 0,
    })).toBe(8);
  });

  it('should score full match with keywords', () => {
    expect(calculateScore({
      sameCategory: true, sameLocation: true, withinTimeWindow: true, keywordOverlap: 3,
    })).toBe(13); // 5+3+2+3
  });

  it('should not meet threshold without category match', () => {
    const score = calculateScore({
      sameCategory: false, sameLocation: true, withinTimeWindow: true, keywordOverlap: 2,
    });
    // 0+3+2+2 = 7 but without category match this should not be displayed
    // The actual service requires category match, but score alone would be 7
    expect(score).toBe(7);
  });

  it('should meet minimum display score with category only', () => {
    const score = calculateScore({
      sameCategory: true, sameLocation: false, withinTimeWindow: false, keywordOverlap: 0,
    });
    expect(score).toBeGreaterThanOrEqual(MIN_DISPLAY_SCORE);
  });

  it('should score keyword overlap incrementally', () => {
    const score0 = calculateScore({ sameCategory: true, sameLocation: false, withinTimeWindow: false, keywordOverlap: 0 });
    const score3 = calculateScore({ sameCategory: true, sameLocation: false, withinTimeWindow: false, keywordOverlap: 3 });
    expect(score3 - score0).toBe(3);
  });
});

describe('Time Window Matching', () => {
  const WINDOW_HOURS = 72;

  function isWithinWindow(lostDate: Date, foundDate: Date): boolean {
    const diffMs = Math.abs(foundDate.getTime() - lostDate.getTime());
    const diffHours = diffMs / (1000 * 60 * 60);
    return diffHours <= WINDOW_HOURS;
  }

  it('should match items within 72 hours', () => {
    const lost = new Date('2026-02-10T10:00:00Z');
    const found = new Date('2026-02-11T10:00:00Z'); // 24h later
    expect(isWithinWindow(lost, found)).toBe(true);
  });

  it('should match items at exactly 72 hours', () => {
    const lost = new Date('2026-02-10T10:00:00Z');
    const found = new Date('2026-02-13T10:00:00Z'); // exactly 72h
    expect(isWithinWindow(lost, found)).toBe(true);
  });

  it('should not match items beyond 72 hours', () => {
    const lost = new Date('2026-02-10T10:00:00Z');
    const found = new Date('2026-02-13T11:00:00Z'); // 73h
    expect(isWithinWindow(lost, found)).toBe(false);
  });

  it('should work when found date is before lost date', () => {
    const lost = new Date('2026-02-12T10:00:00Z');
    const found = new Date('2026-02-11T10:00:00Z'); // found before "lost" date
    expect(isWithinWindow(lost, found)).toBe(true);
  });
});

describe('Location Matching', () => {
  // Kigali areas from matchingService
  const KIGALI_AREAS: Record<string, string[]> = {
    'Nyarugenge': ['Nyabugogo', 'Biryogo', 'Gitega', 'Muhima', 'Nyamirambo'],
    'Kicukiro': ['Gikondo', 'Kicukiro Centre', 'Niboye', 'Kanombe'],
    'Gasabo': ['Kimironko', 'Remera', 'Gisozi', 'Kacyiru', 'Kibagabaga'],
  };

  function getDistrict(location: string): string | null {
    const lower = location.toLowerCase();
    for (const [district, areas] of Object.entries(KIGALI_AREAS)) {
      if (areas.some(a => a.toLowerCase() === lower) || district.toLowerCase() === lower) {
        return district;
      }
    }
    return null;
  }

  it('should identify same-area matches', () => {
    expect(getDistrict('Nyabugogo')).toBe('Nyarugenge');
    expect(getDistrict('Kimironko')).toBe('Gasabo');
  });

  it('should match areas in same district', () => {
    expect(getDistrict('Nyabugogo')).toBe(getDistrict('Muhima')); // Both Nyarugenge
    expect(getDistrict('Kimironko')).toBe(getDistrict('Remera')); // Both Gasabo
  });

  it('should distinguish different districts', () => {
    expect(getDistrict('Nyabugogo')).not.toBe(getDistrict('Kimironko'));
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/unit/middleware.test.ts
‚îÇ Language: TypeScript | Lines: 132 | Size: 4.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Unit Tests: Middleware
 * Tests auth middleware JWT parsing, error handler formatting,
 * and rate limiter configuration.
 */

import { Request, Response, NextFunction } from 'express';
import { generateAccessToken } from '../../src/utils';
import { UserRole } from '../../src/types';

// Mock request/response helpers
function mockReq(overrides: Partial<Request> = {}): Request {
  return {
    headers: {},
    user: undefined,
    ...overrides,
  } as any;
}

function mockRes(): Response & { _status: number; _json: any } {
  const res: any = {
    _status: 200,
    _json: null,
    status(code: number) { this._status = code; return this; },
    json(data: any) { this._json = data; return this; },
  };
  return res;
}

describe('Auth Middleware Logic', () => {
  // Test the token extraction logic (mirrors auth.ts authenticate)
  function extractToken(authHeader?: string): string | null {
    if (!authHeader) return null;
    if (!authHeader.startsWith('Bearer ')) return null;
    return authHeader.slice(7);
  }

  it('should extract token from valid Bearer header', () => {
    expect(extractToken('Bearer abc123')).toBe('abc123');
  });

  it('should return null for missing header', () => {
    expect(extractToken(undefined)).toBeNull();
  });

  it('should return null for non-Bearer scheme', () => {
    expect(extractToken('Basic abc123')).toBeNull();
  });

  it('should return null for empty Bearer', () => {
    expect(extractToken('Bearer ')).toBe('');
  });
});

describe('Error Response Formatting', () => {
  // Mirrors errorHandler.ts response structure
  function formatError(statusCode: number, message: string, stack?: string) {
    const response: any = {
      success: false,
      message,
    };
    if (process.env.NODE_ENV === 'development' && stack) {
      response.stack = stack;
    }
    return response;
  }

  it('should include success: false', () => {
    expect(formatError(500, 'Server error').success).toBe(false);
  });

  it('should include message', () => {
    expect(formatError(404, 'Not found').message).toBe('Not found');
  });

  it('should not include stack in production', () => {
    const original = process.env.NODE_ENV;
    process.env.NODE_ENV = 'production';
    expect(formatError(500, 'err', 'stack trace').stack).toBeUndefined();
    process.env.NODE_ENV = original;
  });
});

describe('Role Authorization Logic', () => {
  // Mirrors auth.ts authorize function
  function isAuthorized(userRole: string, requiredRoles: string[]): boolean {
    return requiredRoles.includes(userRole);
  }

  it('should allow admin for admin-only routes', () => {
    expect(isAuthorized('admin', ['admin'])).toBe(true);
  });

  it('should reject citizen from admin routes', () => {
    expect(isAuthorized('citizen', ['admin'])).toBe(false);
  });

  it('should allow coop_staff for coop/admin routes', () => {
    expect(isAuthorized('coop_staff', ['admin', 'coop_staff'])).toBe(true);
  });

  it('should reject coop_staff from admin-only', () => {
    expect(isAuthorized('coop_staff', ['admin'])).toBe(false);
  });
});

describe('Rate Limiter Configuration', () => {
  // Verify rate limit values match spec Section 9.2
  const SPEC_LIMITS = {
    reportCreation: 5,      // 5 per day per user
    claimAttempts: 3,       // 3 per item per day
    messages: 50,           // 50 per hour
    apiRequests: 100,       // 100 per minute per IP
    loginAttempts: 10,      // Not explicit in spec but in rateLimiter
  };

  it('report creation limit matches spec (5/day)', () => {
    expect(SPEC_LIMITS.reportCreation).toBe(5);
  });

  it('claim attempts limit matches spec (3/day)', () => {
    expect(SPEC_LIMITS.claimAttempts).toBe(3);
  });

  it('message limit matches spec (50/hour)', () => {
    expect(SPEC_LIMITS.messages).toBe(50);
  });

  it('API rate limit matches spec (100/min)', () => {
    expect(SPEC_LIMITS.apiRequests).toBe(100);
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/unit/novel-features.test.ts
‚îÇ Language: TypeScript | Lines: 262 | Size: 8.9 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * ============================================
 * UNIT TESTS FOR NOVEL FEATURES
 * ============================================
 * 
 * Test coverage for:
 * - Verification Strength Analyzer
 * - Sensitive Item Redaction
 * - Cooperative Accountability scoring math
 * 
 * Run with: npx jest tests/unit/novel-features.test.ts
 */

// ‚îÄ‚îÄ Mock database before imports ‚îÄ‚îÄ
jest.mock('../../src/config/database', () => ({
  query: jest.fn(),
}));

jest.mock('../../src/services/auditService', () => ({
  logAudit: jest.fn(),
}));

import {
  analyzeVerificationStrength,
  getTemplatesForCategory,
  QUESTION_TEMPLATES,
} from '../../src/services/verificationStrengthService';

import {
  redactSensitiveContent,
  redactItemList,
} from '../../src/services/sensitiveRedactionService';

// ============================================
// VERIFICATION STRENGTH TESTS
// ============================================

describe('Verification Strength Analyzer', () => {
  
  describe('analyzeVerificationStrength', () => {
    
    it('should rate strong questions as STRONG', () => {
      const result = analyzeVerificationStrength(
        [
          'How many cards are inside the wallet?',
          'Describe the keychain attached to the keys',
          'What specific app is on the phone home screen?'
        ],
        ['three cards', 'small wooden elephant', 'whatsapp business'],
        'WALLET',
        'Black leather wallet lost near Kimironko'
      );
      
      expect(result.overall_strength).not.toBe('WEAK');
      expect(result.overall_score).toBeGreaterThanOrEqual(40);
    });

    it('should rate yes/no questions as WEAK', () => {
      const result = analyzeVerificationStrength(
        ['Is it black?', 'Is it mine?', 'Was it lost?'],
        ['yes', 'yes', 'yes'],
        'PHONE',
        'Black phone lost in Remera'
      );
      
      expect(result.overall_strength).toBe('WEAK');
      expect(result.questions[0].issues).toContain('Yes/no questions are easy to guess (50% chance)');
    });

    it('should flag answers that appear in the item description', () => {
      const result = analyzeVerificationStrength(
        ['What color is the phone?', 'What brand?', 'What model?'],
        ['black', 'samsung', 'galaxy s21'],
        'PHONE',
        'Black Samsung Galaxy S21 lost at Nyabugogo bus stop'
      );

      // At least one question should flag the answer-in-description issue
      const flagged = result.questions.filter(q => 
        q.issues.some(i => i.includes('answer appears in the item description'))
      );
      expect(flagged.length).toBeGreaterThan(0);
    });

    it('should detect redundant questions', () => {
      const result = analyzeVerificationStrength(
        ['What color is the phone?', 'What colour is the phone case?', 'Describe the phone color'],
        ['black', 'black case', 'dark black'],
        'PHONE',
        'Phone lost'
      );

      expect(result.redundancy_warning).toBe(true);
    });

    it('should penalize very short answers', () => {
      const result = analyzeVerificationStrength(
        ['Describe the item', 'What is unique about it?', 'Secret detail?'],
        ['x', 'y', 'z'],
        'OTHER',
        'Lost item'
      );

      result.questions.forEach(q => {
        expect(q.issues.some(i => i.includes('too short'))).toBe(true);
      });
    });

    it('should give bonus for specific question patterns', () => {
      const specific = analyzeVerificationStrength(
        ['How many compartments does the bag have?'],
        ['three compartments with a hidden zipper'],
        'BAG',
        'Lost bag'
      );

      const generic = analyzeVerificationStrength(
        ['Is it a bag?'],
        ['yes'],
        'BAG',
        'Lost bag'
      );

      expect(specific.questions[0].score).toBeGreaterThan(generic.questions[0].score);
    });
  });

  describe('getTemplatesForCategory', () => {
    
    it('should return PHONE templates for PHONE category', () => {
      const templates = getTemplatesForCategory('PHONE');
      expect(templates.length).toBeGreaterThan(0);
      expect(templates[0].category).toBe('PHONE');
      expect(templates.some(t => t.question.toLowerCase().includes('lockscreen'))).toBe(true);
    });

    it('should return OTHER templates for unknown category', () => {
      const templates = getTemplatesForCategory('SPACESHIP');
      expect(templates.length).toBeGreaterThan(0);
      expect(templates[0].category).toBe('OTHER');
    });

    it('should have templates for all defined categories', () => {
      const categories = ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'];
      categories.forEach(cat => {
        expect(QUESTION_TEMPLATES[cat]).toBeDefined();
        expect(QUESTION_TEMPLATES[cat].length).toBeGreaterThan(0);
      });
    });
  });
});

// ============================================
// SENSITIVE REDACTION TESTS
// ============================================

describe('Sensitive Item Redaction', () => {
  
  describe('redactSensitiveContent', () => {
    
    it('should redact Rwanda national ID numbers (16 digits starting with 1)', () => {
      const result = redactSensitiveContent(
        'Found ID card number 1199880012345678 near bus stop',
        'ID'
      );
      
      expect(result.redacted_text).not.toContain('1199880012345678');
      expect(result.redacted_text).toContain('1');    // First digit preserved
      expect(result.redacted_text).toContain('8');    // Last digit preserved
      expect(result.redactions_applied.length).toBeGreaterThan(0);
      expect(result.sensitivity_level).toBe('HIGH');
    });

    it('should redact Rwandan phone numbers', () => {
      const result = redactSensitiveContent(
        'Contact me at +250788123456 or 0722987654',
        'OTHER'
      );

      expect(result.redacted_text).not.toContain('788123456');
      expect(result.redacted_text).not.toContain('722987654');
      expect(result.redactions_applied.length).toBeGreaterThan(0);
    });

    it('should redact email addresses', () => {
      const result = redactSensitiveContent(
        'The ID belongs to john.doe@gmail.com',
        'ID'
      );

      expect(result.redacted_text).not.toContain('john.doe@gmail.com');
      expect(result.redacted_text).toContain('j***@gmail.com');
    });

    it('should NOT redact when user is the owner', () => {
      const result = redactSensitiveContent(
        'Found ID card number 1199880012345678',
        'ID',
        true  // isOwner
      );

      expect(result.redacted_text).toContain('1199880012345678');
      expect(result.redactions_applied.length).toBe(0);
      expect(result.sensitivity_level).toBe('NONE');
    });

    it('should return NONE sensitivity for text without sensitive data', () => {
      const result = redactSensitiveContent(
        'Lost my black phone near Kimironko market',
        'PHONE'
      );

      expect(result.redacted_text).toBe('Lost my black phone near Kimironko market');
      expect(result.redactions_applied.length).toBe(0);
    });

    it('should truncate long descriptions for ID/WALLET categories', () => {
      const longText = 'A'.repeat(300);
      const result = redactSensitiveContent(longText, 'ID');

      expect(result.redacted_text.length).toBeLessThan(longText.length);
      expect(result.redacted_text).toContain('Full details visible after verification');
    });

    it('should handle multiple sensitive patterns in one text', () => {
      const result = redactSensitiveContent(
        'Found wallet with ID 1199880012345678, contact john@test.com or call +250788111222',
        'WALLET'
      );

      expect(result.redactions_applied.length).toBeGreaterThanOrEqual(2);
      expect(result.sensitivity_level).toBe('HIGH');
    });
  });

  describe('redactItemList', () => {
    
    it('should redact descriptions for non-owners', () => {
      const items = [
        { user_id: 1, description: 'ID number 1199880012345678', category: 'ID', title: 'Found ID' },
        { user_id: 2, description: 'Black phone found', category: 'PHONE', title: 'Phone' },
      ];

      const redacted = redactItemList(items, 1); // user 1 viewing

      // Item 1: user IS owner, should NOT be redacted
      expect(redacted[0].description).toContain('1199880012345678');
      
      // Item 2: user is NOT owner, but no sensitive patterns, so unchanged
      expect(redacted[1].description).toBe('Black phone found');
    });

    it('should redact for anonymous users (no userId)', () => {
      const items = [
        { user_id: 1, description: 'Call me at +250788999888', category: 'OTHER', title: 'Item' },
      ];

      const redacted = redactItemList(items);
      expect(redacted[0].description).not.toContain('788999888');
    });
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/unit/trust.test.ts
‚îÇ Language: TypeScript | Lines: 114 | Size: 3.4 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Unit Tests: Trust Score System
 * Tests scoring rules from spec CLAIM-06:
 * - Successful return: +3 finder, +2 owner
 * - Failed verification: -2
 * - Multiple failed claims: -5
 * - Scam confirmed: -10
 * - False scam report: -3
 * - Score clamped to [-100, 100]
 */

import { TrustLevel } from '../../src/types';

describe('Trust Score Rules', () => {
  // Mirror the trust level thresholds from trustService
  function getTrustLevel(score: number): TrustLevel {
    if (score <= -20) return TrustLevel.SUSPENDED;
    if (score < 0) return TrustLevel.RESTRICTED;
    if (score < 10) return TrustLevel.NEW;
    if (score < 30) return TrustLevel.ESTABLISHED;
    return TrustLevel.TRUSTED;
  }

  function clamp(score: number): number {
    return Math.max(-100, Math.min(100, score));
  }

  describe('Score Changes', () => {
    it('successful return rewards both parties', () => {
      const finderReward = 3;
      const ownerReward = 2;
      expect(clamp(0 + finderReward)).toBe(3);
      expect(clamp(0 + ownerReward)).toBe(2);
    });

    it('failed verification penalizes claimer', () => {
      expect(clamp(5 + (-2))).toBe(3);
    });

    it('multiple failed claims penalizes more', () => {
      expect(clamp(5 + (-5))).toBe(0);
    });

    it('confirmed scam is severe penalty', () => {
      expect(clamp(10 + (-10))).toBe(0);
    });

    it('false scam report penalizes reporter', () => {
      expect(clamp(5 + (-3))).toBe(2);
    });

    it('score cannot exceed 100', () => {
      expect(clamp(99 + 5)).toBe(100);
    });

    it('score cannot go below -100', () => {
      expect(clamp(-98 + (-5))).toBe(-100);
    });
  });

  describe('Trust Levels', () => {
    it('SUSPENDED when score <= -20', () => {
      expect(getTrustLevel(-20)).toBe(TrustLevel.SUSPENDED);
      expect(getTrustLevel(-50)).toBe(TrustLevel.SUSPENDED);
    });

    it('RESTRICTED when score is -19 to -1', () => {
      expect(getTrustLevel(-1)).toBe(TrustLevel.RESTRICTED);
      expect(getTrustLevel(-19)).toBe(TrustLevel.RESTRICTED);
    });

    it('NEW when score is 0 to 9', () => {
      expect(getTrustLevel(0)).toBe(TrustLevel.NEW);
      expect(getTrustLevel(9)).toBe(TrustLevel.NEW);
    });

    it('ESTABLISHED when score is 10 to 29', () => {
      expect(getTrustLevel(10)).toBe(TrustLevel.ESTABLISHED);
      expect(getTrustLevel(29)).toBe(TrustLevel.ESTABLISHED);
    });

    it('TRUSTED when score >= 30', () => {
      expect(getTrustLevel(30)).toBe(TrustLevel.TRUSTED);
      expect(getTrustLevel(100)).toBe(TrustLevel.TRUSTED);
    });
  });

  describe('Progressive Cooldown', () => {
    // From spec CLAIM-05: 1hr after 1st fail, 4hr after 2nd, 24hr after 3rd
    function getCooldownMinutes(failuresToday: number): number {
      if (failuresToday <= 0) return 0;
      if (failuresToday === 1) return 60;
      if (failuresToday === 2) return 240;
      return 1440;
    }

    it('no cooldown for first attempt', () => {
      expect(getCooldownMinutes(0)).toBe(0);
    });

    it('1 hour after first failure', () => {
      expect(getCooldownMinutes(1)).toBe(60);
    });

    it('4 hours after second failure', () => {
      expect(getCooldownMinutes(2)).toBe(240);
    });

    it('24 hours after third+ failure', () => {
      expect(getCooldownMinutes(3)).toBe(1440);
      expect(getCooldownMinutes(5)).toBe(1440);
    });
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/unit/utils.test.ts
‚îÇ Language: TypeScript | Lines: 167 | Size: 5.8 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import {
  hashPassword, verifyPassword, hashSecretAnswer, verifySecretAnswer,
  generateAccessToken, generateRefreshToken, verifyAccessToken, verifyRefreshToken,
  generateOTP, hashOTP, verifyOTP, extractKeywords, parsePaginationParams,
  detectExtortionKeywords, hashToken, generateUUID,
} from '../../src/utils';
import { UserRole } from '../../src/types';

describe('Password Hashing', () => {
  it('should hash and verify correctly', async () => {
    const hash = await hashPassword('MySecure1Pass');
    expect(hash).not.toBe('MySecure1Pass');
    expect(await verifyPassword('MySecure1Pass', hash)).toBe(true);
    expect(await verifyPassword('WrongPassword', hash)).toBe(false);
  });

  it('should produce unique hashes (random salt)', async () => {
    const h1 = await hashPassword('same');
    const h2 = await hashPassword('same');
    expect(h1).not.toBe(h2);
  });
});

describe('Secret Answer Hashing', () => {
  it('should verify case-insensitively with whitespace normalization', async () => {
    const { hash, salt } = await hashSecretAnswer('My Dog Buddy');
    expect(await verifySecretAnswer('my dog buddy', hash, salt)).toBe(true);
    expect(await verifySecretAnswer('MY DOG BUDDY', hash, salt)).toBe(true);
    expect(await verifySecretAnswer('  My  Dog  Buddy  ', hash, salt)).toBe(true);
  });

  it('should reject wrong answers', async () => {
    const { hash, salt } = await hashSecretAnswer('correct');
    expect(await verifySecretAnswer('wrong', hash, salt)).toBe(false);
  });

  it('should strip punctuation', async () => {
    const { hash, salt } = await hashSecretAnswer("it's blue!");
    expect(await verifySecretAnswer('its blue', hash, salt)).toBe(true);
  });
});

describe('JWT Tokens', () => {
  const payload = { userId: 1, email: 'test@example.com', role: UserRole.CITIZEN };

  it('should generate and verify access token', () => {
    const token = generateAccessToken(payload);
    expect(token.split('.')).toHaveLength(3);
    const decoded = verifyAccessToken(token);
    expect(decoded.userId).toBe(1);
    expect(decoded.email).toBe('test@example.com');
    expect(decoded.role).toBe('citizen');
  });

  it('should generate and verify refresh token', () => {
    const token = generateRefreshToken(payload);
    const decoded = verifyRefreshToken(token);
    expect(decoded.userId).toBe(1);
  });

  it('should reject invalid tokens', () => {
    expect(() => verifyAccessToken('invalid.token')).toThrow();
  });

  it('should reject tampered tokens', () => {
    const token = generateAccessToken(payload);
    expect(() => verifyAccessToken(token.slice(0, -3) + 'XXX')).toThrow();
  });

  it('should include iat and exp', () => {
    const decoded = verifyAccessToken(generateAccessToken(payload));
    expect(decoded).toHaveProperty('iat');
    expect(decoded).toHaveProperty('exp');
    expect(decoded.exp! - decoded.iat!).toBe(900); // 15 min
  });
});

describe('OTP Generation', () => {
  it('should generate 6-digit numeric OTP', () => {
    expect(generateOTP()).toMatch(/^\d{6}$/);
  });

  it('should produce mostly unique values', () => {
    const set = new Set(Array.from({ length: 100 }, generateOTP));
    expect(set.size).toBeGreaterThan(85);
  });

  it('should hash and verify OTP', async () => {
    const otp = '123456';
    const hash = await hashOTP(otp);
    expect(await verifyOTP('123456', hash)).toBe(true);
    expect(await verifyOTP('654321', hash)).toBe(false);
  });
});

describe('Keyword Extraction', () => {
  it('should extract meaningful keywords', () => {
    const kw = extractKeywords('Samsung Galaxy S23 black phone blue case');
    expect(kw).toContain('samsung');
    expect(kw).toContain('galaxy');
    expect(kw).toContain('black');
    expect(kw).toContain('blue');
  });

  it('should filter stop words', () => {
    const kw = extractKeywords('I lost my phone on the bus');
    expect(kw).not.toContain('i');
    expect(kw).not.toContain('my');
    expect(kw).not.toContain('the');
    expect(kw).toContain('phone');
    expect(kw).toContain('bus');
  });

  it('should handle empty input', () => {
    expect(extractKeywords('')).toEqual([]);
  });

  it('should deduplicate', () => {
    const kw = extractKeywords('phone phone phone');
    expect(kw.filter(k => k === 'phone')).toHaveLength(1);
  });
});

describe('Pagination', () => {
  it('should parse valid params', () => {
    const r = parsePaginationParams('3', '10');
    expect(r).toEqual({ page: 3, limit: 10, offset: 20 });
  });

  it('should default missing values', () => {
    const r = parsePaginationParams(undefined, undefined);
    expect(r.page).toBe(1);
    expect(r.limit).toBe(20);
    expect(r.offset).toBe(0);
  });

  it('should clamp minimum page to 1', () => {
    expect(parsePaginationParams('0', '10').page).toBe(1);
    expect(parsePaginationParams('-1', '10').page).toBe(1);
  });
});

describe('Extortion Detection', () => {
  it('should detect extortion keywords', () => {
    expect(detectExtortionKeywords('send me money first')).toHaveLength(1);
    expect(detectExtortionKeywords('pay before I give it back')).toHaveLength(1);
  });

  it('should return empty for normal messages', () => {
    expect(detectExtortionKeywords('Hi, when can we meet?')).toHaveLength(0);
    expect(detectExtortionKeywords('I found your phone at KBS')).toHaveLength(0);
  });
});

describe('Utility Functions', () => {
  it('hashToken should produce consistent SHA-256', () => {
    const h1 = hashToken('test');
    const h2 = hashToken('test');
    expect(h1).toBe(h2);
    expect(h1.length).toBe(64); // SHA-256 hex
  });

  it('generateUUID should produce valid UUIDs', () => {
    const uuid = generateUUID();
    expect(uuid).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/);
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/unit/validation.test.ts
‚îÇ Language: TypeScript | Lines: 191 | Size: 6.4 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import {
  registerSchema, loginSchema, createLostItemSchema, createFoundItemSchema,
  createClaimSchema, verifyClaimSchema, verifyOtpSchema, sendMessageSchema,
  createCooperativeSchema, banUserSchema,
} from '../../src/middleware/validation';

describe('Register Schema', () => {
  const valid = { email: 'test@example.com', password: 'MySecure1P', name: 'Jean' };

  it('should accept valid registration', () => {
    expect(() => registerSchema.parse(valid)).not.toThrow();
  });

  it('should accept with optional phone', () => {
    expect(() => registerSchema.parse({ ...valid, phone: '+250788123456' })).not.toThrow();
  });

  it('should reject invalid email', () => {
    expect(() => registerSchema.parse({ ...valid, email: 'not-email' })).toThrow();
  });

  it('should reject weak password (no uppercase)', () => {
    expect(() => registerSchema.parse({ ...valid, password: 'nouppercase1' })).toThrow();
  });

  it('should reject weak password (no number)', () => {
    expect(() => registerSchema.parse({ ...valid, password: 'NoNumberHere' })).toThrow();
  });

  it('should reject short password', () => {
    expect(() => registerSchema.parse({ ...valid, password: 'Ab1' })).toThrow();
  });

  it('should reject short name', () => {
    expect(() => registerSchema.parse({ ...valid, name: 'J' })).toThrow();
  });

  it('should reject invalid Rwandan phone', () => {
    expect(() => registerSchema.parse({ ...valid, phone: '+1234567890' })).toThrow();
  });
});

describe('Login Schema', () => {
  it('should accept valid login', () => {
    expect(() => loginSchema.parse({ email: 'a@b.com', password: 'x' })).not.toThrow();
  });

  it('should reject missing email', () => {
    expect(() => loginSchema.parse({ password: 'x' })).toThrow();
  });
});

describe('Create Lost Item Schema', () => {
  const valid = {
    category: 'PHONE',
    title: 'Lost Samsung',
    description: 'Black Samsung phone with blue case found on bus',
    location_area: 'Nyabugogo',
    lost_date: '2026-02-10T14:00:00Z',
    verification_questions: [
      { question: 'What is the wallpaper?', answer: 'my dog' },
      { question: 'What color is the case?', answer: 'blue' },
      { question: 'What is the PIN?', answer: 'six' },
    ],
  };

  it('should accept valid lost item', () => {
    expect(() => createLostItemSchema.parse(valid)).not.toThrow();
  });

  it('should reject invalid category', () => {
    expect(() => createLostItemSchema.parse({ ...valid, category: 'CAR' })).toThrow();
  });

  it('should reject less than 3 questions', () => {
    expect(() => createLostItemSchema.parse({
      ...valid,
      verification_questions: valid.verification_questions.slice(0, 2),
    })).toThrow();
  });

  it('should reject more than 3 questions', () => {
    expect(() => createLostItemSchema.parse({
      ...valid,
      verification_questions: [...valid.verification_questions, { question: 'Extra?', answer: 'x' }],
    })).toThrow();
  });

  it('should reject short title', () => {
    expect(() => createLostItemSchema.parse({ ...valid, title: 'AB' })).toThrow();
  });

  it('should reject short description', () => {
    expect(() => createLostItemSchema.parse({ ...valid, description: 'Too short' })).toThrow();
  });

  it('should accept ISO date string', () => {
    expect(() => createLostItemSchema.parse({ ...valid, lost_date: '2026-02-10' })).not.toThrow();
  });
});

describe('Create Found Item Schema', () => {
  const valid = {
    category: 'WALLET',
    title: 'Brown leather wallet',
    description: 'Found brown wallet at bus stop with some cash inside',
    location_area: 'Kimironko',
    found_date: '2026-02-10T16:00:00Z',
  };

  it('should accept valid found item', () => {
    expect(() => createFoundItemSchema.parse(valid)).not.toThrow();
  });

  it('should accept optional cooperative_id', () => {
    expect(() => createFoundItemSchema.parse({ ...valid, cooperative_id: 1 })).not.toThrow();
  });
});

describe('Claim Schemas', () => {
  it('should accept valid claim', () => {
    expect(() => createClaimSchema.parse({ lost_item_id: 1, found_item_id: 2 })).not.toThrow();
  });

  it('should reject non-positive IDs', () => {
    expect(() => createClaimSchema.parse({ lost_item_id: 0, found_item_id: 2 })).toThrow();
    expect(() => createClaimSchema.parse({ lost_item_id: 1, found_item_id: -1 })).toThrow();
  });

  it('should accept valid verification answers (3 strings)', () => {
    expect(() => verifyClaimSchema.parse({ answers: ['a', 'b', 'c'] })).not.toThrow();
  });

  it('should reject wrong number of answers', () => {
    expect(() => verifyClaimSchema.parse({ answers: ['a', 'b'] })).toThrow();
    expect(() => verifyClaimSchema.parse({ answers: ['a', 'b', 'c', 'd'] })).toThrow();
  });

  it('should reject empty answers', () => {
    expect(() => verifyClaimSchema.parse({ answers: ['', 'b', 'c'] })).toThrow();
  });
});

describe('OTP Schema', () => {
  it('should accept valid 6-digit OTP', () => {
    expect(() => verifyOtpSchema.parse({ otp: '123456' })).not.toThrow();
  });

  it('should reject non-numeric', () => {
    expect(() => verifyOtpSchema.parse({ otp: 'abcdef' })).toThrow();
  });

  it('should reject wrong length', () => {
    expect(() => verifyOtpSchema.parse({ otp: '12345' })).toThrow();
    expect(() => verifyOtpSchema.parse({ otp: '1234567' })).toThrow();
  });
});

describe('Message Schema', () => {
  it('should accept valid message', () => {
    expect(() => sendMessageSchema.parse({ content: 'Hello!' })).not.toThrow();
  });

  it('should reject empty message', () => {
    expect(() => sendMessageSchema.parse({ content: '' })).toThrow();
  });

  it('should reject too long message', () => {
    expect(() => sendMessageSchema.parse({ content: 'x'.repeat(1001) })).toThrow();
  });
});

describe('Cooperative Schema', () => {
  it('should accept valid cooperative', () => {
    expect(() => createCooperativeSchema.parse({
      name: 'KBS Cooperative',
      registration_number: 'RW-2024-001',
      contact_info: '+250788000111',
    })).not.toThrow();
  });
});

describe('Ban User Schema', () => {
  it('should accept valid ban reason', () => {
    expect(() => banUserSchema.parse({ reason: 'Repeated fraud' })).not.toThrow();
  });

  it('should reject short reason', () => {
    expect(() => banUserSchema.parse({ reason: 'bad' })).toThrow();
  });
});


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/integration.test.ts
‚îÇ Language: TypeScript | Lines: 230 | Size: 7.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';

// ============================================
// BYABONEKA+ INTEGRATION TESTS
// Critical Flow Testing
// ============================================

// Note: These tests require a test database connection
// Run with: npm test -- --testPathPattern=integration

describe('Authentication Flow', () => {
  const testUser = {
    email: `test_${Date.now()}@test.com`,
    password: 'TestPass123!',
    name: 'Test User'
  };

  it('should register a new user', async () => {
    // Test implementation would make actual API calls
    expect(testUser.email).toContain('@');
  });

  it('should login with correct credentials', async () => {
    expect(testUser.password.length).toBeGreaterThan(8);
  });

  it('should reject invalid credentials', async () => {
    expect('invalid').not.toBe(testUser.password);
  });

  it('should refresh tokens', async () => {
    expect(true).toBe(true);
  });
});

describe('Lost Item Reporting Flow', () => {
  const testLostItem = {
    category: 'PHONE',
    title: 'Black iPhone 14',
    description: 'Lost on moto near Kimironko',
    location_area: 'Kimironko',
    lost_date: new Date().toISOString(),
    verification_questions: [
      { question: 'What is the lockscreen wallpaper?', answer: 'mountain sunset' },
      { question: 'What phone case color?', answer: 'blue' },
      { question: 'Any scratches?', answer: 'yes on corner' }
    ]
  };

  it('should require 3 verification questions', async () => {
    expect(testLostItem.verification_questions.length).toBe(3);
  });

  it('should extract keywords from title and description', async () => {
    const keywords = ['iphone', 'black', 'moto', 'kimironko'];
    const combined = `${testLostItem.title} ${testLostItem.description}`.toLowerCase();
    expect(keywords.some(k => combined.includes(k))).toBe(true);
  });

  it('should validate category is valid enum', async () => {
    const validCategories = ['PHONE', 'ID', 'WALLET', 'BAG', 'KEYS', 'OTHER'];
    expect(validCategories).toContain(testLostItem.category);
  });
});

describe('Found Item Reporting Flow', () => {
  const testFoundItem = {
    category: 'PHONE',
    title: 'Black smartphone found',
    description: 'Found on bus from Nyabugogo',
    location_area: 'Nyabugogo',
    found_date: new Date().toISOString()
  };

  it('should allow optional photos', async () => {
    expect(testFoundItem).not.toHaveProperty('image_urls');
  });

  it('should validate location area is provided', async () => {
    expect(testFoundItem.location_area).toBeTruthy();
  });
});

describe('Matching Algorithm', () => {
  it('should require category match', async () => {
    const lost = { category: 'PHONE' };
    const found = { category: 'WALLET' };
    expect(lost.category).not.toBe(found.category);
  });

  it('should score same location higher', async () => {
    const sameLocationScore = 5;
    const differentLocationScore = 0;
    expect(sameLocationScore).toBeGreaterThan(differentLocationScore);
  });

  it('should score items within 24h higher than 72h', async () => {
    const within24h = 3;
    const within72h = 2;
    expect(within24h).toBeGreaterThan(within72h);
  });

  it('should return maximum 5 matches', async () => {
    const MAX_MATCHES = 5;
    const mockMatches = [1, 2, 3, 4, 5, 6, 7];
    const result = mockMatches.slice(0, MAX_MATCHES);
    expect(result.length).toBe(5);
  });
});

describe('Verification Challenge', () => {
  it('should pass with 2 of 3 correct answers', async () => {
    const correctCount = 2;
    const threshold = 2;
    expect(correctCount >= threshold).toBe(true);
  });

  it('should fail with 1 of 3 correct answers', async () => {
    const correctCount = 1;
    const threshold = 2;
    expect(correctCount >= threshold).toBe(false);
  });

  it('should rate limit after 3 attempts per day', async () => {
    const attemptsToday = 3;
    const maxAttempts = 3;
    expect(attemptsToday >= maxAttempts).toBe(true);
  });

  it('should normalize answers for comparison', async () => {
    const answer1 = '  Blue CASE  ';
    const answer2 = 'blue case';
    const normalized = answer1.toLowerCase().trim().replace(/\s+/g, ' ');
    expect(normalized).toBe(answer2);
  });
});

describe('OTP Handover Protocol', () => {
  it('should generate 6-digit OTP', async () => {
    const otp = '123456';
    expect(otp.length).toBe(6);
    expect(/^\d+$/.test(otp)).toBe(true);
  });

  it('should expire OTP after 24 hours', async () => {
    const expiryHours = 24;
    expect(expiryHours).toBe(24);
  });

  it('should allow only finder or coop staff to confirm', async () => {
    const roles = ['finder', 'coop_staff'];
    expect(roles.includes('finder')).toBe(true);
    expect(roles.includes('random_user')).toBe(false);
  });

  it('should lock after 3 failed OTP attempts', async () => {
    const attempts = 3;
    const maxAttempts = 3;
    expect(attempts >= maxAttempts).toBe(true);
  });
});

describe('Message Flagging', () => {
  it('should flag messages with extortion keywords', async () => {
    const message = 'Send me money before I return';
    const extortionKeywords = ['money', 'pay', 'send'];
    const found = extortionKeywords.filter(k => message.toLowerCase().includes(k));
    expect(found.length).toBeGreaterThanOrEqual(2);
  });

  it('should not flag normal messages', async () => {
    const message = 'I found your phone at the bus stop';
    const extortionKeywords = ['money', 'pay', 'send'];
    const found = extortionKeywords.filter(k => message.toLowerCase().includes(k));
    expect(found.length).toBeLessThan(2);
  });
});

describe('Trust Score System', () => {
  it('should start users with trust score 0', async () => {
    const newUserTrust = 0;
    expect(newUserTrust).toBe(0);
  });

  it('should increase trust on successful return', async () => {
    const currentTrust = 0;
    const increase = 3;
    expect(currentTrust + increase).toBe(3);
  });

  it('should decrease trust on failed verification', async () => {
    const currentTrust = 5;
    const decrease = -2;
    expect(currentTrust + decrease).toBe(3);
  });
});

describe('Privacy Controls', () => {
  it('should never expose phone numbers publicly', async () => {
    const publicUser = { name: 'John', email: 'j@test.com' };
    expect(publicUser).not.toHaveProperty('phone');
  });

  it('should not show verification answers', async () => {
    const publicItem = { title: 'Lost phone', questions: ['Q1', 'Q2', 'Q3'] };
    expect(publicItem).not.toHaveProperty('answers');
  });
});

describe('Role-Based Access Control', () => {
  it('should restrict admin routes to admin role', async () => {
    const adminRoles = ['admin'];
    const userRole = 'citizen';
    expect(adminRoles.includes(userRole)).toBe(false);
  });

  it('should allow coop_staff to manage cooperative items', async () => {
    const allowedRoles = ['admin', 'coop_staff'];
    const userRole = 'coop_staff';
    expect(allowedRoles.includes(userRole)).toBe(true);
  });

  it('should restrict item editing to owner', async () => {
    const itemOwnerId: number = 1;
    const requestUserId: number = 2;
    const canEdit = Number(itemOwnerId) === Number(requestUserId);
    expect(canEdit).toBe(false);
  });
});



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/matching.test.ts
‚îÇ Language: TypeScript | Lines: 126 | Size: 4.3 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import { computeMatchScore } from '../src/services/matchingService';
import { LostItem, FoundItem, ItemCategory, LostItemStatus, FoundItemStatus, ItemSource } from '../src/types';

describe('Matching Engine', () => {
  // Helper to create mock lost item
  const createLostItem = (overrides: Partial<LostItem> = {}): LostItem => ({
    id: 1,
    user_id: 1,
    category: ItemCategory.PHONE,
    title: 'Black iPhone 13',
    description: 'Lost my black iPhone with blue case',
    location_area: 'Kimironko',
    lost_date: new Date('2024-01-15T10:00:00Z'),
    status: LostItemStatus.ACTIVE,
    keywords: ['black', 'iphone', '13', 'blue', 'case'],
    created_at: new Date(),
    updated_at: new Date(),
    expiry_warning_sent: false,
    ...overrides,
  });

  // Helper to create mock found item
  const createFoundItem = (overrides: Partial<FoundItem> = {}): FoundItem => ({
    id: 1,
    finder_id: 2,
    category: ItemCategory.PHONE,
    title: 'iPhone found at market',
    description: 'Found black iPhone with blue case near market',
    location_area: 'Kimironko',
    found_date: new Date('2024-01-15T14:00:00Z'),
    status: FoundItemStatus.UNCLAIMED,
    source: ItemSource.CITIZEN,
    image_urls: [],
    keywords: ['iphone', 'black', 'blue', 'case', 'market'],
    created_at: new Date(),
    updated_at: new Date(),
    expiry_warning_sent: false,
    ...overrides,
  });

  describe('computeMatchScore', () => {
    it('should return 0 for category mismatch', () => {
      const lost = createLostItem({ category: ItemCategory.PHONE });
      const found = createFoundItem({ category: ItemCategory.WALLET });

      const result = computeMatchScore(lost, found);

      expect(result.score).toBe(0);
      expect(result.explanation).toContain('Category mismatch');
    });

    it('should give +5 for category match', () => {
      const lost = createLostItem();
      const found = createFoundItem();

      const result = computeMatchScore(lost, found);

      expect(result.score).toBeGreaterThanOrEqual(5);
      expect(result.explanation.some(e => e.includes('Category match'))).toBe(true);
    });

    it('should give +5 for same location', () => {
      const lost = createLostItem({ location_area: 'Kimironko' });
      const found = createFoundItem({ location_area: 'Kimironko' });

      const result = computeMatchScore(lost, found);

      expect(result.explanation.some(e => e.includes('Same location'))).toBe(true);
    });

    it('should give +3 for within 24 hours', () => {
      const lostDate = new Date('2024-01-15T10:00:00Z');
      const foundDate = new Date('2024-01-15T18:00:00Z'); // 8 hours later

      const lost = createLostItem({ lost_date: lostDate });
      const found = createFoundItem({ found_date: foundDate });

      const result = computeMatchScore(lost, found);

      expect(result.explanation.some(e => e.includes('24 hours'))).toBe(true);
    });

    it('should give +1 for each keyword match', () => {
      const lost = createLostItem({ keywords: ['black', 'iphone', 'blue'] });
      const found = createFoundItem({ keywords: ['black', 'iphone', 'green'] });

      const result = computeMatchScore(lost, found);

      // Should match 'black' and 'iphone'
      const keywordMatches = result.explanation.filter(e => e.includes('Keyword'));
      expect(keywordMatches.length).toBe(2);
    });

    it('should calculate high score for perfect match', () => {
      const lost = createLostItem({
        category: ItemCategory.PHONE,
        location_area: 'Kimironko',
        lost_date: new Date('2024-01-15T10:00:00Z'),
        keywords: ['black', 'iphone', 'blue', 'case']
      });

      const found = createFoundItem({
        category: ItemCategory.PHONE,
        location_area: 'Kimironko',
        found_date: new Date('2024-01-15T14:00:00Z'),
        keywords: ['black', 'iphone', 'blue', 'case']
      });

      const result = computeMatchScore(lost, found);

      // Category (5) + Location (5) + Time (3) + Keywords (4) = 17
      expect(result.score).toBeGreaterThanOrEqual(15);
    });

    it('should handle empty keywords gracefully', () => {
      const lost = createLostItem({ keywords: [] });
      const found = createFoundItem({ keywords: [] });

      const result = computeMatchScore(lost, found);

      // Should still calculate score without keywords
      expect(result.score).toBeGreaterThan(0);
    });
  });
});



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/setup.ts
‚îÇ Language: TypeScript | Lines: 25 | Size: 596 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

// Test setup file
import dotenv from 'dotenv';

// Load test environment
dotenv.config({ path: '.env.test' });

// Set test environment
process.env.NODE_ENV = 'test';

// Global test setup
process.env.NODE_ENV = 'test';
process.env.JWT_SECRET = 'test_jwt_secret_min_32_characters_long_for_testing!!';
process.env.JWT_REFRESH_SECRET = 'test_refresh_secret_min_32_characters_long_test!!';

// Increase timeout for database operations
jest.setTimeout(10000);

// Mock console.log in tests to reduce noise
global.console = {
  ...console,
  log: jest.fn(),
  debug: jest.fn(),
  info: jest.fn(),
};



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/trust.test.ts
‚îÇ Language: TypeScript | Lines: 143 | Size: 4.8 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Trust Service Tests
 * Tests for trust score calculations
 */

import { getTrustLevel, getClaimAttemptLimit, getReportDailyLimit, TRUST_CHANGES } from '../src/utils';
import { TrustLevel } from '../src/types';

describe('Trust Score Utilities', () => {
  describe('getTrustLevel', () => {
    it('should return SUSPENDED for very negative scores', () => {
      expect(getTrustLevel(-15)).toBe(TrustLevel.SUSPENDED);
      expect(getTrustLevel(-20)).toBe(TrustLevel.SUSPENDED);
      expect(getTrustLevel(-100)).toBe(TrustLevel.SUSPENDED);
    });

    it('should return RESTRICTED for moderately negative scores', () => {
      expect(getTrustLevel(-5)).toBe(TrustLevel.RESTRICTED);
      expect(getTrustLevel(-1)).toBe(TrustLevel.RESTRICTED);
      expect(getTrustLevel(-9)).toBe(TrustLevel.RESTRICTED);
    });

    it('should return NEW for low positive scores', () => {
      expect(getTrustLevel(0)).toBe(TrustLevel.NEW);
      expect(getTrustLevel(1)).toBe(TrustLevel.NEW);
      expect(getTrustLevel(4)).toBe(TrustLevel.NEW);
    });

    it('should return ESTABLISHED for medium scores', () => {
      expect(getTrustLevel(5)).toBe(TrustLevel.ESTABLISHED);
      expect(getTrustLevel(10)).toBe(TrustLevel.ESTABLISHED);
      expect(getTrustLevel(14)).toBe(TrustLevel.ESTABLISHED);
    });

    it('should return TRUSTED for high scores', () => {
      expect(getTrustLevel(15)).toBe(TrustLevel.TRUSTED);
      expect(getTrustLevel(50)).toBe(TrustLevel.TRUSTED);
      expect(getTrustLevel(100)).toBe(TrustLevel.TRUSTED);
    });
  });

  describe('getClaimAttemptLimit', () => {
    it('should return 0 for SUSPENDED', () => {
      expect(getClaimAttemptLimit(TrustLevel.SUSPENDED)).toBe(0);
    });

    it('should return 1 for RESTRICTED', () => {
      expect(getClaimAttemptLimit(TrustLevel.RESTRICTED)).toBe(1);
    });

    it('should return 3 for NEW', () => {
      expect(getClaimAttemptLimit(TrustLevel.NEW)).toBe(3);
    });

    it('should return 5 for ESTABLISHED', () => {
      expect(getClaimAttemptLimit(TrustLevel.ESTABLISHED)).toBe(5);
    });

    it('should return 7 for TRUSTED', () => {
      expect(getClaimAttemptLimit(TrustLevel.TRUSTED)).toBe(7);
    });
  });

  describe('getReportDailyLimit', () => {
    it('should return 0 for SUSPENDED', () => {
      expect(getReportDailyLimit(TrustLevel.SUSPENDED)).toBe(0);
    });

    it('should return 1 for RESTRICTED', () => {
      expect(getReportDailyLimit(TrustLevel.RESTRICTED)).toBe(1);
    });

    it('should return 3 for NEW', () => {
      expect(getReportDailyLimit(TrustLevel.NEW)).toBe(3);
    });

    it('should return 5 for ESTABLISHED', () => {
      expect(getReportDailyLimit(TrustLevel.ESTABLISHED)).toBe(5);
    });

    it('should return 10 for TRUSTED', () => {
      expect(getReportDailyLimit(TrustLevel.TRUSTED)).toBe(10);
    });
  });

  describe('TRUST_CHANGES constants', () => {
    it('should have positive values for good actions', () => {
      expect(TRUST_CHANGES.SUCCESSFUL_RETURN_FINDER).toBeGreaterThan(0);
      expect(TRUST_CHANGES.SUCCESSFUL_RECOVERY_OWNER).toBeGreaterThan(0);
      expect(TRUST_CHANGES.EMAIL_VERIFIED).toBeGreaterThan(0);
      expect(TRUST_CHANGES.PHONE_VERIFIED).toBeGreaterThan(0);
    });

    it('should have negative values for bad actions', () => {
      expect(TRUST_CHANGES.FAILED_VERIFICATION).toBeLessThan(0);
      expect(TRUST_CHANGES.MULTIPLE_FAILED_CLAIMS).toBeLessThan(0);
      expect(TRUST_CHANGES.SCAM_REPORTED).toBeLessThan(0);
      expect(TRUST_CHANGES.SCAM_CONFIRMED).toBeLessThan(0);
    });

    it('should have appropriate magnitudes', () => {
      // Successful returns should be worth more than verifications
      expect(TRUST_CHANGES.SUCCESSFUL_RETURN_FINDER).toBeGreaterThanOrEqual(TRUST_CHANGES.EMAIL_VERIFIED);
      // Confirmed scam should be very negative
      expect(TRUST_CHANGES.SCAM_CONFIRMED).toBeLessThan(-10);
    });
  });

  describe('Trust Level Progression', () => {
    it('should progress through levels as score increases', () => {
      const scores = [-20, -5, 0, 7, 20];
      const expectedLevels = [
        TrustLevel.SUSPENDED,
        TrustLevel.RESTRICTED,
        TrustLevel.NEW,
        TrustLevel.ESTABLISHED,
        TrustLevel.TRUSTED
      ];

      scores.forEach((score, index) => {
        expect(getTrustLevel(score)).toBe(expectedLevels[index]);
      });
    });

    it('should have increasing claim limits with trust levels', () => {
      const levels = [
        TrustLevel.SUSPENDED,
        TrustLevel.RESTRICTED,
        TrustLevel.NEW,
        TrustLevel.ESTABLISHED,
        TrustLevel.TRUSTED
      ];

      let previousLimit = -1;
      levels.forEach(level => {
        const limit = getClaimAttemptLimit(level);
        expect(limit).toBeGreaterThanOrEqual(previousLimit);
        previousLimit = limit;
      });
    });
  });
});



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/utils.test.ts
‚îÇ Language: TypeScript | Lines: 395 | Size: 13.0 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

import {
  extractKeywords,
  getTrustLevel,
  computeLocationDistance,
  isMessageFlaggable,
  getHoursDifference,
  getDaysDifference,
  isWithinHours,
  isValidEmail,
  isValidPhone,
  sanitizeInput,
  parsePaginationParams,
  generateOTP,
  hashToken,
  getClaimAttemptLimit,
  getReportDailyLimit,
  TRUST_CHANGES
} from '../src/utils';
import { TrustLevel } from '../src/types';

describe('Utility Functions', () => {
  describe('extractKeywords', () => {
    it('should extract meaningful keywords from text', () => {
      const text = 'Lost my black iPhone 13 Pro with blue silicone case';
      const keywords = extractKeywords(text);

      expect(keywords).toContain('black');
      expect(keywords).toContain('iphone');
      expect(keywords).toContain('blue');
      expect(keywords).toContain('silicone');
    });

    it('should filter out stopwords', () => {
      const text = 'I lost my phone in the market';
      const keywords = extractKeywords(text);

      expect(keywords).not.toContain('the');
      expect(keywords).not.toContain('in');
      expect(keywords).not.toContain('my');
    });

    it('should normalize to lowercase', () => {
      const text = 'BLACK IPHONE Samsung';
      const keywords = extractKeywords(text);

      expect(keywords).toContain('black');
      expect(keywords).toContain('iphone');
      expect(keywords).toContain('samsung');
    });

    it('should handle empty text', () => {
      const keywords = extractKeywords('');
      expect(keywords).toEqual([]);
    });

    it('should identify brand names', () => {
      const text = 'Samsung Galaxy phone with Tecno charger';
      const keywords = extractKeywords(text);

      expect(keywords).toContain('samsung');
      expect(keywords).toContain('galaxy');
      expect(keywords).toContain('tecno');
    });

    it('should identify colors', () => {
      const text = 'A red bag with green stripes and white logo';
      const keywords = extractKeywords(text);

      expect(keywords).toContain('red');
      expect(keywords).toContain('green');
      expect(keywords).toContain('white');
    });

    it('should handle special characters', () => {
      const text = 'iPhone-14 with case @home #lost!';
      const keywords = extractKeywords(text);

      expect(keywords.some(k => k.includes('iphone'))).toBe(true);
    });
  });

  describe('getTrustLevel', () => {
    it('should return SUSPENDED for very low scores', () => {
      expect(getTrustLevel(-15)).toBe(TrustLevel.SUSPENDED);
      expect(getTrustLevel(-100)).toBe(TrustLevel.SUSPENDED);
    });

    it('should return RESTRICTED for negative scores', () => {
      expect(getTrustLevel(-5)).toBe(TrustLevel.RESTRICTED);
      expect(getTrustLevel(-1)).toBe(TrustLevel.RESTRICTED);
    });

    it('should return NEW for low positive scores', () => {
      expect(getTrustLevel(0)).toBe(TrustLevel.NEW);
      expect(getTrustLevel(4)).toBe(TrustLevel.NEW);
    });

    it('should return ESTABLISHED for medium scores', () => {
      expect(getTrustLevel(5)).toBe(TrustLevel.ESTABLISHED);
      expect(getTrustLevel(14)).toBe(TrustLevel.ESTABLISHED);
    });

    it('should return TRUSTED for high scores', () => {
      expect(getTrustLevel(15)).toBe(TrustLevel.TRUSTED);
      expect(getTrustLevel(100)).toBe(TrustLevel.TRUSTED);
    });
  });

  describe('getClaimAttemptLimit', () => {
    it('should return 0 for SUSPENDED', () => {
      expect(getClaimAttemptLimit(TrustLevel.SUSPENDED)).toBe(0);
    });

    it('should return 1 for RESTRICTED', () => {
      expect(getClaimAttemptLimit(TrustLevel.RESTRICTED)).toBe(1);
    });

    it('should return 3 for NEW', () => {
      expect(getClaimAttemptLimit(TrustLevel.NEW)).toBe(3);
    });

    it('should return 5 for ESTABLISHED', () => {
      expect(getClaimAttemptLimit(TrustLevel.ESTABLISHED)).toBe(5);
    });

    it('should return 7 for TRUSTED', () => {
      expect(getClaimAttemptLimit(TrustLevel.TRUSTED)).toBe(7);
    });
  });

  describe('getReportDailyLimit', () => {
    it('should return appropriate limits for each trust level', () => {
      expect(getReportDailyLimit(TrustLevel.SUSPENDED)).toBe(0);
      expect(getReportDailyLimit(TrustLevel.RESTRICTED)).toBe(1);
      expect(getReportDailyLimit(TrustLevel.NEW)).toBe(3);
      expect(getReportDailyLimit(TrustLevel.ESTABLISHED)).toBe(5);
      expect(getReportDailyLimit(TrustLevel.TRUSTED)).toBe(10);
    });
  });

  describe('computeLocationDistance', () => {
    it('should return 0 for same location', () => {
      expect(computeLocationDistance('Kimironko', 'Kimironko')).toBe(0);
      expect(computeLocationDistance('KIMIRONKO', 'kimironko')).toBe(0);
    });

    it('should return 1 for adjacent locations', () => {
      expect(computeLocationDistance('Kimironko', 'Remera')).toBe(1);
      expect(computeLocationDistance('Remera', 'Kimironko')).toBe(1);
      expect(computeLocationDistance('Kacyiru', 'Gisozi')).toBe(1);
    });

    it('should return 2 for same district locations', () => {
      expect(computeLocationDistance('Kimironko', 'Kacyiru')).toBe(2);
      expect(computeLocationDistance('Gikondo', 'Kanombe')).toBe(2);
    });

    it('should return 3 for different district locations', () => {
      expect(computeLocationDistance('Kimironko', 'Nyamirambo')).toBe(3);
      expect(computeLocationDistance('Remera', 'Gitega')).toBe(3);
    });

    it('should handle case insensitivity', () => {
      expect(computeLocationDistance('REMERA', 'kimironko')).toBe(1);
      expect(computeLocationDistance('Remera', 'KIMIRONKO')).toBe(1);
    });

    it('should handle whitespace', () => {
      expect(computeLocationDistance(' Kimironko ', ' Remera ')).toBe(1);
    });
  });

  describe('isMessageFlaggable', () => {
    it('should flag messages with multiple suspicious keywords', () => {
      const result = isMessageFlaggable('Please pay money via MTN before I return');
      expect(result.flagged).toBe(true);
      expect(result.reason).toBeDefined();
    });

    it('should not flag normal messages', () => {
      const result = isMessageFlaggable('Thank you for finding my phone!');
      expect(result.flagged).toBe(false);
    });

    it('should flag extortion attempts', () => {
      const result = isMessageFlaggable('Send me 10000 first then I will give you');
      expect(result.flagged).toBe(true);
    });

    it('should flag payment requests', () => {
      const result = isMessageFlaggable('Transfer money to my account for reward');
      expect(result.flagged).toBe(true);
    });

    it('should flag external meeting requests', () => {
      const result = isMessageFlaggable('Meet me alone at night and pay money first');
      expect(result.flagged).toBe(true);
    });

    it('should not flag single suspicious word', () => {
      const result = isMessageFlaggable('I found your wallet with money inside');
      expect(result.flagged).toBe(false);
    });
  });

  describe('getHoursDifference', () => {
    it('should calculate correct hours difference', () => {
      const date1 = new Date('2024-01-15T10:00:00Z');
      const date2 = new Date('2024-01-15T14:00:00Z');

      expect(getHoursDifference(date1, date2)).toBe(4);
    });

    it('should return absolute difference', () => {
      const date1 = new Date('2024-01-15T14:00:00Z');
      const date2 = new Date('2024-01-15T10:00:00Z');

      expect(getHoursDifference(date1, date2)).toBe(4);
    });

    it('should handle same time', () => {
      const date = new Date('2024-01-15T10:00:00Z');
      expect(getHoursDifference(date, date)).toBe(0);
    });

    it('should handle fractional hours', () => {
      const date1 = new Date('2024-01-15T10:00:00Z');
      const date2 = new Date('2024-01-15T10:30:00Z');
      expect(getHoursDifference(date1, date2)).toBe(0.5);
    });
  });

  describe('getDaysDifference', () => {
    it('should calculate correct days difference', () => {
      const date1 = new Date('2024-01-15T10:00:00Z');
      const date2 = new Date('2024-01-17T10:00:00Z');
      expect(getDaysDifference(date1, date2)).toBe(2);
    });

    it('should handle partial days', () => {
      const date1 = new Date('2024-01-15T00:00:00Z');
      const date2 = new Date('2024-01-15T12:00:00Z');
      expect(getDaysDifference(date1, date2)).toBe(0.5);
    });
  });

  describe('isWithinHours', () => {
    it('should return true for dates within range', () => {
      const date1 = new Date('2024-01-15T10:00:00Z');
      const date2 = new Date('2024-01-15T12:00:00Z');
      expect(isWithinHours(date1, date2, 3)).toBe(true);
    });

    it('should return false for dates outside range', () => {
      const date1 = new Date('2024-01-15T10:00:00Z');
      const date2 = new Date('2024-01-15T20:00:00Z');
      expect(isWithinHours(date1, date2, 5)).toBe(false);
    });

    it('should handle exact boundary', () => {
      const date1 = new Date('2024-01-15T10:00:00Z');
      const date2 = new Date('2024-01-15T15:00:00Z');
      expect(isWithinHours(date1, date2, 5)).toBe(true);
    });
  });

  describe('isValidEmail', () => {
    it('should validate correct emails', () => {
      expect(isValidEmail('test@example.com')).toBe(true);
      expect(isValidEmail('user.name@domain.co.rw')).toBe(true);
      expect(isValidEmail('user+tag@gmail.com')).toBe(true);
    });

    it('should reject invalid emails', () => {
      expect(isValidEmail('invalid')).toBe(false);
      expect(isValidEmail('test@')).toBe(false);
      expect(isValidEmail('@domain.com')).toBe(false);
      expect(isValidEmail('')).toBe(false);
      expect(isValidEmail('test @example.com')).toBe(false);
    });
  });

  describe('isValidPhone', () => {
    it('should validate Rwandan phone numbers', () => {
      expect(isValidPhone('+250788123456')).toBe(true);
      expect(isValidPhone('250788123456')).toBe(true);
      expect(isValidPhone('+250 788 123 456')).toBe(true);
    });

    it('should reject invalid phone numbers', () => {
      expect(isValidPhone('123456')).toBe(false);
      expect(isValidPhone('+1234567890')).toBe(false);
      expect(isValidPhone('abcdefghijk')).toBe(false);
    });
  });

  describe('sanitizeInput', () => {
    it('should remove HTML tags', () => {
      expect(sanitizeInput('<script>alert("xss")</script>')).toBe('alert("xss")');
      expect(sanitizeInput('<b>bold</b> text')).toBe('bold text');
    });

    it('should trim whitespace', () => {
      expect(sanitizeInput('  hello world  ')).toBe('hello world');
    });

    it('should handle normal text', () => {
      expect(sanitizeInput('Normal text here')).toBe('Normal text here');
    });
  });

  describe('parsePaginationParams', () => {
    it('should parse valid params', () => {
      const result = parsePaginationParams(2, 20);
      expect(result.page).toBe(2);
      expect(result.limit).toBe(20);
      expect(result.offset).toBe(20);
    });

    it('should use defaults for missing params', () => {
      const result = parsePaginationParams(undefined, undefined);
      expect(result.page).toBe(1);
      expect(result.limit).toBe(10);
      expect(result.offset).toBe(0);
    });

    it('should handle string params', () => {
      const result = parsePaginationParams('3', '15');
      expect(result.page).toBe(3);
      expect(result.limit).toBe(15);
    });

    it('should enforce minimum page of 1', () => {
      const result = parsePaginationParams(0, 10);
      expect(result.page).toBe(1);
    });

    it('should enforce maximum limit of 100', () => {
      const result = parsePaginationParams(1, 500);
      expect(result.limit).toBe(100);
    });

    it('should enforce minimum limit of 1', () => {
      const result = parsePaginationParams(1, -5);
      expect(result.limit).toBe(1);
    });
  });

  describe('generateOTP', () => {
    it('should generate 6-digit OTP', () => {
      const otp = generateOTP();
      expect(otp).toMatch(/^\d{6}$/);
    });

    it('should generate different OTPs', () => {
      const otps = new Set([generateOTP(), generateOTP(), generateOTP()]);
      expect(otps.size).toBeGreaterThan(1);
    });
  });

  describe('hashToken', () => {
    it('should hash token consistently', () => {
      const token = 'test-token-123';
      const hash1 = hashToken(token);
      const hash2 = hashToken(token);
      expect(hash1).toBe(hash2);
    });

    it('should produce different hashes for different tokens', () => {
      const hash1 = hashToken('token1');
      const hash2 = hashToken('token2');
      expect(hash1).not.toBe(hash2);
    });

    it('should produce hex string', () => {
      const hash = hashToken('test');
      expect(hash).toMatch(/^[a-f0-9]+$/);
    });
  });

  describe('TRUST_CHANGES', () => {
    it('should have positive values for good actions', () => {
      expect(TRUST_CHANGES.SUCCESSFUL_RETURN_FINDER).toBeGreaterThan(0);
      expect(TRUST_CHANGES.SUCCESSFUL_RECOVERY_OWNER).toBeGreaterThan(0);
      expect(TRUST_CHANGES.EMAIL_VERIFIED).toBeGreaterThan(0);
    });

    it('should have negative values for bad actions', () => {
      expect(TRUST_CHANGES.FAILED_VERIFICATION).toBeLessThan(0);
      expect(TRUST_CHANGES.SCAM_REPORTED).toBeLessThan(0);
      expect(TRUST_CHANGES.SCAM_CONFIRMED).toBeLessThan(0);
    });
  });
});



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tests/validation.test.ts
‚îÇ Language: TypeScript | Lines: 383 | Size: 10.3 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/**
 * Validation Middleware Tests
 * Tests for request validation schemas
 */

import { Request, Response, NextFunction } from 'express';
import {
  validate,
  registerSchema,
  loginSchema,
  createLostItemSchema,
  createFoundItemSchema,
  createClaimSchema,
  verifyClaimSchema,
  sendMessageSchema,
} from '../src/middleware/validation';

describe('Validation Middleware', () => {
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockNext: jest.Mock;
  let jsonMock: jest.Mock;
  let statusMock: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();
    jsonMock = jest.fn();
    statusMock = jest.fn(() => ({ json: jsonMock }));
    mockNext = jest.fn();
    mockResponse = {
      json: jsonMock,
      status: statusMock,
    };
    mockRequest = {
      body: {},
    };
  });

  describe('registerSchema', () => {
    const middleware = validate(registerSchema);

    it('should pass with valid registration data', () => {
      mockRequest.body = {
        email: 'test@example.com',
        password: 'Password123!',
        name: 'Test User',
        phone: '+250788123456',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should pass without optional phone', () => {
      mockRequest.body = {
        email: 'test@example.com',
        password: 'Password123!',
        name: 'Test User',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject invalid email', () => {
      mockRequest.body = {
        email: 'invalid-email',
        password: 'Password123!',
        name: 'Test User',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject short password', () => {
      mockRequest.body = {
        email: 'test@example.com',
        password: 'short',
        name: 'Test User',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject empty name', () => {
      mockRequest.body = {
        email: 'test@example.com',
        password: 'Password123!',
        name: '',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });

  describe('loginSchema', () => {
    const middleware = validate(loginSchema);

    it('should pass with valid login data', () => {
      mockRequest.body = {
        email: 'test@example.com',
        password: 'Password123!',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject missing email', () => {
      mockRequest.body = {
        password: 'Password123!',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject missing password', () => {
      mockRequest.body = {
        email: 'test@example.com',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });

  describe('createLostItemSchema', () => {
    const middleware = validate(createLostItemSchema);

    it('should pass with valid lost item data', () => {
      mockRequest.body = {
        category: 'PHONE',
        title: 'Lost iPhone 14',
        description: 'Black iPhone 14 Pro with blue case',
        location_area: 'Kimironko',
        lost_date: '2024-01-15',
        verification_questions: [
          { question: 'What is the lockscreen?', answer: 'Mountain photo' },
          { question: 'Phone color?', answer: 'Black' },
          { question: 'Case color?', answer: 'Blue' },
        ],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject invalid category', () => {
      mockRequest.body = {
        category: 'INVALID',
        title: 'Lost Item',
        description: 'Description',
        location_area: 'Kimironko',
        lost_date: '2024-01-15',
        verification_questions: [
          { question: 'Q1?', answer: 'A1' },
          { question: 'Q2?', answer: 'A2' },
          { question: 'Q3?', answer: 'A3' },
        ],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject missing verification questions', () => {
      mockRequest.body = {
        category: 'PHONE',
        title: 'Lost iPhone',
        description: 'Description',
        location_area: 'Kimironko',
        lost_date: '2024-01-15',
        verification_questions: [
          { question: 'Q1?', answer: 'A1' },
        ],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject short title', () => {
      mockRequest.body = {
        category: 'PHONE',
        title: 'Hi',
        description: 'Description of the item',
        location_area: 'Kimironko',
        lost_date: '2024-01-15',
        verification_questions: [
          { question: 'Q1?', answer: 'A1' },
          { question: 'Q2?', answer: 'A2' },
          { question: 'Q3?', answer: 'A3' },
        ],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });

  describe('createFoundItemSchema', () => {
    const middleware = validate(createFoundItemSchema);

    it('should pass with valid found item data', () => {
      mockRequest.body = {
        category: 'WALLET',
        title: 'Found Brown Wallet',
        description: 'Brown leather wallet with cards',
        location_area: 'Remera',
        found_date: '2024-01-15',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should pass with optional cooperative_id', () => {
      mockRequest.body = {
        category: 'WALLET',
        title: 'Found Wallet at Bus Station',
        description: 'Brown leather wallet',
        location_area: 'Nyabugogo',
        found_date: '2024-01-15',
        cooperative_id: 1,
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject invalid category', () => {
      mockRequest.body = {
        category: 'INVALID',
        title: 'Found Item',
        description: 'Description',
        location_area: 'Remera',
        found_date: '2024-01-15',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });

  describe('createClaimSchema', () => {
    const middleware = validate(createClaimSchema);

    it('should pass with valid claim data', () => {
      mockRequest.body = {
        lost_item_id: 1,
        found_item_id: 2,
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject missing lost_item_id', () => {
      mockRequest.body = {
        found_item_id: 2,
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject non-integer ids', () => {
      mockRequest.body = {
        lost_item_id: 'abc',
        found_item_id: 2,
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });

  describe('verifyClaimSchema', () => {
    const middleware = validate(verifyClaimSchema);

    it('should pass with valid answers array', () => {
      mockRequest.body = {
        answers: ['answer1', 'answer2', 'answer3'],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject wrong number of answers', () => {
      mockRequest.body = {
        answers: ['answer1', 'answer2'],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject empty answers', () => {
      mockRequest.body = {
        answers: ['', 'answer2', 'answer3'],
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });

  describe('sendMessageSchema', () => {
    const middleware = validate(sendMessageSchema);

    it('should pass with valid message', () => {
      mockRequest.body = {
        content: 'Hello, I think this is my phone!',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(mockNext).toHaveBeenCalled();
    });

    it('should reject empty message', () => {
      mockRequest.body = {
        content: '',
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });

    it('should reject too long message', () => {
      mockRequest.body = {
        content: 'a'.repeat(2001),
      };

      middleware(mockRequest as Request, mockResponse as Response, mockNext);

      expect(statusMock).toHaveBeenCalledWith(400);
      expect(mockNext).not.toHaveBeenCalled();
    });
  });
});




‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  SECTION: (root)/
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: .dockerignore
‚îÇ Language: Text | Lines: 18 | Size: 219 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

node_modules
npm-debug.log
dist
coverage
.env
.env.*
!.env.example
uploads/*
!uploads/.gitkeep
*.md
.git
.github
tests
jest.config.js
.eslintrc*
.prettierrc*
docker-compose.yml
*.postman_collection.json


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: .env.example
‚îÇ Language: Text | Lines: 35 | Size: 792 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# Database
DATABASE_URL=postgresql://byaboneka:byaboneka_dev_pass@localhost:5432/byaboneka_plus

# JWT Configuration
JWT_SECRET=your_jwt_secret_here_min_32_characters_long
JWT_REFRESH_SECRET=your_refresh_secret_here_min_32_characters
JWT_ACCESS_EXPIRY=15m
JWT_REFRESH_EXPIRY=7d

# Server Configuration
PORT=4000
NODE_ENV=development

# CORS
CORS_ORIGIN=http://localhost:3000

# File Uploads
UPLOAD_PATH=./uploads
MAX_FILE_SIZE=5242880
ALLOWED_FILE_TYPES=image/jpeg,image/png,image/webp

# Rate Limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=100

# Email (for password reset - MVP uses email)
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=your_email@example.com
SMTP_PASS=your_email_password
EMAIL_FROM=noreply@byaboneka.rw

# Optional: Sentry for error tracking
SENTRY_DSN=



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: .gitignore
‚îÇ Language: Text | Lines: 107 | Size: 1.6 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# =========================
# Node / JavaScript
# =========================
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# =========================
# Build outputs
# =========================
dist/
build/
coverage/

# Vite
.vite/

# =========================
# Environment files
# =========================
.env
.env.*
!.env.example

# =========================
# TypeScript
# =========================
*.tsbuildinfo

# =========================
# Logs
# =========================
logs/
*.log

# =========================
# Uploads / user content
# =========================
uploads/
public/uploads/

# =========================
# Database
# =========================
*.sqlite
*.db
*.dump
*.sql

# =========================
# Cache / temp
# =========================
.cache/
tmp/
temp/

# =========================
# OS generated files
# =========================
.DS_Store
Thumbs.db
ehthumbs.db
desktop.ini

# =========================
# Editor / IDE
# =========================
.vscode/
!.vscode/extensions.json
!.vscode/settings.json

.idea/
*.suo
*.ntvs*
*.njsproj
*.sln

# =========================
# Testing
# =========================
coverage/
.nyc_output/

# =========================
# Misc
# =========================
*.pem
*.key
*.crt

# =========================
# Turborepo / Monorepo
# =========================
.turbo/

# =========================
# Storybook
# =========================
storybook-static/

# =========================
# ESLint
# =========================
.eslintcache



‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: Byaboneka_Plus_API.postman_collection.json
‚îÇ Language: JSON | Lines: 711 | Size: 27.8 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

{
  "info": {
    "name": "Byaboneka+ API",
    "description": "Trust-Aware Lost & Found Infrastructure for Rwanda\n\n## Quick Start\n1. Run the **Register** then **Login** request\n2. The access token is auto-saved to the collection variable `accessToken`\n3. All authenticated requests use this token automatically\n\n## Environments\n- **Local**: `http://localhost:4000/api/v1`\n- **Production**: `https://your-app.onrender.com/api/v1`",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "byaboneka-plus"
  },
  "variable": [
    { "key": "baseUrl", "value": "http://localhost:4000/api/v1" },
    { "key": "accessToken", "value": "" },
    { "key": "refreshToken", "value": "" },
    { "key": "userId", "value": "" },
    { "key": "lostItemId", "value": "" },
    { "key": "foundItemId", "value": "" },
    { "key": "claimId", "value": "" },
    { "key": "cooperativeId", "value": "" },
    { "key": "adminToken", "value": "" }
  ],
  "auth": {
    "type": "bearer",
    "bearer": [{ "key": "token", "value": "{{accessToken}}" }]
  },
  "item": [
    {
      "name": "üîê Authentication",
      "item": [
        {
          "name": "Register",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) {",
                  "  pm.collectionVariables.set('accessToken', res.data.tokens.accessToken);",
                  "  pm.collectionVariables.set('refreshToken', res.data.tokens.refreshToken);",
                  "  pm.collectionVariables.set('userId', res.data.user.id);",
                  "  pm.test('Registration successful', () => pm.expect(res.data.user.email).to.exist);",
                  "}",
                  "pm.test('Status 201', () => pm.response.to.have.status(201));"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"jean@example.com\",\n  \"password\": \"MySecure1Pass\",\n  \"name\": \"Jean Habimana\",\n  \"phone\": \"+250788123456\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/register", "host": ["{{baseUrl}}"], "path": ["auth", "register"] }
          }
        },
        {
          "name": "Login",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) {",
                  "  pm.collectionVariables.set('accessToken', res.data.tokens.accessToken);",
                  "  pm.collectionVariables.set('refreshToken', res.data.tokens.refreshToken);",
                  "  pm.collectionVariables.set('userId', res.data.user.id);",
                  "}",
                  "pm.test('Login successful', () => pm.expect(res.success).to.be.true);",
                  "pm.test('Has tokens', () => pm.expect(res.data.tokens.accessToken).to.exist);"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"jean@example.com\",\n  \"password\": \"MySecure1Pass\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/login", "host": ["{{baseUrl}}"], "path": ["auth", "login"] }
          }
        },
        {
          "name": "Login (Admin)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) {",
                  "  pm.collectionVariables.set('adminToken', res.data.tokens.accessToken);",
                  "}",
                  "pm.test('Admin login', () => pm.expect(res.data.user.role).to.eql('admin'));"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"admin@byaboneka.rw\",\n  \"password\": \"Admin1234!\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/login", "host": ["{{baseUrl}}"], "path": ["auth", "login"] }
          }
        },
        {
          "name": "Refresh Token",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"refreshToken\": \"{{refreshToken}}\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/refresh", "host": ["{{baseUrl}}"], "path": ["auth", "refresh"] }
          }
        },
        {
          "name": "Get Profile",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/auth/profile", "host": ["{{baseUrl}}"], "path": ["auth", "profile"] }
          }
        },
        {
          "name": "Update Profile",
          "request": {
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Jean-Claude Habimana\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/profile", "host": ["{{baseUrl}}"], "path": ["auth", "profile"] }
          }
        },
        {
          "name": "Change Password",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"currentPassword\": \"MySecure1Pass\",\n  \"newPassword\": \"NewSecure2Pass\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/change-password", "host": ["{{baseUrl}}"], "path": ["auth", "change-password"] }
          }
        },
        {
          "name": "Forgot Password",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"jean@example.com\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/forgot-password", "host": ["{{baseUrl}}"], "path": ["auth", "forgot-password"] }
          }
        },
        {
          "name": "Logout",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"refreshToken\": \"{{refreshToken}}\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/auth/logout", "host": ["{{baseUrl}}"], "path": ["auth", "logout"] }
          }
        }
      ]
    },
    {
      "name": "üì¶ Lost Items",
      "item": [
        {
          "name": "Create Lost Item",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) { pm.collectionVariables.set('lostItemId', res.data.id); }",
                  "pm.test('Status 201', () => pm.response.to.have.status(201));",
                  "pm.test('Has keywords', () => pm.expect(res.data.keywords).to.be.an('array'));"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"category\": \"PHONE\",\n  \"title\": \"Samsung Galaxy S23 Ultra\",\n  \"description\": \"Black Samsung phone with cracked screen protector and blue case. Has a small scratch on the back.\",\n  \"location_area\": \"Nyabugogo\",\n  \"location_hint\": \"Near the main bus station\",\n  \"lost_date\": \"2026-02-10T14:00:00Z\",\n  \"verification_questions\": [\n    { \"question\": \"What is your phone wallpaper?\", \"answer\": \"my dog\" },\n    { \"question\": \"What color is the phone case?\", \"answer\": \"blue\" },\n    { \"question\": \"What is the lock screen PIN length?\", \"answer\": \"six digits\" }\n  ]\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/lost-items", "host": ["{{baseUrl}}"], "path": ["lost-items"] }
          }
        },
        {
          "name": "List Lost Items",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{baseUrl}}/lost-items?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["lost-items"],
              "query": [{ "key": "page", "value": "1" }, { "key": "limit", "value": "10" }]
            }
          }
        },
        {
          "name": "Get Lost Item",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/lost-items/{{lostItemId}}", "host": ["{{baseUrl}}"], "path": ["lost-items", "{{lostItemId}}"] }
          }
        },
        {
          "name": "Get Matches for Lost Item",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/lost-items/{{lostItemId}}/matches", "host": ["{{baseUrl}}"], "path": ["lost-items", "{{lostItemId}}", "matches"] }
          }
        },
        {
          "name": "My Lost Items",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/users/me/lost-items", "host": ["{{baseUrl}}"], "path": ["users", "me", "lost-items"] }
          }
        },
        {
          "name": "Update Lost Item",
          "request": {
            "method": "PUT",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"description\": \"Updated description with more details about the Samsung phone\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/lost-items/{{lostItemId}}", "host": ["{{baseUrl}}"], "path": ["lost-items", "{{lostItemId}}"] }
          }
        },
        {
          "name": "Delete Lost Item",
          "request": {
            "method": "DELETE",
            "url": { "raw": "{{baseUrl}}/lost-items/{{lostItemId}}", "host": ["{{baseUrl}}"], "path": ["lost-items", "{{lostItemId}}"] }
          }
        }
      ]
    },
    {
      "name": "üîç Found Items",
      "item": [
        {
          "name": "Create Found Item",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) { pm.collectionVariables.set('foundItemId', res.data.id); }",
                  "pm.test('Status 201', () => pm.response.to.have.status(201));"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"category\": \"PHONE\",\n  \"title\": \"Black Samsung phone found on bus\",\n  \"description\": \"Found a black Samsung phone on the seat of KBS bus #205. Has a blue case and cracked screen protector.\",\n  \"location_area\": \"Nyabugogo\",\n  \"location_hint\": \"KBS Bus #205, route Nyabugogo-Kimironko\",\n  \"found_date\": \"2026-02-10T16:30:00Z\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/found-items", "host": ["{{baseUrl}}"], "path": ["found-items"] }
          }
        },
        {
          "name": "List Found Items",
          "request": {
            "method": "GET",
            "url": {
              "raw": "{{baseUrl}}/found-items?page=1&limit=10&category=PHONE",
              "host": ["{{baseUrl}}"],
              "path": ["found-items"],
              "query": [
                { "key": "page", "value": "1" },
                { "key": "limit", "value": "10" },
                { "key": "category", "value": "PHONE" }
              ]
            }
          }
        },
        {
          "name": "Get Found Item",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/found-items/{{foundItemId}}", "host": ["{{baseUrl}}"], "path": ["found-items", "{{foundItemId}}"] }
          }
        },
        {
          "name": "Upload Images",
          "request": {
            "method": "POST",
            "body": {
              "mode": "formdata",
              "formdata": [{ "key": "images", "type": "file", "src": "" }]
            },
            "url": { "raw": "{{baseUrl}}/found-items/{{foundItemId}}/images", "host": ["{{baseUrl}}"], "path": ["found-items", "{{foundItemId}}", "images"] }
          }
        },
        {
          "name": "My Found Items",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/users/me/found-items", "host": ["{{baseUrl}}"], "path": ["users", "me", "found-items"] }
          }
        }
      ]
    },
    {
      "name": "‚úÖ Claims & Verification",
      "item": [
        {
          "name": "Create Claim",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) { pm.collectionVariables.set('claimId', res.data.id); }",
                  "pm.test('Status 201', () => pm.response.to.have.status(201));"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"lost_item_id\": {{lostItemId}},\n  \"found_item_id\": {{foundItemId}}\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/claims", "host": ["{{baseUrl}}"], "path": ["claims"] }
          }
        },
        {
          "name": "Get Verification Questions",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/questions", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "questions"] }
          }
        },
        {
          "name": "Submit Verification Answers",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"answers\": [\"my dog\", \"blue\", \"six digits\"]\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/verify", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "verify"] }
          }
        },
        {
          "name": "Get Claim Details",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}"] }
          }
        },
        {
          "name": "My Claims",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/users/me/claims", "host": ["{{baseUrl}}"], "path": ["users", "me", "claims"] }
          }
        },
        {
          "name": "Cancel Claim",
          "request": {
            "method": "POST",
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/cancel", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "cancel"] }
          }
        }
      ]
    },
    {
      "name": "üîë Handover (OTP)",
      "item": [
        {
          "name": "Generate OTP",
          "request": {
            "method": "POST",
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/handover/otp", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "handover", "otp"] }
          }
        },
        {
          "name": "Verify OTP (Confirm Handover)",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"otp\": \"123456\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/handover/verify", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "handover", "verify"] }
          }
        },
        {
          "name": "Get Handover Status",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/handover", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "handover"] }
          }
        }
      ]
    },
    {
      "name": "‚öñÔ∏è Disputes",
      "item": [
        {
          "name": "File Dispute",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"reason\": \"I forgot the answer to question 2 but this is definitely my phone. I can provide the purchase receipt from MTN store Kigali.\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/claims/{{claimId}}/dispute", "host": ["{{baseUrl}}"], "path": ["claims", "{{claimId}}", "dispute"] }
          }
        },
        {
          "name": "List Disputes (Admin)",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/admin/disputes?status=OPEN", "host": ["{{baseUrl}}"], "path": ["admin", "disputes"], "query": [{ "key": "status", "value": "OPEN" }] }
          }
        },
        {
          "name": "Resolve Dispute (Admin)",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"resolution\": \"RESOLVED_OWNER\",\n  \"resolution_notes\": \"Owner provided valid purchase receipt as proof of ownership.\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/admin/disputes/1/resolve", "host": ["{{baseUrl}}"], "path": ["admin", "disputes", "1", "resolve"] }
          }
        }
      ]
    },
    {
      "name": "üí¨ Messages",
      "item": [
        {
          "name": "Send Message",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"content\": \"Hi, I found what might be your phone. When can we meet at the cooperative office?\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/messages/threads/{{claimId}}", "host": ["{{baseUrl}}"], "path": ["messages", "threads", "{{claimId}}"] }
          }
        },
        {
          "name": "Get Thread Messages",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/messages/threads/{{claimId}}", "host": ["{{baseUrl}}"], "path": ["messages", "threads", "{{claimId}}"] }
          }
        },
        {
          "name": "List My Threads",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/messages/threads", "host": ["{{baseUrl}}"], "path": ["messages", "threads"] }
          }
        },
        {
          "name": "Unread Count",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/messages/unread-count", "host": ["{{baseUrl}}"], "path": ["messages", "unread-count"] }
          }
        },
        {
          "name": "Report Scam Message",
          "request": {
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"reason\": \"User is demanding payment before returning the item.\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/messages/1/report", "host": ["{{baseUrl}}"], "path": ["messages", "1", "report"] }
          }
        }
      ]
    },
    {
      "name": "üè¢ Cooperatives",
      "item": [
        {
          "name": "List Cooperatives",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/cooperatives", "host": ["{{baseUrl}}"], "path": ["cooperatives"] }
          }
        },
        {
          "name": "Get Cooperative",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/cooperatives/{{cooperativeId}}", "host": ["{{baseUrl}}"], "path": ["cooperatives", "{{cooperativeId}}"] }
          }
        },
        {
          "name": "Create Cooperative (Admin)",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "const res = pm.response.json();",
                  "if (res.success) { pm.collectionVariables.set('cooperativeId', res.data.id); }"
                ]
              }
            }
          ],
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"Kigali Bus Services (KBS)\",\n  \"registration_number\": \"RW-COOP-2024-001\",\n  \"contact_info\": \"+250788000111\",\n  \"address\": \"Nyabugogo Terminal, Kigali\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/cooperatives", "host": ["{{baseUrl}}"], "path": ["cooperatives"] }
          }
        },
        {
          "name": "Verify Cooperative (Admin)",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "PATCH",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"VERIFIED\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/cooperatives/{{cooperativeId}}/status", "host": ["{{baseUrl}}"], "path": ["cooperatives", "{{cooperativeId}}", "status"] }
          }
        },
        {
          "name": "Add Coop Staff (Admin)",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"staff@kbs.rw\",\n  \"password\": \"StaffPass1!\",\n  \"name\": \"Emmanuel Ndayisaba\",\n  \"phone\": \"+250788000222\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/cooperatives/{{cooperativeId}}/staff", "host": ["{{baseUrl}}"], "path": ["cooperatives", "{{cooperativeId}}", "staff"] }
          }
        },
        {
          "name": "Get Coop Staff",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/cooperatives/{{cooperativeId}}/staff", "host": ["{{baseUrl}}"], "path": ["cooperatives", "{{cooperativeId}}", "staff"] }
          }
        },
        {
          "name": "Cooperative Dashboard",
          "request": {
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/cooperative/dashboard", "host": ["{{baseUrl}}"], "path": ["cooperative", "dashboard"] }
          }
        }
      ]
    },
    {
      "name": "üõ°Ô∏è Admin",
      "item": [
        {
          "name": "Dashboard Stats",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/admin/stats", "host": ["{{baseUrl}}"], "path": ["admin", "stats"] }
          }
        },
        {
          "name": "List Users",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "GET",
            "url": {
              "raw": "{{baseUrl}}/admin/users?page=1&limit=20",
              "host": ["{{baseUrl}}"],
              "path": ["admin", "users"],
              "query": [{ "key": "page", "value": "1" }, { "key": "limit", "value": "20" }]
            }
          }
        },
        {
          "name": "Ban User",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "body": {
              "mode": "raw",
              "raw": "{\n  \"reason\": \"Repeated fraudulent claim attempts\"\n}",
              "options": { "raw": { "language": "json" } }
            },
            "url": { "raw": "{{baseUrl}}/admin/users/2/ban", "host": ["{{baseUrl}}"], "path": ["admin", "users", "2", "ban"] }
          }
        },
        {
          "name": "Unban User",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "url": { "raw": "{{baseUrl}}/admin/users/2/unban", "host": ["{{baseUrl}}"], "path": ["admin", "users", "2", "unban"] }
          }
        },
        {
          "name": "Scam Reports",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/admin/scam-reports?status=OPEN", "host": ["{{baseUrl}}"], "path": ["admin", "scam-reports"], "query": [{ "key": "status", "value": "OPEN" }] }
          }
        },
        {
          "name": "Audit Logs",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/admin/audit-logs?page=1&limit=50", "host": ["{{baseUrl}}"], "path": ["admin", "audit-logs"], "query": [{ "key": "page", "value": "1" }, { "key": "limit", "value": "50" }] }
          }
        },
        {
          "name": "Recalculate Trust",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "url": { "raw": "{{baseUrl}}/admin/users/2/recalculate-trust", "host": ["{{baseUrl}}"], "path": ["admin", "users", "2", "recalculate-trust"] }
          }
        },
        {
          "name": "Trigger Cleanup",
          "request": {
            "auth": { "type": "bearer", "bearer": [{ "key": "token", "value": "{{adminToken}}" }] },
            "method": "POST",
            "url": { "raw": "{{baseUrl}}/admin/cleanup", "host": ["{{baseUrl}}"], "path": ["admin", "cleanup"] }
          }
        }
      ]
    },
    {
      "name": "üíö System",
      "item": [
        {
          "name": "Health Check",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "pm.test('API is healthy', () => {",
                  "  const res = pm.response.json();",
                  "  pm.expect(res.status).to.eql('ok');",
                  "  pm.expect(res.database).to.eql('connected');",
                  "});"
                ]
              }
            }
          ],
          "request": {
            "auth": { "type": "noauth" },
            "method": "GET",
            "url": { "raw": "{{baseUrl}}/health", "host": ["{{baseUrl}}"], "path": ["health"] }
          }
        }
      ]
    }
  ]
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: docker-compose.yml
‚îÇ Language: YAML | Lines: 44 | Size: 1.1 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# docker-compose.yml - Local development
version: '3.9'

services:
  api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "4000:4000"
    environment:
      - NODE_ENV=production
      - PORT=4000
      - DATABASE_URL=postgresql://byaboneka:byaboneka_dev@db:5432/byaboneka_plus
      - JWT_SECRET=dev_jwt_secret_change_in_production_min_32_chars!!
      - JWT_REFRESH_SECRET=dev_refresh_secret_change_in_production_min_32!!
      - CORS_ORIGIN=http://localhost:3000
      - UPLOAD_PATH=./uploads
    depends_on:
      db:
        condition: service_healthy
    restart: unless-stopped
    volumes:
      - uploads:/app/uploads

  db:
    image: postgres:16-alpine
    environment:
      - POSTGRES_USER=byaboneka
      - POSTGRES_PASSWORD=byaboneka_dev
      - POSTGRES_DB=byaboneka_plus
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U byaboneka -d byaboneka_plus"]
      interval: 5s
      timeout: 5s
      retries: 5

volumes:
  pgdata:
  uploads:


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: Dockerfile
‚îÇ Language: Text | Lines: 55 | Size: 1.3 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# ============================================
# Byaboneka+ API - Production Dockerfile
# Multi-stage build for minimal image size
# ============================================

# Stage 1: Build
FROM node:20-alpine AS builder

WORKDIR /app

# Install build dependencies for sharp
RUN apk add --no-cache python3 make g++ vips-dev

COPY package*.json ./
RUN npm ci

COPY tsconfig.json ./
COPY src/ ./src/

# Compile TypeScript
RUN npx tsc

# Remove dev dependencies
RUN npm prune --production

# Stage 2: Production
FROM node:20-alpine AS production

WORKDIR /app

# Install runtime dependencies for sharp only
RUN apk add --no-cache vips tini

# Copy compiled code and production deps
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# Create uploads directory and non-root user
RUN mkdir -p uploads && \
    addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup && \
    chown -R appuser:appgroup /app

USER appuser

EXPOSE 4000

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:4000/api/v1/health || exit 1

# Use tini for proper PID 1 signal handling
ENTRYPOINT ["/sbin/tini", "--"]
CMD ["node", "dist/index.js"]


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: jest.config.js
‚îÇ Language: JavaScript | Lines: 35 | Size: 773 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

/** @type {import('ts-jest').JestConfigWithTsJest} */
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/tests'],
  testMatch: [
    '**/*.test.ts',
    '**/*.spec.ts'
  ],
  moduleFileExtensions: ['ts', 'js', 'json'],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'text-summary', 'lcov', 'html'],
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/index.ts',
    '!src/migrations/**',
    '!src/seeds/**',
    '!src/types/**',
    '!src/config/swagger.ts',
  ],
  coverageThreshold: {
  global: {
    branches: 60,
    functions: 70,
    lines: 70,
    statements: 70,
  },
},

setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  testTimeout: 30000,
  verbose: true,
  forceExit: true,
  detectOpenHandles: true,
};


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: package.json
‚îÇ Language: JSON | Lines: 73 | Size: 2.3 KB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

{
  "name": "byaboneka-plus-backend",
  "version": "1.0.0",
  "description": "Trust-Aware Lost & Found Infrastructure for Rwanda - Backend API",
  "main": "dist/index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "migrate": "ts-node src/migrations/run.ts",
    "migrate:down": "ts-node src/migrations/rollback.ts",
    "seed": "ts-node src/seeds/run.ts",
    "test": "jest --forceExit --detectOpenHandles",
    "test:coverage": "jest --coverage --forceExit --detectOpenHandles",
    "test:watch": "jest --watch",
    "test:unit": "jest --testPathPattern=tests/unit --forceExit",
    "test:integration": "jest --testPathPattern=tests/integration --forceExit --detectOpenHandles",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "format": "prettier --write src/**/*.ts",
    "docker:build": "docker build -t byaboneka-plus-api .",
    "docker:run": "docker run -p 4000:4000 --env-file .env byaboneka-plus-api"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "pg": "^8.11.3",
    "sharp": "^0.33.2",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^9.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.11",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/morgan": "^1.9.9",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.10.6",
    "@types/node-cron": "^3.0.11",
    "@types/pg": "^8.10.9",
    "@types/supertest": "^6.0.2",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^9.0.7",
    "@typescript-eslint/eslint-plugin": "^6.18.0",
    "@typescript-eslint/parser": "^6.18.0",
    "eslint": "^8.56.0",
    "jest": "^29.7.0",
    "prettier": "^3.1.1",
    "supertest": "^6.3.3",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "author": "MAYALA Plamedi",
  "license": "MIT"
}


‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ FILE: tsconfig.json
‚îÇ Language: JSON | Lines: 27 | Size: 521 B
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "lib": ["ES2022"],

    "outDir": "./dist",
    "rootDir": "./src",

    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,

    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,

    "isolatedModules": true,

  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}



‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  END OF DUMP ‚Äî 63 files | 16,555 lines
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê